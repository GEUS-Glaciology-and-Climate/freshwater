#+Latex_Class: copernicus
#+AUTHOR: 
#+LaTeX_CLASS_OPTIONS: [essd, manuscript]
#+Options: toc:nil ^:t {}:t

# #+LATEX_HEADER_EXTRA: \usepackage{showlabels}

#+PROPERTY: header-args :eval no :noweb yes :comments both
#+PROPERTY: header-args:bash+ :eval no-export :noweb yes :comments both
#+PROPERTY: header-args:bash+ :session (concat "*" (file-name-sans-extension (buffer-name)) "-shell*")
#+PROPERTY: header-args:bash+ :tangle-mode (identity #o744) :shebang #!/usr/bin/env bash
#+PROPERTY: header-args:jupyter-python+ :session freshwater
#+PROPERTY: header-args:jupyter-python+ :eval no-export :noweb yes :comments both
#+PROPERTY: header-args:elisp+ :eval no-export :noweb yes
#+PROPERTY: header-args:python+ :eval no-export :noweb yes

#+EXCLUDE_TAGS: noexport

# WARNING: infinite recursion if not ":eval no"
#+header: :eval no
#+name: workflow-update
#+BEGIN_SRC emacs-lisp :results none :eval no :results none :exports none
(progn
  (require 'notifications)
  (org-make-toc)

  ;; remove #+results: blocks
  (org-babel-map-src-blocks nil (if (org-babel-where-is-src-block-result) 
				    (org-babel-insert-result "" '("replace"))))
  (save-buffer) ;; can now inspect "missing" results w/ git wdiff
  (org-babel-execute-buffer) ;; this make take a few whiles
  (save-buffer)
  (notifications-notify
   :title "Review with 'git wdiff'"
   :body "Note: :async results may not be finished"
   :timeout 5000
   :transient t))
#+END_SRC

#+RESULTS: workflow-update

#+BEGIN_EXPORT LaTeX
\title{Greenland liquid water runoff from 1979 through 2017}
\Author[1]{Kenneth D.}{Mankoff}
\Author[1]{Andreas P.}{Ahlstrøm}
\Author[1]{William}{Colgan}
\Author[1]{Robert S.}{Fausto}
\Author[2]{Xavier}{Fettweis}
\Author[3]{Ken}{Kondo}
\Author[4]{Kirsty}{Langley}
\Author[5]{Brice}{Noël}
\Author[3]{Shin}{Sugiyama}
\Author[1]{Dirk}{van As}
\affil[1]{Department of Glaciology and Climate, Geological Survey of Denmark and Greenland (GEUS), Copenhagen, Denmark}
\affil[2]{Department of Geography, University of Liège, Belgium}
\affil[3]{Institute of Low Temperature Science, Hokkaido University, Japan}
\affil[4]{Asiaq-Greenland Survey, Nuuk, Greenland}
\affil[5]{Institute for Marine and Atmospheric Research, Utrecht University, The Netherlands}
\runningtitle{Greenland liquid water runoff}
\runningauthor{K. D. Mankoff \textit{et al.}}
\correspondence{Ken Mankoff (kdm@geus.dk)}

\received{}
\pubdiscuss{}
\revised{}
\accepted{}
\published{}
%% These dates will be inserted by ACPD
\firstpage{1}
\maketitle

\newcommand{\textcite}[1]{\citet{#1}}
\newcommand{\autocite}[1]{\citep{#1}}
#+END_EXPORT

#+BEGIN_abstract
We present a high-resolution map of Greenland hydrologic outlets, basins, and streams, and a 1979 through 2017 time series of Greenland liquid water runoff for each outlet. Outlets, basins, and streams are derived from traditional hydrologic routing algorithms over the surface of a 100 m ArcticDEM digital elevation model (DEM) twice: Once to the ice margin and once to the coast. We then partition liquid water runoff from both ice and land from two regional climate models (RCMs; MAR and RACMO) into each basin and at each outlet location. The data include call_bsc[:session](d="ice", m=0) {{{results(=18903=)}}} ice basins and outlets (call_bsc[:session](d="ice", m=10) {{{results(=614=)}}} basins greater than 10 km^2), call_bsc[:session](d="land", m=0) {{{results(=30241=)}}} land basins and outlets (call_bsc[:session](d="land", m=10) {{{results(=958=)}}} basins greater than 10 km^2), major streams in each basin, and daily runoff water volume flow rate at each outlet from each of two RCMs. We perform a sensitivity study of outlet location change for every ice sheet location over a range of hydrologic routing assumptions and data sets. Annual ice runoff ranges from ~136 km^{3} in 1992 to ~785 km^{3} in 2012. Daily maximum ice runoff from one basin is as large as 4380 m^{3} s^{-1}. Both ice runoff magnitude and variability increase over the time series. Land runoff contributes an additional ~35 % to the ice runoff. Comparison with 8 basins instrumented with stream gauges shows a range of (dis)agreement from poor to excellent between our estimated discharge and observations. As part of the journal's living archive option, and our goal to make an operational product, all input data, code, and results from this study will be updated as needed (when new input data are available, as new features are added, or to fix bugs) and made available at
doi:10.22008/promice/data/freshwater_runoff/v01 citep:GEUS_freshwater_paper and at http://github.com/mankoff/freshwater.
#+END_abstract

# basin size count
#+NAME: bsc
#+BEGIN_SRC bash :results verbatim :var d="ice" m=0 :eval yes :exports none :session
m2=$(( m * 1000 * m * 1000 )) # km to m^2
awk -v m2="${m2}" -F, '$2 > m2 { count++ } END {print count}' freshwater/${d}_surf/basins.csv
#+END_SRC

#+RESULTS: bsc
: 18903

* Table of Contents                               :toc_2:noexport:
- [[#about-this-document][About This Document]]
  - [[#workflow][Workflow]]
- [[#introduction][Introduction]]
- [[#input-data][Input Data]]
- [[#methods][Methods]]
  - [[#streams-outlets-and-basins][Streams, Outlets, and Basins]]
  - [[#coverage][Coverage]]
- [[#product-description][Product Description]]
- [[#results][Results]]
- [[#discussion][Discussion]]
  - [[#comparison-with-previous-similar-work][Comparison with previous similar work]]
  - [[#validation-against-observations][Validation against observations]]
  - [[#uncertainty][Uncertainty]]
  - [[#other-sources-of-freshwater][Other sources of freshwater]]
- [[#data-and-code-availability][Data and Code Availability]]
  - [[#readme][README]]
- [[#conclusions][Conclusions]]
- [[#misc][Misc]]
- [[#references][References]]
- [[#algorithms][Algorithms]]
  - [[#streams-outlets-and-basins-1][Streams, outlets, and basins]]
  - [[#model-output-routing][Model output routing]]
  - [[#makefile][Makefile]]
- [[#data][Data]]
  - [[#provenance][Provenance]]
  - [[#import-data][Import Data]]
- [[#quality-control][Quality control]]
  - [[#streams-outlets-and-basins-2][Streams, Outlets, and Basins]]
  - [[#outputs][Outputs]]
  - [[#raw-v-processed-for-ice--land][Raw v. processed for ice & land]]
  - [[#watson][Watson]]
  - [[#gem-rivers][GEM rivers]]
- [[#usage-examples][Usage Examples]]
  - [[#load-data][Load Data]]
  - [[#all-outlets-inside-a-region][All outlets inside a region]]
  - [[#outlet-nearest-a-single-point][Outlet nearest a single point]]
  - [[#ice-outlets-draining-through-a-nearby-coast-outlet][Ice outlets draining through a nearby coast outlet]]
  - [[#subset-by-simple-region-sum-across-region-and-by-month][Subset by simple region, sum across region and by month]]
- [[#supplemental-material][Supplemental Material]]
  - [[#coverage-1][Coverage]]
  - [[#basin-changes-with-changing-k][Basin changes with changing k]]
- [[#figures][Figures]]
  - [[#overview][Overview]]
  - [[#coverage-2][Coverage]]
  - [[#annual-runoff][Annual Runoff]]
  - [[#watson-runoff][Watson runoff]]
  - [[#watson-basins][Watson basins]]
  - [[#change-in-outlet][Change in Outlet]]
  - [[#gem-basin][GEM Basin]]
  - [[#qaanaaq][Qaanaaq]]
- [[#appendix][Appendix]]
  - [[#software][Software]]
  - [[#changing-basins-with-changing-routing-schemes][Changing basins with changing routing schemes]]
- [[#meta][Meta]]
  - [[#set-up-git][Set up git]]
  - [[#software-1][Software]]
- [[#latex-setup][LaTeX Setup]]

* About This Document                                   :noexport:

This document is an Emacs Org Mode plain-text file with code and text embedded. If you are viewing:

+ A DOC, Google Doc, or PDF file, then it was generated by exporting from Org. Not all of the Org parts (code, results, comments, etc.) were exported. The Org source file is available upon request, and may be embedded in the PDF. Most non-Apple PDF viewers provide easy access to embedded or attached files.
 
+ A webpage somewhere, then this is a subset of the code and text that the website render has decided to display to you through the browser. You can choose to view the raw source and/or download it and view it locally on your computer.

+ A file with a =org= extension in something other than Emacs, then you are seeing the canonical version and the full source, but without any syntax highlighting, document structure, or the ability to execute the code blocks.

+ An =Org= file within Emacs, then this is the canonical version. You should be able to fully interact and reproduce the contents of this document, although it may require 3rd-party applications (Python, etc.) a similar Emacs configuration, and the data files. This is available upon request.

** Workflow

To recreate this work

+ Open this file in Emacs Org Mode.
+ check that you have the necessary software dependencies installed. See section: [[*Code][Code]].
+ Download and set up the necessary data files as per the [[*Data][Data]] section
+ Tangle the embedded code blocks.
  + Execute =C-c C-v C-t= to run the (org-babel-tangle) function
+ Run =make=
  + This should probably be run in an external terminal because it takes hours to days...
+ Update Babel result blocks throughout the document by
  + Cleaning all result blocks with =C-u C-c C-v k= or (org-babel-remove-result-one-or-many t), then
  + Executing all blocks (without =:eval no=) using =C-c C-v C-b= or (org-babel-execute-buffer)

This is captured programatically by [[workflow-update]]

* Introduction

# The mass budget of the Greenland ice sheet has on average been negative since the beginning of the new millennium citep:mouginot_2019_forty. The mass budget of the ice sheet is primarily the net balance between mass gain by snow accumulation, mass loss from the surface from melting (runoff) and mass loss across the grounding line from iceberg production and submarine melt. The runoff mass losses originate from changes in the surface energy balance, e.g. temperature, incoming solar radiation, and precipitation, which in turn governs the liquid water runoff (REFS).

Over the past decades, liquid runoff from Greenland has increased citep:mernild_2012_greenland,bamber_2018_freshwater,trusel_2018_nonlinear,perner_2019_greenland. When that runoff leaves the ice sheet and enters fjords and coastal seas, it influences a wide range of physical citep:straneo_2011_impact,an_2012_impact,mortensen_2013_seasonal,bendtsen_2015_heat,cowton_2015_modeling,mankoff_2016_structure,fried_2019_distinct,cowton_2019_sensitivity,beckmann_2019_modeling, chemical citep:kanna_2018_upwelling,balmonte_2019_sharp, and biological citep:kamenos_2012_reconstructing,kanna_2018_upwelling,balmonte_2019_sharp systems citep:catania_2019_future. The influence of freshwater on multiple domains and disciplines citep:catania_2019_future is the reason several past studies have estimated runoff at various temporal and spatial scales citep:mernild_2008_surface,mernild_2009_greenland,mernild_2010_freshwater,langen_2015_quantifying,ahlstrom_2017_abrupt,citterio_2017_towards,van-as_2018_reconstructing,bamber_2018_freshwater,perner_2019_greenland,slater_2019_estimating. 

Freshwater discharge from Greenland primarily takes three forms: solid ice from calving at marine terminating glaciers, submarine meltwater at marine terminating glaciers, and liquid runoff from surface melt, condensation, and rainfall. Immediately upstream from the grounding line, no submarine melting has occurred and that water is still solid ice. A recent paper by citet:mankoff_2019_ice targets the solid ice discharge budget by estimating solid ice discharge across flux gates 5 km upstream from all fast-flowing marine terminating glaciers in Greenland. Complementing that paper, this paper targets Greenland's point-source liquid water runoff budget by partitioning RCM runoff estimates to all ice margin and coastal outlets. The sum of this data product and citet:mankoff_2019_ice is an estimate of the majority of freshwater (liquid and solid ice) volume flow rates into Greenland fjords. Those two terms comprise the bulk but not all of freshwater volume - they exclude relatively minor contributions from precipitation directly onto the fjord surface, evaporation and condensation, sea ice formation and melt, or subglacial basal melting. Much work remains to determine which portion of solid ice across a flux gate becomes submarine melt, and where and when the solid ice, i.e. icebergs, melts in the fjord.

In this data set description we present a Greenland wide product of liquid water runoff time series and a high-resolution map of hydrologic outlets, basins, and streams. The daily runoff water volume flow rate for the period of 1979 through 2017 are based on runoff from land or ice estimated by two regional climate models (RCMs) and has a 100 m spatial resolution including outlets, basins, and streams (at the ice margin and coast). In the following description and methods, we document the inputs, assumptions, methodologies, and results we use to estimate Greenland runoff from 1979 through 2017. This product is available at doi:10.22008/promice/data/freshwater_runoff/v01 citep:GEUS_freshwater_paper.

# and produce a comprehensive operational data product of liquid water runoff at high spatial and temporal resolution. Here we present a 100 m spatial resolution data set of Greenland outlets, basins, and streams (ice margin and coast), and a 1979 through 2017 daily temporal resolution regional climate model (RCM) data set of discharge through each outlet. Included with the outlet metadata is outlet elevation which identifies land-terminating from subglacial discharge at marine terminating glaciers. 

* Input Data

The static products (streams, outlets, and basins (Fig. [[fig:overview]])) are derived from an ice-sheet surface DEM, an ice-sheet mask, the land surface DEM, and an ocean mask. For the surface DEM, we use the ArcticDEM v7 100 m product citep:ArcticDEM. When using subglacial routing, we use ice thickness from BedMachine v3 citep:morlighem_2017_bedmachine,NSIDC_BedMachine_GL. For the ice mask we use the Programme for Monitoring of the Greenland Ice Sheet (PROMICE) Ice Extent citep:citterio_2013_brief. For the ocean mask we use the Making Earth System Data Records for Use in Research Environments (MEaSUREs) Greenland Ice Mapping Project (GIMP) Land Ice and Ocean Classification Mask, Version 1 citep:NSIDC_0714,howat_2014_greenland. Satellite basemap imagery comes from citep:howat_2014_greenland, specifically the National Snow and Ice Data Center (NSIDC) MEaSUREs GIMP data set with ID 0713 citep:NSIDC_0713.

The time series product (daily runoff) is derived from gridded daily runoff estimates from RCM calculations over the land and ice areas of Greenland. The daily runoff comes from the Modèle Atmosphérique Régional (MAR; citet:fettweis_2017_reconstructions, 15 km resolution) and the Regional Atmospheric Climate Model (RACMO; citet:noel_2018_modelling, 5.5 km resolution) and runoff, \(R\), is defined by

#+NAME: eq:runoff
\begin{equation}
R = ME + RA - RT - RF
\end{equation}

where \(ME\) is melt, \(RA\) is rainfall, \(RT\) is retention, and \(RF\) is refreezing. In RACMO, retention occurs only when there is firn, not with bare ice, while MAR has a runoff delay for bare ice runoff, but not land runoff. Both RCM results were provided regridded to a 1 km resolution using an offline statistical down-scaling technique based on local vertical runoff gradient applied to the sub-grid topography. MAR simulations were run using version 3.9.6 citep:delhasse_2019_brief. RACMO simulations were run using version 2.3p2. Both RCMs use ERA-Interim 6-hour forcing.

* Methods
** Streams, Outlets, and Basins                           :ignore:

Streams are calculated from the hydrologic head elevation, that is the DEM surface for surface routing, or the subglacial pressure head elevation for subglacial routing (only performed as part of the uncertainty estimate). Outlets are defined as the grid cell location where streams terminate at the ice margin or coastal boundary. Each outlet has one upstream basin and each basin has one outlet. Only major streams are defined, so small basins may have outlets but no streams.

We use the GRASS GIS software package citep:neteler_2012_GRASS,GRASS_GIS_software  =r.stream.extract= tool configured for multi-flow direction from eight neighbors (MFD-8) to calculate the primary flow direction and outlets at the ice edge and coast, and then the =r.stream.basins= tool to calculate basins and streams upstream from each outlet citep:jasiewicz_2011_hortonian. Basins < 1 km^{2} are absorbed into their largest neighbor and the associated outlets are dropped.

Finally, for both domains (land and ice) we calculate zonal statistics for each basin and day for the RCM ice and land runoff. Outlet metadata data includes the BedMachine elevation at the outlet location. When this value is negative, it indicates submarine (subglacial) discharge.

** Coverage
:PROPERTIES:
:CUSTOM_ID:  sec:methods:coverage
:END:

Each 100 m^{2} pixel is classified as ice, land, or fjord. However, the ice boundary citep:citterio_2013_brief, the coast boundary citep:NSIDC_0714, and the 1 km^{2} statistically-downscaled RCM domains do not always agree with each other on the classification of a given grid cell. A disagreement occurs, for example, when a basin cell is classified as glacier in citet:citterio_2013_brief but the matching RCM cell is land, or vice versa. This disagreement occurs almost everywhere along the ice margin because the 1 km resolution RCM boundary and the 100 m mask boundary rarely perfectly align. It also occurs wherever nunatuks exist, because ice-sheet interior "holes" are filled, otherwise they falsely act as interior drains. The ice margin is also where the majority of runoff occurs due to the highest temperatures at the lowest ice elevations. Small changes in masks in these locations can introduce large changes in RCM outputs.

We adjust the RCM results to the basin using the following method (Fig. [[fig:coverage]]). Where the surface mask reports ice and a RCM reports land, the RCM land runoff fraction is discarded (this reduces annual average runoff by ~5 %), and the RCM ice runoff fraction over this basin is used to compensate for the uncovered basin cells. For example, if an ice basin is only 90 % covered by ice in an RCM, the runoff is divided by 0.9 to estimate total runoff. Where a basin reports land and the RCM reports ice, the same method as above is applied, but for land. When a small basin has no RCM cells of the same classification covering any part of it, that basin never has any reported runoff. This method means that RCM runoff is not conserved through this work - RCM inputs to our algorithm do not equal our reported output which are ~3 % higher on an annual average.

Runoff adjustments using this method are underestimated for large basins with large inland high elevation regions with low runoff, because this method fills in misaligned cells with each days average runoff, but the misalignment (missing runoff) occurs at the ice sheet edge where maximum runoff occurs. However, given that the basin is large, misalignment is proportionally small, and therefore errors are proportionally small. When misalignment is proportionally large (e.g. a basin is only ~1 % covered by the same RCM classification), that implies a small basin. In the case of a small basin, the covered part must be near the uncovered part, the infilling method therefore uses spatially nearby data, and there is no underestimate.

At the basin scale, fractional coverage ranges from 0 to 1. Coverage equal to 0 occurs where a basin does not have a MAR or RACMO cell of the same type (ice or land) over any part of it. Coverage close to 0 occurs where a basin has one grid cell (100 m^{2}) overlapped by a MAR or RACMO cell of the same type, but the rest of the basin has no overlap. Coverage equal to 1 occurs where a basin is completely overlapped by MAR or RACMO cells of the same type. 

RCM inputs are also scaled by the projection area error between the EPSG:3413 map projection of the RCM and an approximation of the true earth spheroid. This error is up to 8 % for some grid cells, but ranges from - 6 % to + 8 % over Greenland and the cumulative error for the entire ice sheet is < 8 %.

# TODO: Histogram (2D hexbin heatmap?) of covearge v. basin area? Coverage v. runoff?

* Product Description

This liquid water runoff product for Greenland contains a static map of Greenland's hydrological outlets, basins, and streams and a times-series of runoff from each outlet.

The output data is provided in the following formats:

*** Streams                                               :ignore:

The stream product is provided as a GeoPackage standard GIS product and a metadata CSV that includes the stream type (start or intermediate segment), network, stream along-flow length, stream straight length, sinuosity, source elevation, outlet elevation, and a variety of stream indices such as the Strahler, Horton, Shreve, Hack, and other parameters citep:jasiewicz_2011_hortonian.

*** Outlets                                               :ignore:

The outlet product is also provided as a GeoPackage and CSV, each of which include the outlet ID (linked to the basin ID), the longitude, latitude, EPSG:3413 x and y, and the outlet elevation.

*** Basins                                                :ignore:

The basin product GeoPackage includes the geospatial region that defines the basin. The metadata CSV includes the basin ID (linked to the outlet ID), and the area of each basin.

*** Discharge                                             :ignore:

The time-series discharge product is provided as annual NetCDF files, four per year, one for each domain (ice margin, land coast) and one for each RCM (MAR and RACMO). The NetCDF file contains an unlimited time dimension, usually containing 365 or 366 days, much of the same metadata as the outlets CSV file, including the outlet (a.k.a station) ID, the latitude, longitude, and altitude of the outlet, and a runoff variable with dimensions (station, time) and units m^{3} s^{-1}.


* Results
:PROPERTIES:
:header-args:bash+: :eval yes :session
:END:

Results of this work include 1) ice-margin terminating streams, outlets, and basins, 2) coast-terminating streams, outlets, and basins (this product is a super-set of (1), and includes the upstream ice streams and basins), 3) runoff at the ice-marginal outlets from ice runoff and 4) runoff at the coastal outlets from land runoff. Runoff ice products are in duplicate from the MAR and RACMO RCMs.

Fig. [[fig:overview]] illustrates call_bsc(d="ice", m=0) {{{results(=18903=)}}} ice basins and outlets and call_bsc(d="land", m=0) {{{results(=30241=)}}} land basins and outlets. Among these ice basins  we find call_bsc(d="ice", m=10) {{{results(=614=)}}} greater than 10 km^2 and call_bsc(d="ice", m=100) {{{results(=42=)}}} greater than 100 km^2, while the land basins have call_bsc(d="land", m=10) {{{results(=958=)}}} greater than 10 km^2 and call_bsc(d="land", m=100) {{{results(=47=)}}} grater than 100 km^2. 

Overall this amounts to 1,807,264 km^{2} of basin ice cells, of which 1,769,087 km^{2} are covered by ice in MAR, 37,669 km^{2} are covered by land, and 479 km^{2} are covered by fjord. There are 336,497 km^{2} of basin land cells, of which 306,256 km^{2} are covered by land in MAR, 10,569 km^{2} are covered by ice, and 19,672 km^{2} are covered by fjord. The total Greenland coverage of RACMO is similar (Table and data available in Supplemental Online Material).

Our grid cell land classification correction adjusts RCM ice runoff values by ~8 %. As mentioned, the misalignment between the ice, land, and ocean masks and the RCM land type results in a total ice sheet runoff ~5 % less than the RCM runoff inputs when runoff is only accumulated where the RCM ice grid cells align with the basin ice grid cells. However, when our coverage algorithm is subsequently applied to adjust RCM inputs for regions where basins have ice but the RCMs do not, total ice sheet runoff is ~3 % more than the RCM inputs. A similar adjustment occurs for RCM land runoff.

Figure [[fig:annual_runoff]] shows the time-series product spanning the period from src_bash{ls freshwater/runoff/margin/|head -n1|sed 's/[^0-9]*//g'} {{{results(=1979=)}}} through src_bash{ls freshwater/runoff/margin/|tail -n1|sed 's/[^0-9]*//g'} {{{results(=2017=)}}}, containing src_bash{parallel "ncdump -h {} | grep UNLIMITED" ::: $(ls freshwater/runoff/margin/runoff_ice_MAR_*.nc) | sed 's/[^0-9]*//g'|datamash sum 1} {{{results(=14244=)}}} days. Daily runoff values range from a minimum of 0 m^{3} to a maximum of call_rmax(type="max") {{{results(=4380=)}}} m^{-3} on call_rmax(type="date") {{{results(='2012-08-06'=)}}} located on the western part of the ice sheet south of Sermeq Kujalleq (Jakobshavn Isbræ) (50.68 E, 68.31 N, 203 m a.s.l). Annual runoff has a maximum of call_rmax(type="maxann") {{{results(=18=)}}} km^{3} from one basin (a similar value as reported by citet:lewis_2009_hydrologic).

#+NAME: rmax
#+BEGIN_SRC jupyter-python :session runoff_max :var type="max" :exports none :results value :eval no-export :display plain
import xarray as xr
import numpy as np

if 'ds' not in locals():
    ds = xr.open_mfdataset("./freshwater/runoff/margin/runoff_ice_MAR_*.nc", combine='by_coords')

if type == "max":
    m = ds['runoff'].max().values.astype(np.int)
    idx = np.where((ds['runoff'] > (m-0.01)) == True)
    mm = ds.isel(station=idx[0], time=idx[1])
    r = m.flatten()[0]

if type == "maxann":
    dsann = ds['runoff'].resample(time='A').sum()
    m = dsann.max().values.astype(np.int)
    idx = np.where((dsann > (m-0.00001)) == True)
    mm = dsann.isel(station=idx[0], time=idx[1])
    r = np.round(mm.values[0][0] * 86400/1E9).astype(np.int)

if type == "date":
    r = mm['time'].values.astype(np.str)[0][0:10]

if type == "loc":
    loc = np.round(mm['lon'].values[0],2).astype(np.str) + " " + \
        np.round(mm['lat'].values[0],2).astype(np.str) + " " + \
        np.round(mm['alt'].values[0]).astype(np.int).astype(np.str)
    r = loc

r
#+END_SRC

#+RESULTS: rmax
: 4380

#+CALL: rmax[:exports none](type="loc")

#+RESULTS:
: -50.68 68.31 203

#+BEGIN_SRC jupyter-python :session session :exports none :results raw drawer
<<load_this_data>>

df_ann = df.resample('A').sum()

df_ann['land %'] = df_ann['MAR land'] / df_ann['MAR ice'] * 100
df_ann['MAR total'] = df_ann['MAR ice'] + df_ann['MAR land']

df_ann
#+END_SRC

#+RESULTS:
| time                | MAR ice | MAR land | RACMO ice |  land % | MAR total |
|---------------------+---------+----------+-----------+---------+-----------|
| 1979-12-31 00:00:00 | 239.215 |  120.519 |   261.792 | 50.3813 |   359.734 |
| 1980-12-31 00:00:00 | 321.245 |  116.775 |   347.483 | 36.3508 |    438.02 |
| 1981-12-31 00:00:00 | 343.306 |  118.648 |   391.154 | 34.5605 |   461.955 |
| 1982-12-31 00:00:00 | 271.162 |  102.364 |   312.212 |   37.75 |   373.526 |
| 1983-12-31 00:00:00 | 203.528 |  136.643 |   216.894 | 67.1375 |   340.171 |
| 1984-12-31 00:00:00 |  345.82 |  136.167 |    335.31 | 39.3753 |   481.987 |
| 1985-12-31 00:00:00 | 353.941 |  111.216 |   379.942 | 31.4221 |   465.157 |
| 1986-12-31 00:00:00 | 244.377 |  113.092 |   258.204 | 46.2777 |    357.47 |
| 1987-12-31 00:00:00 | 370.967 |  134.777 |   388.581 | 36.3312 |   505.744 |
| 1988-12-31 00:00:00 | 362.103 |  123.501 |   363.659 | 34.1066 |   485.604 |
| 1989-12-31 00:00:00 | 354.811 |  112.768 |   367.989 | 31.7826 |   467.579 |
| 1990-12-31 00:00:00 | 385.618 |  131.495 |   428.978 | 34.0998 |   517.113 |
| 1991-12-31 00:00:00 | 350.413 |  126.976 |   362.512 | 36.2361 |   477.389 |
| 1992-12-31 00:00:00 | 136.595 |  112.908 |   191.468 | 82.6589 |   249.503 |
| 1993-12-31 00:00:00 | 335.916 |  130.219 |   395.871 | 38.7653 |   466.135 |
| 1994-12-31 00:00:00 | 281.519 |  116.345 |   322.976 | 41.3277 |   397.865 |
| 1995-12-31 00:00:00 | 382.108 |  118.946 |   432.718 | 31.1288 |   501.054 |
| 1996-12-31 00:00:00 | 262.361 |  134.357 |    294.48 | 51.2106 |   396.718 |
| 1997-12-31 00:00:00 | 327.286 |  136.939 |   350.949 | 41.8408 |   464.225 |
| 1998-12-31 00:00:00 | 463.182 |  135.165 |   487.184 | 29.1819 |   598.348 |
| 1999-12-31 00:00:00 |  335.31 |  126.997 |   362.449 | 37.8744 |   462.307 |
| 2000-12-31 00:00:00 | 369.192 |  131.905 |   386.502 | 35.7281 |   501.097 |
| 2001-12-31 00:00:00 | 369.755 |  130.326 |   405.228 | 35.2466 |   500.081 |
| 2002-12-31 00:00:00 | 440.602 |  146.097 |   484.532 | 33.1586 |   586.699 |
| 2003-12-31 00:00:00 | 574.072 |  133.605 |   561.886 | 23.2732 |   707.677 |
| 2004-12-31 00:00:00 | 451.576 |  144.358 |   470.637 | 31.9675 |   595.933 |
| 2005-12-31 00:00:00 | 517.627 |  160.801 |   507.213 |  31.065 |   678.429 |
| 2006-12-31 00:00:00 | 415.921 |  141.183 |   420.856 | 33.9446 |   557.103 |
| 2007-12-31 00:00:00 |  573.23 |  131.716 |   546.749 | 22.9778 |   704.946 |
| 2008-12-31 00:00:00 | 561.339 |  158.919 |   547.155 | 28.3108 |   720.259 |
| 2009-12-31 00:00:00 | 396.559 |  120.676 |    411.83 | 30.4307 |   517.235 |
| 2010-12-31 00:00:00 | 668.999 |   128.12 |   666.347 |  19.151 |   797.119 |
| 2011-12-31 00:00:00 |  550.38 |  112.614 |   540.873 | 20.4611 |   662.994 |
| 2012-12-31 00:00:00 | 785.476 |  142.703 |   693.246 | 18.1677 |   928.179 |
| 2013-12-31 00:00:00 |  367.48 |  113.598 |   387.134 | 30.9127 |   481.078 |
| 2014-12-31 00:00:00 | 499.922 |   127.11 |   502.671 |  25.426 |   627.032 |
| 2015-12-31 00:00:00 | 430.788 |  137.286 |   438.269 | 31.8685 |   568.074 |
| 2016-12-31 00:00:00 | 613.969 |  124.751 |   582.834 | 20.3189 |    738.72 |
| 2017-12-31 00:00:00 | 437.565 |  152.327 |   427.326 | 34.8124 |   589.892 |

#+BEGIN_SRC jupyter-python :session session :exports none :results raw drawer
print("TOTAL\n", df_ann.describe())
print("\nFIRST DECADE\n", df_ann.iloc[:10].describe())
print("\nLAST DECADE\n", df_ann.iloc[-10:].describe())
#+END_SRC

#+RESULTS:
#+begin_example
TOTAL
           MAR ice    MAR land   RACMO ice     land %   MAR total
count   39.000000   39.000000   39.000000  39.000000   39.000000
mean   402.441995  129.100362  416.258760  35.308233  531.542357
std    131.401137   13.307510  111.481784  12.138483  137.569416
min    136.595222  102.363689  191.467517  18.167711  249.503300
25%    335.613235  118.797008  356.699143  30.671721  463.266165
50%    369.755210  130.218790  395.871074  34.099847  501.053995
75%    457.378954  136.405464  485.857620  37.812165  597.140486
max    785.475995  160.801049  693.245624  82.658878  928.179007

FIRST DECADE
           MAR ice    MAR land   RACMO ice     land %   MAR total
count   10.000000   10.000000   10.000000  10.000000   10.000000
mean   305.566484  121.370324  325.522975  41.369286  426.936808
std     60.411905   11.540467   61.326469  10.723845   62.552784
min    203.527741  102.363689  216.893567  31.422097  340.171233
25%    251.073693  114.012980  274.397027  35.003143  363.182195
50%    332.275659  119.583868  341.396619  37.050389  449.987343
75%    351.910916  131.957863  375.870924  44.552084  477.779688
max    370.967242  136.643492  391.153501  67.137527  505.744107

LAST DECADE
           MAR ice    MAR land   RACMO ice     land %   MAR total
count   10.000000   10.000000   10.000000  10.000000   10.000000
mean   531.247723  131.810433  519.768541  25.985979  663.058157
std    131.880746   15.684999  106.183751   6.080380  136.346254
min    367.479877  112.613981  387.134118  18.167711  481.077824
25%    432.482209  121.694705  430.061811  20.354427  573.528249
50%    525.150943  127.615015  521.772295  26.868376  645.012995
75%    600.811558  141.348701  573.914010  30.792210  734.105030
max    785.475995  158.919493  693.245624  34.812381  928.179007
#+end_example

Annual average ice runoff has a 1979 through 2017 mean of ~400 km^{3}, a 1992 minimum of 136 km^{3} (MAR ice) and 191 km^{3} (RACMO ice), and a 2012 maximum of 785 km^{3} (MAR) and 693 km^{3} (RACMO) (Fig. [[fig:annual_runoff]]). The 1992 low is likely due to the Mt. Pinatubo eruption, and then 2nd lowest runoff year, 1983, due to El Chichón eruption. The land runoff (MAR only) contributes an additional 35 % to the ice runoff on average, with a range from 18 % (142 km^{3} during the 2012 high ice-runoff year) to 83 % (112 km^{3} during the 1992 low ice-runoff year).

During the first decade of the time series, ice runoff had a mean of 305 km^{3} (MAR) or 325 km^{3} (RACMO), ranged from ~200 km^{3} to ~390 km^{3}, and had an annual standard deviation of 60 km^{3}. During the last decade of the time series, ice runoff had a mean of 531 km^{3} (MAR) or 519 km^{3} (RACMO), ranged from ~370 km^{3} to 785 km^{3}, and had an annul standard deviation of 130 km^{3}. From this, it is evident that ice runoff varies widely but increases in both magnitude and variability over the duration of the time-series.

# We also compare our runoff estimate with discharge measurements at eight land- and glacier- fed rivers including a major basin on the western part of the Greenland ice sheet (Watson River, from citet:van-as_2018_reconstructing), six stream gauges from the Greenland Ecosystem Monitoring (GEM) project, and one in northwest Greenland near Qaanaaq.

# . Our runoff agrees well for low runoff but is only approximately 50 % for high runoff (Fig. [[fig:vanAs_compare]]). When we include one or two ice basins to the south, our modeled (MAR and RACMO) runoff estimates match well (Fig. [[fig:vanAs_compare]]).

* Discussion
:PROPERTIES:
:header-args:bash+: :eval yes :session
:END:
** Comparison with previous similar work

# To summarize this product, we work at 100 m spatial resolution to provide call_bsc(d="ice", m=1) {{{results(=18903=)}}} ice basins and call_bsc(d="land", m=1) {{{results(=30241=)}}} land basins, although many of those are < 10 km^{2} and therefore may have limited utility. Each basin has one outlet, and all large basins have streams.

#  basins and outlets at the ice edge, src_sh{wc -l ./out/coast/outlets.csv | tr -dc [0-9]} {{{results(=31241=)}}} basins and outlets at the coast, estimated stream locations, and a variety of daily time-series from two RCMs partitioning ice runoff and land runoff at appropriated outlets, plus precipitation onto the fjord surface.

Our static products - streams, outlets, and basins - have been previously estimated. citet:lewis_2009_hydrologic identified 293 distinct hydrologic ice basins and provided a data set of ice basins and ice margin outlets. Our work, a decade later, has significantly more basins and outlets because of the higher resolution of the input data, and additional data products. We provide ice basins, ice margin outlets, ice streams with metadata, land basins, coastal outlets, and land streams with metadata. citet:lewis_2009_hydrologic generated basins from a 5 km DEM, compared to the 100 m DEM used here. Routing with a 5 km DEM is likely to cause some basins and outlets to drain into an incorrect fjord. When comparing BedMachine v3 (150 m) and ArcticDEM (100 m) products, land DEM errors or resolution limitations cause some BedMachine basins to drain on the opposite side of a spit or an isthmus than they appear to in satellite imagery - imagery that is closely matched by the nearby flow-path as routed using ArcticDEM.

# We are unable to quantitatively compare changes in the basin outlet location for all upstream grid cells between citet:lewis_2009_hydrologic and our basins (as we do for different versions of our basins in the Appendix) because citet:lewis_2009_hydrologic has outlets on a different land mask and a shift exists for all outlets due to the boundary.

Our time-series product - runoff, also has existing similar products. The most recent of these is from citet:bamber_2018_freshwater (Fig. [[fig:annual_runoff]]) who provide a data product at lower spatial resolution (5 km), lower temporal resolution (monthly), and only coastal discharge, not coastal basins, nor ice basins, nor ice margin outlets and discharge. However, citet:bamber_2018_freshwater surpasses our product in that the time-series extends back to 1958, and spatial coverage includes a larger portion of the Arctic including Iceland, Svalbard, and Arctic Canada. Furthemore, by provide data at 5 km spatial and monthly temporal resolution, citet:bamber_2018_freshwater implements the main strategy suggested here to increase the signal-to-noise ratio of the data.

** Validation against observations

There are many regional products that estimate a single or a few basins and associated runoff over a range of spatial resolutions and a range of temporal resolutions and periods. Examples of these include citet:rennermalm_2012_proglacial,lindback_2014_high,lindback_2015_subglacial,ahlstrom_2017_abrupt,van-as_2017_hypsometric,van-as_2018_reconstructing and others. Many of these regional studies focus on the oft-studied south-west sector of Greenland that includes the Russell and Leverett glaciers and the Watson River. Here we compare our results to all observations that we have been able to find that are publicly accessible, or willing to become open and publicly accessible as part of this work. These comparisons include (1) Watson River discharge from citet:van-as_2018_reconstructing, (2) Greenland Ecosystem Monitoring Programme (GEM) data for six basins around Zackenberg, Disko Island, and Nuuk, and (3) Runoff from a small basin near Qaanaaq, in Northwest Greenland.

*** Watson River

#+NAME: low_runoff_days
#+BEGIN_SRC jupyter-python :session session :exports none :results raw drawer
<<runoff_watson>>
w = runoff_watson()

n_gt_500 = (w['MAR ice'] > 500).sum()
print(n_gt_500 / w.shape[0] *100)
n_le_500 = (w['MAR ice'] <= 500).sum()
print(n_le_500 / w.shape[0] *100)
#+END_SRC

#+RESULTS: low_runoff_days
: 7.008619471527483
: 92.99138052847252

We compare the observed Watson River discharge from citet:van-as_2018_reconstructing to the runoff from the nearest outlet in this work. We note that runoff from this work matches for low runoff (< 500 m^{3} s^{-1}, 93 % of all runoff days), but is only approximately half of the citet:van-as_2018_reconstructing runoff for high runoff (Fig. [[fig:vanAs_compare]]). This difference may be due to either errors in the basin delineation used in this study, errors in the stage-discharge relationship used by citet:van-as_2018_reconstructing, errors in the RCM runoff estimates, or a combination of the above three. All three of these error sources increase with high melt or runoff; Basin delineation becomes less certain with distance from the ice sheet margin. The river stage-discharge conversion becomes less certain at high stage levels. Runoff calculations from a snow surface are more uncertain than from an ice surface, because of e.g. snow density, subsurface refreezing, and surface darkening.

Our basin is smaller than the basin used in citet:van-as_2018_reconstructing and similar to citet:mernild_2018_high who attributed the difference between their modeled outflow and observations from citet:van-as_2017_hypsometric to their decision to use surface rather than subglacial routing, and applied a correction term. We find that our basin does not include ice to the south of itself that is included in citet:van-as_2018_reconstructing. When we manually add the two large ice basins to the south of the Watson River basin, runoff estimates agree (Fig. [[fig:vanAs_compare]] right panel), suggesting basin delineation, not stage-discharge or RCM may be the primary cause for this disagreement. We are able to recreate the citet:van-as_2018_reconstructing basin (introduced in citet:lindback_2015_subglacial) but only when using the citet:lindback_2014_high bed and the citet:bamber_2013_bed surface. When using only one or zero of those and any combination of BedMachine v2 citep:morlighem_2014_deeply, BedMachine v3, or ArcticDEM surface elevations and BedMachine v2 or v3 bed elevations, we are unable to match the citet:lindback_2015_subglacial basin. Instead all our basins resemble those shown in Fig [[fig:watson_basins]].

# An improved GIS-wide bed product will modify basin delineations and runoff estimates that are part of this product to improve and better match observations over time.

# A large number of other studies addressing runoff are not discussed in this section because of limited access to data 

# citet:mernild_2018_high

# citet:liston_2012_greenland and citet:mernild_2012_greenland present HydroFlow, a routing model that include both slow and fast transfer functions (i.e. runoff delay) for runoff. The runoff presented here include a delay because the RCMs include a delay, but once that RCM runoff output is used as an input to this work, there is no delay and runoff is transferred to the outlet instantaneously. The other major difference between citet:liston_2012_greenland and citet:mernild_2012_greenland and the work presented here is our shared data and code and goal to make an continually updating operational product.

# We attempt to recreate the citet:lindback_2015_subglacial basins using the raw citet:lindback_2014_high bed and thickness, and BedMachine v2 citep:morlighem_2014_deeply, BedMachine v3, and ArcticDEM surface elevations, and a range of subglacial pressure assumptions. In no case were we able to generate a Kangerlussuaq basin that a) included the ice excluded to the south in our basin or b) reached the ice divide as in citet:lindback_2015_subglacial - instead all our basins resemble those of citet:bartholomew_2011_supraglacial and are similar to the basins shown in Fig [[fig:watson_basins]]. Because this work intends to maintain an updated data product when improved and open data become available in the future, we expect the basin delineations and runoff estimates that are part of this product to improve and better match observations over time.

*** GEM Basins

Six basins from the GEM project have a time-series of runoff, and comparisons between our basin-partitioned RCM runoff and observations show better agreement than the for the Watson River basin(s). We note that these basins are significantly smaller than the Watson River basin, but because the basin is primarily defined by a land surface rather than an ice basin, basin delineation is more accurate. Therefore disagreement here between GEM observation and our product is likely attributable to errors in the RCM runoff, not the basin delineation.

Of the six basins with GEM runoff, the two largest (Zackenberg (Fig. [[fig:GEM_map_Zackenberg]]) and Röde Elv (Fig. [[fig:GEM_map_Rode]])) show good agreement between the ice basins and the MAR and RACMO ice cells. The four smallest GEM basins (Fig. [[fig:GEM_map_others]]) have only one MAR and RACMO ice cell over an ice basin, several ice basins with no simulated runoff, and several MAR and RACMO ice cells with no co-located ice basin. The discussion of how these (mis)alignments are treated is in Sec. \ref{sec:methods:coverage}.

We show both daily time-series (Fig. [[fig:GEM_ts]]) and 10-day smoothed scatter-plot (Fig. [[fig:GEM_scatter]]) of the six GEM basin runoff observations and estimates. We use only MAR as the comparison here because the MAR product includes land and ice runoff, while RACMO only includes ice runoff. The daily time series, limited to 2017 because that is the only year of Röde Elv data, shows an agreement in both magnitude and variability between the MAR and GEM runoff products. However, all basins except Zackenberg show a MAR step-change decrease between day 168 and 169, after which variability continues to match (e.g. modeled v. observed day-long precipitation events roughly align) but magnitude does not agree as well as prior to day 169.

The scatter plot has a 10-day smooth applied as in citet:van-as_2017_hypsometric, and shows all available days of data not just 2017. Color represents day of year, and similar to Fig. [[fig:GEM_ts]] shows that the MAR runoff slightly overestimates the GEM observations early in the year, and slightly underestimates the observations late in the year. 

This seasonal disagreement is apparent as a step-change in all years, but not always on day 169 (18 June for non-leap-years). However, sometime in June of all years where GEM data and MAR data exist and in five of six basins (excluding Zackenberg), a step-decrease in MAR produces an underestimate of runoff relative to observations. The cause for this disagreement is not yet known.

*** Qaanaaq

We validate our basins and runoff against one additional observation and highlight that in some locations strong agreement exists but may or may not exist for the right or wrong reason. A small basin near Qaanaaq has been instrumented for the past several summers citep:sugiyama_2014_initial,tsutaki_2017_surface, with overlap in August 2017. 

From Fig. [[fig:map_Qaanaaq]], the Qaanaaq glacier outline is closely matched by the ice basin product generated here. However, only one nearby MAR ice cell covers 4 of the 1075 basin grid cells. Even so, that single MAR cell combined with our coverage algorithm (Sec. \ref{sec:methods:coverage}) generates very good agreement between MAR runoff and observations (Fig. [[fig:ts_Qaanaaq]]). RACMO ice cells cover almost the entire ice basin, yet do not agree as well. The comparison here is among observations from a stream, MAR ice and land, and RACMO ice only. Land area is not included in the RACMO product, but excluding it here is not likely to be the reason for the disagreement given a) the relatively small  portion of the catchment that is land and b) the magnitude of the MAR-estimated land runoff. Regardless, here RACMO does not capture the 5-fold increase seen in both the MAR and observations. This (dis)agreement among MAR, RACMO, and the observations highlights the uncertainty in the results presented here.

** Uncertainty

Uncertainty from RCM inputs and observations are considered external to this work, although they are still discussed below. In this work, we introduce one new source uncertainty - the routing model, which exhibits in two different ways: Spatial (basin delineation) and temporal (runoff delay). 

We do not address the temporal uncertainty quantitatively or numerically in this work - only in  discussion throughout the document and in the Mitigation section. Spatial uncertainty is a product of both the input data (the BedMachine bed) and the subglacial routing assumptions (the \(k\) value in Equation [[eq:head]]). Estimating these uncertainties may or may not lead to different estimates of runoff - for example, two drastically different drainage basins from different \(k\)-values may have similar estimates of runoff. The inverse is less common - it is not likely to have drastically different outlet runoff estimates from basins with only small changes, because large volumes of runoff usually come from large areas.

*** Basin uncertainty and surface vs. subglacial routing

The basins presented here are static approximations based on 100 m resolution surface DEM of a dynamic system. It is difficult to quantify the uncertainty of the assumptions used here, but we discuss the known uncertainties, ranging from least uncertain to most uncertain.

Basins comprised of only land are likely to be more precise and accurate than ice basins, because land is better resolved, has larger surface slopes, has negligible sub-surface flow, and is less dynamic than ice. Even if basins and outlets seem visually correct from the 100 m product, the basin outline still has uncertainty on the order of hundreds of meters and will therefore include many minor errors and non-physical properties, such as drainage basin boundaries bisecting lakes.

# We note that one large basin near Nuuk changes its outlet location significantly when we use 100 m ArcticDEM rather than 150 m BedMachine (Fig. [[fig:BM3_v_aDEM]]), and a visual comparison with Google Earth suggests the drainage pattern from the 100 m ArcticDEM product is a closer match reality. 

Basins delineated using the ice surface are likely to be more precise than basins using static subglacial theory, because the ice surface elevation has smaller errors than the bed elevation.  However, even if more precise, they may be less accurate, because most water routes subglacially. Finally, the precision and accuracy differences increase when one considers that subglacial routing is highly dynamic on timescales from minutes to seasons (e.g. citet:werder_2013_modeling). This dynamic system may introduce large spatial changes in outflow location (water or basin "piracy", citet:ahlstrom_2002_mapping,lindback_2015_subglacial,chu_2016_rerouting), but recent work by citet:stevens_2018_relationship suggests basins switching outlet locations may not be as common as earlier work suggests, and our sensitivity analysis (Fig. [[fig:diff_land_surf_aDEM_BM3_jako]] and Appendix) suggests that for source locations where the majority of runoff occurs, outlet location change by less than 10 km under different routing assumptions and data sets. Subglacial routing also increases opportunities for subglacial storage citep:rennermalm_2013_evidence,livingston_2013_potential.

We note that the ice surface is responsible for ~90 % of the subglacial routing assuming equal gradients at the ice surface and base. If basal features are ~10x the size of surface features, then the ice surface is effectively responsible for ~50 % of subglacial routing.

Given all of the above considerations, we opted for surface routing rather than subglacial (similar to citet:ahlstrom_2017_abrupt and citet:mernild_2018_high). However, we compare surface and subglacial basins, and the influence of those basins on the final outflow location, across a variety of products, where we quantify for every grid cell how far the eventual outlet for that grid cell moves under different basin delineation schemes.

When routing subglacially, we define the head \(h\) as

#+NAME: eq:head
\begin{equation}
h = z_b + k \frac{\rho_i}{\rho_w} (z_s - z_b),
\end{equation}

where \(h\) is the hydraulic head at each location, \(z_b\) the ice-free land surface and basal topography, \(k\) the flotation fraction, \(\rho_i\) the density of ice (917 kg m^{-3}), \(\rho_w\) the density of water (1000 kg m^{-3}), and \(z_s\) the land surface for both ice free and ice covered surfaces. Equation [[eq:head]] comes from citet:shreve_1972_movement where they define the hydropotential (units Pa), but here is divided by gravity \(g\) times the density of water \(\rho_w\) to convert the units from units Pa to m. Equation [[eq:head]] makes the assumption that when ice is present (\(z_s \ne z_b\)) all water routes subglacially. When \(k\) is equal to \(\rho_w/\rho_i\) \approx 1.0905, then Eq. [[eq:head]] simplifies to \(h = z_s\).

Fig. [[fig:diff_land_surf_aDEM_BM3_jako]], comparing ArcticDEM surface routing v. BedMachine surface routing, shows that part of one basin shifts its coastal outlet by 30 to < 100 km, a few smaller portions of basins shift their outlets by 10 to < 30 km, Sermeq Kujalleq (Jakobshavn Isbræ) by 3 to < 10 km, and the majority by < 1 km. A range of additional routing scheme and input data set comparisons are shown in the Appendix.

Finally, even when we perform surface routing for basin delineation, we provide the BedMachine elevation of each outlet. Outlet elevations less than 0 indicate marine terminating subglacial outlets. However, even though this method provides an estimate of the initial subglacial discharge depth, much work remains to determine the effective depth of subglacial discharge, where effective depth is defined as the neutrally buoyant isopycnal that the subglacial discharge rapidly reaches once it enters the fjord (c.f. citet:mankoff_2016_structure).

# Severe quality issues are apparent at some outlet glaciers where surface slopes are low, or the surface does not have streams because of heavy crevassing (not represented here) and all water flowing subglacially over an unknown bed topography. One example of this is shown at the Soranerbræen terminus (Fig. [[fig:flat]]). A simple solution is to aggregate runoff over an area rather than use a single nearest point.

# The work was performed at 100 m. The work could have been done using a 30 m DEM or even at higher resolution.  However, given that almost all outlet streams appear to be captured based on comparisons with satellite imagery, it is unlikely that future surface DEM improvements will significantly change this work. Future versions of this or similar products are likely to benefit most from updated basal topography data, and most importantly from higher resolution and improved RCMs.

# + Compare w/ basins from citet:chu_2016_rerouting
# + Compare w/ basins and outlet runoff from citet:stevens_2016_linking
# + Compare w/ basins from citet:lindback_2015_subglacial
# + Compare w/ outlet runoff from citet:mankoff_2016_structure

*** RCM uncertainty

In addition to the basin delineation issues discussed above, the runoff product from the RCMs also introduces uncertainty into the product generated here. The RCM input products do not provide formal time- or space-varying error estimates, but of course do contain errors because they do not precisely nor accurately capture reality. RCM uncertainty is assigned a fixed value of 15 %. 

# RCM uncertainty is assigned a fixed value of 15 % and is assumed to be independent from routing model and observational uncertainty.

The primary RCM issues include 1) general calibration error, 2) treatment of the time delay for runoff, and 3) low resolution in the spatial grid (sub-grid processes are not captured sufficiently and are often parameterized to agree with limited available observations e.g. density of fresh snow).

The first issue is highlighted above where we compare our runoff to observations, and see for example annually repeating step-changes in RCM runoff that do not match observations.

For the second issue, the RCMs do calculate refreezing in snow and firn, and the RACMO runoff equation does include a retention term, but retention only occurs when there is firn cover. MAR includes a time delay of up to 10 days that is primarily a function of surface slope citep:zuo_1996_modelling,yang_2019_surface. Neither model includes the subglacial system and runoff is assumed to immediately leave the ice sheet surface. Properly addressing time delays with runoff requires addressing storage and release of water across a variety of timescales in a variety of media: firn (e.g. citet:munneke_2014_explaining,vandecrux_2019_firn), supraglacial streams and lakes (e.g. citet:zuo_1996_modelling,smith_2015_efficient,yang_2019_surface), the subglacial system (e.g. citet:rennermalm_2013_evidence) and a variety of other physical processes that are not within the scope of SMB modeling. Runoff delay can be implemented outside the RCMs (e.g. citet:liston_2012_greenland,mernild_2018_high), but for this version of the product we present instantaneous runoff and downstream users can apply temporal lags if needed. 

# As shown by citet:van-as_2017_hypsometric, routing delays of up to several days exists between the Watson River discharge and ice-sheet meltwater runoff. When lakes occur along the flow-path, the delay can increase.

The third issue is a current limitation of the RCMs that will be improved as future versions increase resolution.

# NOTE TO DO

# Modeled runoff with our best estimate of basins disagrees with the one available "direct" observation of runoff. Elsewhere, proxies of runoff show agreement with modeled runoff and basins (e.g. citet:mankoff_2016_structure and citet:stevens_2016_linking). This is agreement is possible via two methods - either the agreement shown elsewhere is correct for the right reasons, and elsewhere both the modeled drainage area and RCM runoff is correct, or they are correct for the wrong reasons. If for the wrong reason, either runoff is correct but for the wrong reason (incorrect basin combined with incorrect RCM runoff produces correct runoff at the outlet), or the runoff is wrong, and the model that uses the incorrect runoff is either wrong, right for the wrong reasons, or not sensitive to using an incorrect input.

*** Observational Uncertainty

When comparing against observations, additional uncertainty is introduced because the stage-discharge relationship is neither completely precise or accurate. We use published observation uncertainty when it exists. 

*** Mitigating Uncertainties

\label{sec:mitigation}

Traditional uncertainty propagation is further complicated because it is not clear to what extent the three uncertainties (observational, RCM, and routing model) should be treated as independent from each other - all three uncertainties are likely to show some correlation with elevation, slope, air temperature, or other shared physical processes.

Many of the uncertainties discussed here can be mitigated by increasing the signal to noise ratio of the product provided here. Because we provide a high spatial and temporal resolution product, this is equivalent to a large number of signals, each of which has some uncertainty (noise). Averaging results spatially or temporally, if possible for a downstream use of this product, will increase the signal to noise ratio and reduce uncertainty. 

For example, because we provide basins for the entire ice sheet, total runoff is not subject to basin uncertainty. Any error in the delineation of one basin must necessarily be corrected by the inclusion (if underestimate) or exclusion (if overestimate) of a neighboring basin, although neighboring basins may introduce their own errors. Therefore, summing basins reduces the error introduced by basin outline uncertainty, and should be done if a downstream product does not need an estimate of runoff from a single outlet. This feature is built-in to coastal outlet discharge which is not as sensitive to our routing algorithm as ice margin outlet discharge because most coast outlets include a range of upstream ice margin outlets (e.g. Figs. [[fig:outlet_change_1]] v. [[fig:outlet_change_2]] in Appendix). Conversely, at the ice margin, outlet location and discharge volume is more uncertain. However, most runoff is generated near the ice margin and as runoff approaches the margin, there is less opportunity for it to switch basins.

Temporally, errors introduced by this study's assumption of instantaneous runoff can be reduced by summing or averaging runoff over larger time periods. Although a given volume of water may remain in storage long term, the assumption of steady state storage means that long-term storage shown by, for example, dye trace studies, can be ignored - the volume with the dye may be stored, but a similar volume should be discharged in its place.

** Other sources of freshwater

The liquid water runoff product provided here is only one source of freshwater that leaves the ice sheet and affects fjords and coastal seas. The other primary freshwater source is iceberg calving and submarine melt at the ice/ocean boundary of marine terminating glaciers. A companion to the liquid water runoff product introduced here is provided by citet:mankoff_2019_ice, which estimates solid ice volume flow rates across gates near marine terminating glaciers. That ice downstream enters fjords as either calving icebergs or liquid water from submarine melting.

Both this product and citet:mankoff_2019_ice provide liquid or solid freshwater volume flow rates at outlets (this product, which includes elevation of discharge, equal to depth when negative) or grounding lines citep:mankoff_2019_ice, but actual freshwater into a fjord occurs at a more complicated range of locations. Solid ice melts throughout the fjord and beyond (e.g. citet:enderlin_2016_iceberg,moon_2017_subsurface), and the freshwater discharge presented here may enter at a depth, but rapidly rises up the ice front and eventually flows into the fjord at some isopycnal citep:mankoff_2016_structure. The eventual downstream location of the fresh water is not addressed in this work.

Freshwater inputs directly to the water surface are also not included in this product. The flux (per square meter) to the water surface must be similar to the flux from the non-ice-covered the land surface. The land runoff volume accounts for ~35 % of the total runoff volume presented in this work (Fig. [[fig:annual_runoff]]), so the freshwater input (i.e. precipitation) directly to the fjord surface must also be ~35 % when considering a fjord and ocean area with area equal to the non-ice-covered land area.

Finally, basal melt from 1) geothermal heating (e.g. citet:fahnestock_2001_high) 2) frictional heating (e.g. citet:echelmeyer_1990_jakobshavns) and 3) viscous heat dissipation from all previous freshwater sources (c.f. citet:mankoff_2017_past) contributes up to 10 % additional runoff to the surface melt. Geothermal and frictional heating are approximately steady state and contribute freshwater throughout the winter months.

Importantly, ice sheet runoff may not be the majority source of freshwater into some fjords, even though it is traditionally considered the majority, or even only, source of freshwater. The combination of land runoff, freshwater inputs (snow and rain) directly onto the fjord surface, and basal runoff, suggests that GIS-wide ice sheet surface runoff may account for < 50 % of total runoff. The percent contribution of ice sheet surface runoff is likely to vary widely depending on the downstream fjord, upstream basin, and dates and time-span of the estimates.

* Data and Code Availability

This work in its entirety is available at doi:10.22008/promice/data/freshwater_runoff/v01 citep:GEUS_freshwater_paper where it will be updated over time.

A website for post-publication updates is available at https://github.com/mankoff/freshwater where we document ongoing changes to this work and use the GitHub Issues feature to collect suggested improvements, document those improvements as they are implemented, document problems that made it through review, and mention related works not cited here, perhaps due to temporal directionality citep:zeh_2007_physical. This version of the document is generated with git commit version \input{|"git describe --always --dirty='*'"}.

Runoff can only change in the future - the true past runoff is fixed - yet different estimates exist of past runoff (e.g. citet:van-as_2018_reconstructing,bamber_2018_freshwater, and this work). These differences must be caused by different methods or different inputs to the methods. By fully documenting the inputs, methods, and results we use to estimate runoff, this work supports attribution of result differences between different estimates. Both data and code are needed to support reproducibility, which is needed to both quantify and attribute differences. That is, future estimates of past runoff can and should both quantify and attribute differences due to changes in input data and the same methods (RCM inputs or the surface or subglacial digital elevation models (DEMs) used for routing), differences due to changes in hydrological routing algorithms using the same data, or combinations of the two. Quantification and attribution of these differences in needed to move the community from broadly comparable process studies to operational products that better support downstream research goals.  

** README                                               :noexport:

#+BEGIN_SRC org :tangle ./freshwater/README.txt :mkdirp ./freshwater :eval no-export :eval no
README for "Greenland liquid water runoff from 1979 through 2017"

DOI: doi:10.22008/promice/data/freshwater_runoff/v01
Source: https://github.com/mankoff/freshwater

,* Data Description

Data sets released as part of this work include:
+ Streams
+ Outlets
+ Basins
+ Runoff (at outlets)

Each of these computed on the following domains:
+ ice_surf :: Ice surface routing
+ land_surf :: Land surface routing

| Filename     | Description                    |
|--------------+--------------------------------|
| streams.gpkg | GeoPackage of stream locations |
| streams.csv  | Metadata for streams           |
| outlets.gpkg | GeoPackage of outlet locations |
| outlets.csv  | Metadata for outlets           |
| basins.gpkg  | GeoPackage of basin locations  |
| basins.csv   | Metadata for basins            |

In the runoff folder, 
+ margin :: Ice surface runoff routed to the ice margin
+ coast :: Land surface runoff routed to the coast
#+END_SRC



* Conclusions

Our new outlet, basin, stream, and liquid water discharge data provide a high spatial (100 m) and temporal (1 day) resolution estimate of freshwater fluxes into Greenland fjords and coastal seas for the entire ice-sheet area from 1979 through 2017. We find an annual average Greenland runoff of 400 \pm 130 km^{3} ranging from 136 km^{3} in 1992 to 785 km^{3} in 2012, and displaying and overall increase in both magnitude and variability.

Because of the high spatial and temporal resolution, quality issues exist at basin and daily scale that do not exist when working over larger areas or times. 

This liquid freshwater volumetric flow rate product is complemented by a solid ice discharge product citep:mankoff_2019_ice. Combined, these provide an estimate of the majority of freshwater (total solid ice and liquid) flow rates from the Greenland ice sheet into fjords and coastal seas. 

This estimate of freshwater flux into Greenland fjords aims to support further studies of the impact of freshwater on ocean physical, chemical, and biological properties; fjord nutrient, sediment, and ecosystems; and larger societal impacts of freshwater on the fjord and surrounding environments.

* Misc                                                    :ignore:

#+BEGIN_authorcontribution
\xspace KDM produced this work - wrote the code and the text. APA and DVA helped with discussions of methods and quality control. WC, RSF, and DVA helped with writing. KK and SS supplied Qaanaaq data. XF and BN supplied RCM inputs. KL provided GEM data. 
#+END_authorcontribution


#+BEGIN_competinginterests
\xspace  The authors declare that they have no conflict of interest.
#+END_competinginterests


#+BEGIN_acknowledgements
Funding was provided by the Programme for Monitoring of the Greenland Ice Sheet (PROMICE). Parts of this work were funded by the INTAROS project under the European Union's Horizon 2020 research and innovation program under grant agreement No. 727890. DEMs provided by the Polar Geospatial Center under NSF-OPP awards 1043681, 1559691, and 1542736. Data from the Greenland Ecosystem Monitoring Programme (GEM) were provided by Asiaq – Greenland Survey, Nuuk, Greenland. We thank Dorthe Petersen (ASIAQ) for help with basin quality control.
#+END_acknowledgements

* References                                              :ignore:

#+LaTeX: \bibliographystyle{copernicus}
# #+LaTeX: \bibliography{/home/kdm/Documents/Papers/library,freshwater}{}
#+LaTeX: \bibliography{freshwater}{}

* Algorithms                                            :noexport:
:PROPERTIES:
:header-args:bash+: :eval no
:header-args:jupyter-python+: :eval no
:END:
** Streams, outlets, and basins

The hydrological basins are defined based on surface flow routing. In the Appendix we explore basins defined on a range of subglacial pressures.

First, we calculate the hydropotential head for the surface

#+NAME: head
#+BEGIN_SRC bash :results verbatim
log_info "Calculating head from surface elevation"

# surf
# r.mapcalc "head_unfilled = if(mask_o_l_i@ArcticDEM == 1, null(), z_s@ArcticDEM)"

k=0.9
r.mapcalc "head_unfilled = if(mask_o_l_i@ArcticDEM == 1, null(), 0) + if(mask_o_l_i@ArcticDEM == 2, z_s@ArcticDEM, 0) + if(mask_o_l_i@ArcticDEM == 3, (z_s@ArcticDEM - thickness@BedMachine) + ${k} * 0.917 * thickness@BedMachine)"
r.fill.dir input=head_unfilled output=head direction=fill_dir areas=fill_problem_areas

#+END_SRC

The equation is slightly different if calculating subglacial head

The head gradient is defined as:
| Location         | Description                       |
|------------------+-----------------------------------|
| Sea              | Undefined                         |
| Land             | ArcticDEM 100 m                   |
| Ice (subglacial) | ArcticDEM + k * 0.917 * thickness |
| Ice (surface)    | ArcticDEM                         |

=thickness= is from BedMachine.

#+NAME: head_sub
#+BEGIN_SRC bash :results verbatim
log_info "Calculating subglacial head with k: ${k}"
r.mapcalc "head_unfilled = if(mask_o_l_i@ArcticDEM == 1, null(), 0) + if(mask_o_l_i@ArcticDEM == 2, z_s@ArcticDEM, 0) + if(mask_o_l_i@ArcticDEM == 3, (z_b@ArcticDEM) + ${k} * 0.917 * thickness@ArcticDEM)"
r.fill.dir input=head_unfilled output=head direction=fill_dir areas=fill_problem_areas
#+END_SRC

Then, we calculate the streams, outlets, and basins based on the head

#+NAME: sob
#+BEGIN_SRC bash :results verbatim
<<streams>>
<<outlets>>
<<basins>>

# Then, populate the steams, outlets, and basins with metadata
<<metadata>>
# And finally, export results to disk
<<export>>
#+END_SRC

Putting it all together, we want to calculate streams, outlets, and basins twice, once to the ice edge (domain = ice), and once to the coast (domain=land). See Section [[#domains][Domains]] for implementation. This is the top-level [[./sob.sh]] code that implements the streams, outlets, and basins routing and exports the results to disk.

+ WARN :: land surf needs to be run first, because ice_surf uses
          information from land_surf. Specifically, ice outlets look
          up what coast basin they drain out of, and carry that
          metadata with them.

#+BEGIN_SRC bash :results verbatim :tangle sob.sh
<<init>>

g.mapset -c land_surf
<<land_domain>>
<<head>>
<<sob>>

g.mapset -c ice_surf
<<ice_domain>>
<<head>>
<<sob>>

<<land_basins_no_ice>>

log_info "DONE: Streams, Outlets, and Basins"
#+END_SRC

If we want to run it for subglacial values, it can be done with the following code. This block not exported or run, but just presented here as an example. Similar code to this is run elsewhere when I do the sensitivity study where outflow occurs based on a range of subglacial pressures.

#+BEGIN_SRC bash :results verbatim
g.mapset -c ice_sub_90 # 90 % subglacial pressure
<<ice_domain>>
k=0.9
<<head_sub>>
<<sob>>
#+END_SRC

Below, we'll build out the code defined above.

**** Streams

After calculating the head, we use 3rd party tools to get the flow direction and streams

#+NAME: streams
#+BEGIN_SRC bash :results verbatim
THRESH=300
log_warn "Using threshold: ${THRESH}"
log_info "r.stream.extract..."

r.stream.extract elevation=head threshold=${THRESH} memory=16384 direction=dir stream_raster=streams stream_vector=streams
#+END_SRC

**** Outlets

+ The flow direction =dir= is negative where flow leaves the domain. These are the outlets.
+ Encode each outlet with a unique id

#+NAME: outlets
#+BEGIN_SRC bash :results verbatim
log_info "Calculating outlets"
r.mapcalc "outlets_1 = if(dir < 0, 1, null())"
r.out.xyz input=outlets_1 | \
    cat -n | \
    tr '\t' '|' | \
    cut -d"|" -f1-3 | \
    v.in.ascii input=- output=outlets_uniq separator=pipe \
        columns="x int, y int, cat int" x=2 y=3 cat=1
#+END_SRC

**** Basins

Using =r.stream.basins=, we can get basins for every outlet.

#+NAME: basins
#+BEGIN_SRC bash :results verbatim
log_info "r.stream.basins..."

r.stream.basins -m direction=dir points=outlets_uniq basins=basins_uniq memory=16384 --verbose

<<absorb_small_basins>>
#+END_SRC

For land basins, we also want a version that doesn't include sub-ice

#+NAME: land_basins_no_ice
#+BEGIN_SRC bash :results verbatim
log_info "Building land basins w/o ice"

mapset=$(g.mapset -p)
g.mapset land_surf
r.mapcalc "basins_no_ice = if(isnull(basins@ice_surf), basins, null())"
g.mapset ${mapset}
#+END_SRC



**** Domains
:PROPERTIES:
:ID:       f498d03c-0eac-4428-8118-b347f76b094a
:CUSTOM_ID: domains
:END:

+ For the ice domain, the domain boundary is the ice/land edge.
+ For the land domain, the domain boundary is the land/fjord edge.

***** Ice

#+NAME: ice_domain
#+BEGIN_SRC bash :results verbatim
log_info "Setting domain to ice"
g.region -dp
# DEBUG
# g.region res=9000
r.mask raster=mask_o_l_i@ArcticDEM maskcats=3 --o # mask to ice
<<mask_small_areas>>
#+END_SRC

***** Land

#+NAME: land_domain
#+BEGIN_SRC bash :results verbatim
log_info "Setting domain to land"
g.region -dp
r.mask raster=mask_o_l_i@ArcticDEM maskcats="2 3" --o # mask to land & ice
<<mask_small_areas>>
#+END_SRC

**** Metadata

#+NAME: metadata
#+BEGIN_SRC bash :results verbatim
<<add_metadata>>
<<add_stream_indices>>
#+END_SRC

***** Add Metadata

+ streams [2/2]
  + [X] stream indices
  + [X] stream length
+ basin [2/2]
  + [X] area
  + [X] ice - has some ice contribution
+ outlet [5/5]
  + [X] acc value - no, can use area
  + [X] BedMachine z_b
  + [X] lon, lat
  + [X] EPSG 3413 x, y
  + [X] link margin outlets to coast outlet

#+NAME: add_metadata
#+BEGIN_SRC bash :results verbatim
log_info "Adding metadata..."

###
### streams
###
v.db.addcolumn map=streams column="length INT"
v.to.db map=streams option=length column=length

###
### outlets
###
v.db.addcolumn map=outlets column="lon DOUBLE PRECISION"
v.db.addcolumn map=outlets column="lat DOUBLE PRECISION"
v.db.addcolumn map=outlets column="x INT"
v.db.addcolumn map=outlets column="y INT"
# v.db.addcolumn map=outlets column="cells INT"
v.db.addcolumn map=outlets column="elev INT"

# r.mask -r

v.what.rast map=outlets raster=x@PERMANENT column=x
v.what.rast map=outlets raster=y@PERMANENT column=y
v.what.rast map=outlets raster=z_b@BedMachine column=elev # TODO

# probably a more efficient way to get lon,lat column from x,y...
mkdir -p tmp
db.select -c sql='select x,y,cat from outlets' | m.proj -od input=- | tr '|' ',' > ./tmp/lonlat.csv
db.in.ogr input=./tmp/lonlat.csv output=lonlat
db.select table=lonlat|head
v.db.join map=outlets column=cat other_table=lonlat other_column=field_3
v.db.update map=outlets column=lon query_column=field_1
v.db.update map=outlets column=lat query_column=field_2
v.db.dropcolumn map=outlets columns=field_1,field_2,field_3
db.select table=outlets | head

# distance from outlet ice or coast
if [[ "ice_surf" == $(g.mapset -p) ]]; then # ice domain. Find which coast basin we're inside of
   v.db.addcolumn map=outlets column="coast_id int"
   v.what.rast map=outlets type=point raster=basins@land_surf column=coast_id

   v.db.addcolumn map=outlets column="coast_lon double"
   v.db.addcolumn map=outlets column="coast_lat double"
   v.db.addcolumn map=outlets column="coast_x int"
   v.db.addcolumn map=outlets column="coast_y int"
  
   g.copy vector=outlets@land_surf,oland
   db.execute sql='UPDATE outlets SET coast_lon=(SELECT lon from oland WHERE outlets.coast_id=oland.cat)'
   db.execute sql='UPDATE outlets SET coast_lat=(SELECT lat from oland WHERE outlets.coast_id=oland.cat)'
   db.execute sql='UPDATE outlets SET coast_x=(SELECT x from oland WHERE outlets.coast_id=oland.cat)'
   db.execute sql='UPDATE outlets SET coast_y=(SELECT y from oland WHERE outlets.coast_id=oland.cat)'
fi

###
### basins
###
v.db.addcolumn map=basins column="area DOUBLE PRECISION"
v.to.db map=basins option=area column=area
#+END_SRC

***** Stream Indices
#+NAME: add_stream_indices
#+BEGIN_SRC bash :results verbatim
log_info "r.stream.order: BEGIN"
date
time r.stream.order -m stream_rast=streams direction=dir elevation=head accumulation=ones@PERMANENT stream_vect=stream_vect strahler=strahler horton=horton shreve=shreve hack=hack topo=topological memory=16384
date
log_info "r.stream.order: END"

# g.copy vector=streams,foo --o
# g.copy vector=stream_vect,bar --o

for c in $(echo strahler horton shreve hack drwal_old topo_dim); do
    db.execute sql="ALTER TABLE streams ADD COLUMN ${c} INT"
    db.execute sql="UPDATE streams SET ${c}=(SELECT ${c} from stream_vect WHERE stream_vect.cat=streams.cat)"
done

for c in $(echo stright sinosoid cum_length source_elev outlet_elev); do
    db.execute sql="ALTER TABLE streams ADD COLUMN ${c} double"
    db.execute sql="UPDATE streams SET ${c}=(SELECT ${c} from stream_vect WHERE stream_vect.cat=streams.cat)"
done

# # fix typo: sinosoid -> sinusoid; stright -> straight
db.execute sql="ALTER TABLE streams ADD COLUMN sinusoid DOUBLE"
db.execute sql="UPDATE streams SET sinusoid = sinosoid"
# db.execute sql="ALTER TABLE streams DROP COLUMN sinosoid"
v.db.dropcolumn map=streams columns=sinosoid

db.execute sql="ALTER TABLE streams ADD COLUMN straight DOUBLE"
db.execute sql="UPDATE streams SET straight = stright"
# db.execute sql="ALTER TABLE streams DROP COLUMN stright"
v.db.dropcolumn map=streams columns=stright
#+END_SRC


**** Export

#+NAME: export
#+BEGIN_SRC bash :results verbatim
log_info "Exporting..."

MAPSET=$(g.mapset -p)
mkdir -p freshwater/${MAPSET}

# db.select table=streams | tr '|' ',' > ./freshwater/${MAPSET}/streams.csv
# db.select table=outlets | tr '|' ',' > ./freshwater/${MAPSET}/outlets.csv
# db.select table=basins | tr '|' ',' > ./freshwater/${MAPSET}/basins.csv
parallel --bar "db.select table={} | tr '|' ',' > ./freshwater/${MAPSET}/{}.csv" ::: streams outlets basins

# v.out.ogr -c input=streams output=./freshwater/${MAPSET}/streams.gpkg --o
# v.out.ogr -c input=outlets output=./freshwater/${MAPSET}/outlets.gpkg --o
# v.out.ogr -c input=basins output=./freshwater/${MAPSET}/basins.gpkg --o
parallel --bar "v.out.ogr -c input={} output=./freshwater/${MAPSET}/{}.gpkg --o" ::: streams outlets basins
#+END_SRC



*** Helper Functions
**** init
#+NAME: init
#+BEGIN_SRC bash :results verbatim
set -o nounset
set -o pipefail

# set -o errexit

### uncomment the above line when doing initial run. When rerunning and
### counting on GRASS failing w/ overwrite issues (speed increase), the
### line above must be commented

red='\033[0;31m'; orange='\033[0;33m'; green='\033[0;32m'; nc='\033[0m' # No Color
log_info() { echo -e "${green}[$(date --iso-8601=seconds)] [INFO] ${@}${nc}"; }
log_warn() { echo -e "${orange}[$(date --iso-8601=seconds)] [WARN] ${@}${nc}"; }
log_err() { echo -e "${red}[$(date --iso-8601=seconds)] [ERR] ${@}${nc}" >&2; }

trap ctrl_c INT # trap ctrl-c and call ctrl_c()
ctrl_c() { log_err "CTRL-C. Cleaning up"; }

debug() { if [[ debug:- == 1 ]]; then log_warn "debug:"; echo $@; fi; }

<<GRASS_config>>
#+END_SRC

**** GRASS config

https://grass.osgeo.org/grass74/manuals/variables.html

| GRASS_VERBOSE |                                                                |
|            -1 | complete silence (also errors and warnings are discarded)      |
|             0 | only errors and warnings are printed                           |
|             1 | progress and important messages are printed (percent complete) |
|             2 | all module messages are printed                                |
|             3 | additional verbose messages are printed                        |

#+NAME: GRASS_config
#+BEGIN_SRC bash :results verbatim :tangle no
export GRASS_VERBOSE=3
# export GRASS_MESSAGE_FORMAT=silent

set -x # print commands to STDOUT before running them
#+END_SRC


**** x and y and ones in PERMANENT mapset

#+NAME: xy_permanent
#+BEGIN_SRC bash :results verbatim
MAPSET=$(g.mapset -p)
g.mapset PERMANENT
r.mapcalc "x = x()"
r.mapcalc "y = y()"
r.mapcalc "ones = 1"
g.mapset ${MAPSET}
#+END_SRC

**** COMMENT Map projection distortion

#+BEGIN_SRC bash :results verbatim :tangle distortion.sh
<<init>>
log_info "Calculating distortion"
#+END_SRC

#+NAME: distortion
#+BEGIN_SRC bash :results verbatim :tangle distortion.sh
ORIG_MAPSET=$(g.mapset -p)
MAPSET=distortion
g.mapset -c ${MAPSET}

if [[ "err_2D_area" == $(g.list type=raster pattern=err_2D_area) ]]; then
  log_warn "Distortion already calculated"
else
  g.region res=10000 -ap
  v.mkgrid map=grid position=region type=point

  v.out.ascii grid | m.proj input=- -od | cut -d"|" -f1,2 | tr '|' ' ' > ./tmp/distortion_ll.txt
  PROJSTR=$(g.proj -j)
  echo $PROJSTR
  cat ./tmp/distortion_ll.txt \
    | proj -VS ${PROJSTR} \
    | grep Areal \
    | column -t \
    | sed s/\ \ /,/g \
    | cut -d, -f4 \
       > ./tmp/distortion_err.txt

  time paste -d " " <(m.proj -i input=./tmp/distortion_ll.txt separator=space | cut -d" " -f1,2) ./tmp/distortion_err.txt | r.in.xyz input=- output=err_2D_inv_sparse separator=space

  g.region -d
  r.resamp.interp input=err_2D_inv_sparse output=err_2D_inv method=bilinear
  r.mapcalc "err_2D_area = 1/(err_2D_inv)" # convert to multiplier
  r.mapcalc "err_2D_line = 1/(err_2D_inv^0.5)" # convert area error to linear error

g.mapset ${ORIG_MAPSET}
#+END_SRC


**** Mask small areas

Don't process tiny islands.

#+NAME: mask_small_areas
#+BEGIN_SRC bash :results verbatim
# remove islands
# frink "90 m^2 * 10 -> hectares" # 8.1
# frink "1 km^2 -> hectares" # 100

# value is in hectares
r.reclass.area -d input=MASK output=MASK_nosmall value=100.1 mode=lesser method=rmarea
r.mask MASK_nosmall --o
#+END_SRC

**** Absorb small basins & drop their outlets

+ Merge small (< 1 km^2) basins with their largest neighbor.
+ Drop associated outlets too.

#+NAME: absorb_small_basins
#+BEGIN_SRC bash :results verbatim
# absorb small basins and outlets
# frink "1.0 km^2 / ((90 * 90) m^2)" # 123.4567
# frink "1.0 km^2 / ((150 * 150) m^2)" # 45
# frink "1.0 km^2 / ((100 * 100) m^2)# #100

# minsize is in cells
r.clump -d input=basins_uniq output=basins_nosmall minsize=101
r.mode base=basins_nosmall cover=basins_uniq output=basins
r.to.vect -v input=basins output=basins type=area
v.db.dropcolumn map=basins column="label"

v.to.rast input=outlets_uniq output=outlets_uniq use=cat
# r.mapcalc "outlets = if(outlets_streams == basins, basins, null())"
r.mapcalc "outlets = if(outlets_uniq == basins, basins, null())"
r.to.vect -v input=outlets output=outlets type=point
db.dropcolumn -f table=outlets column=label
# db.dropcolumn -f table=outlets column=area
#+END_SRC


**** GRASS launch and mapset selector prologue

+ Launches GRASS if not running.
+ Changes to specified mapset if not already in it.

#+NAME: grass_init_mapset
#+BEGIN_SRC bash :results verbatim :results none
[[ -z ${mapset} ]] && mapset=PERMANENT
if [[ ! (${PS1} =~ .*GRASS.*) ]]; then
  [[ -d ./G ]] || grass -e -c EPSG:3413 ./G
  [[ -d ./G/${mapset} ]] || grass -e -c ./G/${mapset}
  grass ./G/${mapset}
else
  [[ ${mapset} == $(g.mapset -p) ]] || g.mapset -c ${mapset} --q
fi
#+END_SRC

Example usage:

#+BEGIN_SRC bash :results verbatim :session grass_ex :var mapset="foo"
<<grass_init_mapset>>
echo "MAPSET is: " $(g.mapset -p)
#+END_SRC

**** Remove GRASS PS1 prompt noise from Babel output

#+NAME: GRASS_PS1_clean
#+BEGIN_SRC bash :var data="" :session grass_ex :eval no-export :results verbatim
echo ""
echo ""
echo "${data}" | tr '>' '\n' | grep -v -E "^ ?$" | grep -v "GRASS"
#+END_SRC

#+RESULTS: GRASS_PS1_clean
: 
: [0;34m[1m~/projects/freshwater[0;37m[1m [master▶] [m$ [00m[0;34m[1m~/projects/freshwater[0;37m[1m [master▶] [m$ [00m$

Example Usage:

#+header: :post GRASS_PS1_clean(data=*this*)
#+header: :session grass_ex
#+header: :var mapset="foo"
#+BEGIN_SRC bash :results verbatim
<<grass_init_mapset>>
g.region -p
#+END_SRC


** Model output routing
*** Area correction for EPSG:3413
:PROPERTIES:
:header-args:bash+: :tangle area_error.sh
:END:

+ This correction needs to be applied to any model data.
+ It is easiest and fastest to generate an area correction raster for each of the two models on their exact grid.
+ To do this, we set up model domains in GRASS, estimate the area correction for each cell, write out a NetCDF file of that raster, and then apply that to each day of the model data.

#+BEGIN_SRC bash :results verbatim
<<init>>
log_info "Area Error..."
#+END_SRC

**** MAR
***** Create MAR Mapset
MAR NetCDF files don't contain projection information that can be used by GRASS. So I find the bottom, top, left, and right edges by...

+ longitude where lat is max,
+ longitude where lat is min
+ latitude where lon is max
+ latitude where lon is min

Then pass those four through ~m.proj~ to get the x,y bounds of the region in GRASS

#+name: MAR_bounds
#+BEGIN_SRC jupyter-python :results raw drawer :tangle no :display text/plain :exports none :session MAR :eval no-export
import numpy as np
import xarray as xr

DATADIR="/home/kdm/data"
ds = xr.open_dataset(DATADIR+"/MAR/3.9/MARv3.9-daily-ERA-Interim-2017.nc")

lon = ds['LON'].values.flatten()
lat = ds['LAT'].values.flatten()

lonmax_idx = np.argmax(lon)
lonmin_idx = np.argmin(lon)
latmax_idx = np.argmax(lat)
latmin_idx = np.argmin(lat)

R = lon[lonmax_idx],lat[lonmax_idx]
L = lon[lonmin_idx],lat[lonmin_idx]
T = lon[latmax_idx],lat[latmax_idx]
B = lon[latmin_idx],lat[latmin_idx]

# bounds
pd.DataFrame(index=['T','B','L','R'], columns=['lon','lat'], data=np.vstack((T,B,L,R)))
#+END_SRC

#+RESULTS: MAR_bounds
:          lon        lat
: T -45.039822  83.948792
: B -30.694536  58.800426
: L -89.264137  81.557274
: R   7.516274  80.071167

#+RESULTS:
:          lon        lat
: T -45.039822  83.948792
: B -30.694536  58.800426
: L -89.264137  81.557274
: R   7.516274  80.071167


#+BEGIN_SRC bash :results verbatim
log_info "Creating MAR mapset..."

g.mapset -c MAR

# NOTE: The origin of the hard-code values used here can be found in the Org source file.
T=-45.039822,83.948792
B=-30.694536,58.800426
L=-89.264137,81.557274
R=7.516274,80.071167

Txy=$(m.proj -i coordinates=$T)
Bxy=$(m.proj -i coordinates=$B)
Lxy=$(m.proj -i coordinates=$L)
Rxy=$(m.proj -i coordinates=$R)
echo $Txy $Bxy $Lxy $Rxy

N=$(echo ${Txy} | cut -d"|" -f2)
S=$(echo ${Bxy} | cut -d"|" -f2)
E=$(echo ${Rxy} | cut -d"|" -f1)
W=$(echo ${Lxy} | cut -d"|" -f1)

g.region e=$E w=$W s=$S n=$N -pal res=1000
g.region n=n+500 s=s+500 # as per adjustment check below, things appear to be shifted 1/2 cell SOUTH
g.region save=MAR
#+END_SRC

****** MAR alignment check                                    :QC:
:PROPERTIES:
:header-args:bash+: :tangle no
:END:

Note - this check diagnosed a misalignmnet of 1/2 MAR grid cell shifted SOUTH. A correction was implemented during the import phase, so when re-running this, everything may appear to line up properly initially, and then be shifted 1/2 cell (500 m) too far NORTH if the adjustment below is applied a second time.

Review:

#+BEGIN_SRC bash :results verbatim
grass ./G/MAR

g.region region=MAR -p

d.mon start=wx0

g.list type=raster mapset=ice_surf -m |cat
d.rast basins@ice_surf

g.list type=raster mapset=MAR -m |cat
r.to.vect input=mask_ice output=mask_ice type=area
d.vect mask_ice fill_color=none
#+END_SRC

+ zoom in N - MAR mask seems 0.5 to 1 grid cell shifted south.
+ same near Disko
+ same in S

Let's shift everything N by half a grid cell
#+BEGIN_SRC bash :results verbatim
g.region region=MAR -p
r.mapcalc "mask_ice_shift = mask_ice"
g.region s=s+500 n=n+500
r.region -c map=mask_ice_shift
diff <(g.region -up region=MAR) <(g.region -up)
diff <(g.region -up region=MAR) <(g.region -up raster=mask_ice_shift)
diff <(g.region -up) <(g.region -up raster=mask_ice_shift)

r.to.vect input=mask_ice_shift output=mask_ice_shift type=area
d.vect mask_ice_shift fill_color=none color=red
#+END_SRC




***** 2D Area Error
:PROPERTIES:
:CUSTOM_ID: code:area_error
:END:

+ EPSG:3413 has projection errors of \(\pm\) ~8% in Greenland
+ Method
  + Email: [[mu4e:msgid:m2tvxmd2xr.fsf@gmail.com][Re: {GRASS-user} scale error for each pixel]]
  + Webmail: https://www.mail-archive.com/grass-user@lists.osgeo.org/msg35005.html

#+NAME: area_error
#+BEGIN_SRC bash :results verbatim :tangle no
MAPSET=$(g.mapset -p)
log_info "2D Area Error for ${MAPSET}"

v.mkgrid map=grid position=region type=point

v.out.ascii grid | m.proj input=- -od | cut -d"|" -f1,2 | tr '|' ' ' > ./tmp/distortion_ll_${MAPSET}.txt
PROJSTR=$(g.proj -j)
echo $PROJSTR
cat ./tmp/distortion_ll_${MAPSET}.txt \
  | proj -VS ${PROJSTR} \
  | grep Areal \
  | column -t \
  | sed s/\ \ /,/g \
  | cut -d, -f4 \
    > ./tmp/distortion_err_${MAPSET}.txt

paste -d " " <(m.proj -i input=./tmp/distortion_ll_${MAPSET}.txt separator=space | cut -d" " -f1,2) ./tmp/distortion_err_${MAPSET}.txt | r.in.xyz input=- output=err_2D_inv separator=space

r.mapcalc "err_2D_area = 1/(err_2D_inv)" # convert to multiplier
r.mapcalc "err_2D_line = 1/(err_2D_inv^0.5)" # convert area error to linear error
r.out.gdal -c -m input=err_2D_area output=./tmp/err_2D_area_${MAPSET}.nc type=Float32 format=netCDF 
#+END_SRC

#+BEGIN_SRC bash :results verbatim
if [[ "" == $(g.list type=raster pattern=err_2D_area mapset=.) ]]; then
  <<area_error>>
fi
#+END_SRC

**** RACMO
***** Create RACMO Mapset
#+BEGIN_SRC bash :results verbatim
log_info "Creating RACMO mapset..."

g.mapset -c RACMO
FILE=${DATADIR}/RACMO/1km/Icemask_Topo_Iceclasses_lon_lat_average_1km.nc 
x0=$(ncdump -v x ${FILE} | grep "^ x =" | cut -d" " -f4 | cut -d, -f1)
x1=$(ncdump -v x ${FILE} | tail -n2 | head -n1 | tr ',' '\n' | tail -n1 | cut -d" " -f2)
y0=$(ncdump -v y ${FILE} | grep "^ y =" | cut -d" " -f4 | cut -d, -f1)
y1=$(ncdump -v y ${FILE} | tail -n2 | head -n1 | tr ',' '\n' | tail -n1 | cut -d" " -f2)
g.region w=$x0 e=$x1 s=$y0 n=$y1 res=1000 -ap
g.region s=s-500 n=n-500 e=e-1000 w=w-1000 # See "RACMO alignment check" below
g.region save=RACMO
#+END_SRC

****** RACMO alignment check                                  :QC:
:PROPERTIES:
:header-args:bash+: :tangle no
:END:


Note - this check diagnosed a misalignmnet of 1/2 MAR grid cell shifted SOUTH. A correction was implemented during the import phase, so when re-running this, everything may appear to line up properly initially, and then be shifted 1/2 cell (500 m) too far NORTH if the adjustment below is applied a second time.

Review:

#+BEGIN_SRC bash :results verbatim
grass ./G/RACMO

g.region region=RACMO -p

d.mon start=wx0

g.list type=raster mapset=ice_surf -m |cat
d.rast basins@ice_surf

g.list type=raster mapset=RACMO -m |cat
r.to.vect input=mask_ice output=mask_ice type=area
d.vect mask_ice fill_color=none
#+END_SRC

+ Appears 1 grid cell to far east and 1/2 grid cell to far north

Let's shift everything N by half a grid cell
#+BEGIN_SRC bash :results verbatim
g.region region=RACMO -p
r.mapcalc "mask_ice_shift = mask_ice"
g.region s=s-500 n=n-500 e=e-1000 w=w-1000
r.region -c map=mask_ice_shift
diff <(g.region -up region=RACMO) <(g.region -up)
diff <(g.region -up region=RACMO) <(g.region -up raster=mask_ice_shift)
diff <(g.region -up) <(g.region -up raster=mask_ice_shift)

r.to.vect input=mask_ice_shift output=mask_ice_shift type=area --o
d.vect mask_ice_shift fill_color=none color=red
#+END_SRC


***** 2D Area Error
See: [[#code:area_error][2D Area Error]]

#+BEGIN_SRC bash :results verbatim
if [[ "" == $(g.list type=raster pattern=err_2D_area mapset=.) ]]; then
  <<area_error>>
fi
#+END_SRC



*** RCM Preprocessing
:PROPERTIES:
:header-args:jupyter-python+: :tangle preprocess.py
:header-args:jupyter-python+: :shebang #!/usr/bin/env python
:END:

At this point the static work is done - we have basins, streams, and outlets for all of GIS. 

The remaining tasks are to SUM the daily model variables by each basin, and assign results to the outlet for each basin.

Working with the provided NetCDF files is possible but accessing one time of one variable is very slow (in GRASS) compared to when a NetCDF file of only one variable is used. I'll pre-process the MAR data to generate one file per variable.

+ MAR: One RUNOFF variable that contains appropriate runoff for both ice and land
+ RACMO: One RUNOFF variable that contains appropriate runoff for both ice and land

**** MAR Notes

From Xavier:

#+BEGIN_QUOTE
RU(CORR) = the (sub grid topography corrected) runoff over the permanent ice part of a pixel. In your case, I suggest you to use RUcorr instead of RU.

RU2 = runoff over the tundra part of a pixel (land runoff).

SF/RF are provided everywhere.

MSK_GIMP = land/sea/ice mask.

Over land you can use RUcorr and RU2 in fct of MSK_GIMP
Over sea, you can use RF+SF
#+END_QUOTE

**** Extract MAR Vars
:PROPERTIES:
:ID:       d698cc04-c4d7-4812-a274-fca1a83ee0eb
:END:

+ Use =xarray= citep:hoyer_2017_xarray and =dask= citep:DASK so that we can efficiently process the ~330 GB of data (much larger than RAM).

#+BEGIN_SRC jupyter-python :session MAR :exports both :results raw drawer
import xarray as xr
import os
from dask.diagnostics import ProgressBar

DATADIR="/home/kdm/data"
ROOT=DATADIR+"/MAR/3.9"

if not os.path.exists("./dat/MAR_runoff_ice.nc"):
    area = xr.open_dataset("./tmp/err_2D_area_MAR.nc")
    ds = xr.open_mfdataset(ROOT+"/MARv3.9-daily-ERA-Interim-????.nc", 
                           chunks={'time': 100}, 
                           combine='by_coords')
    da = (ds['RUcorr'] * (ds['MSK_GIMP'] == 2) * area['Band1'].values)   # runoff over ice
    da.variable.attrs = {'units':'mmWE/day','long_name':'Water runoff','standard_name':'Water runoff'}
    ds_sub = da.to_dataset(name='runoff')
    delayed_obj = ds_sub.to_netcdf('./dat/MAR_runoff_ice.nc', compute=False)
    with ProgressBar(): results = delayed_obj.compute() # 1h20min
    del(ds); del(da); del(ds_sub); del(delayed_obj)    

if not os.path.exists("./dat/MAR_runoff_land.nc"):
    area = xr.open_dataset("./tmp/err_2D_area_MAR.nc")
    ds = xr.open_mfdataset(ROOT+"/MARv3.9-daily-ERA-Interim-????.nc", 
                           chunks={'time': 100},
                           combine='by_coords')
    da = ds['RU2'] * (ds['MSK_GIMP'] == 1) * area['Band1'].values       # runoff over land
    da.variable.attrs = {'units':'mmWE/day','long_name':'Water runoff','standard_name':'Water runoff'}
    ds_sub = da.to_dataset(name='runoff')
    delayed_obj = ds_sub.to_netcdf('./dat/MAR_runoff_land.nc', compute=False)
    with ProgressBar(): results = delayed_obj.compute() # 1h20min
    del(ds); del(da); del(ds_sub); del(delayed_obj)    

# if not os.path.exists("./dat/MAR_rain.nc"):
#     ds = xr.open_mfdataset(ROOT+"/MARv3.9-daily-ERA-Interim-????.nc", chunks={'time': 100})
#     # # here we include land only becase model domain may be slightly different than GIMP 30 m domain.
#     # #         water + land         snowfall + rainfall
#     # da = (ds['MSK_GIMP'] != 2) * (ds['RF'])
#     da = (ds['RF'])
#     da.variable.attrs = {'units':'mmWE/day','long_name':'Rainfall','standard_name':'RF'}
#     ds_sub = da.to_dataset(name='rain')
#     delayed_obj = ds_sub.to_netcdf('./dat/MAR_rain.nc', compute=False)
#     with ProgressBar(): results = delayed_obj.compute()
#     del(ds); del(da); del(ds_sub); del(delayed_obj)    
#+END_SRC


**** RACMO Notes

Brice email: [[mu4e:msgid:48FFD1A0-A010-4BBD-84DE-63CD9F7EF67B@uu.nl][Re: All freshwater]]

#+BEGIN_QUOTE
The data consist of:

1 km: ice covered regions

- Daily total precipitation (rain + snow) and runoff in mm w.e. or
  kg/m2 per day covering the whole GrIS and peripheral ice caps (GICS)
  for the year 1979-2017.

- Mask file including: lon/lat, PROMICE mask (3 = GrIS, 1 and 2 =
  GICs) and topography from the GIMP DEM upscaled to 1 km.

The data are statistically downscaled from the output of RACMO2.3p2 (5.5 km) to 1 km resolution.

The projection used is Polar Stereographic North (EPSG:3413) and the resolution is exactly 1 km x 1 km.

5.5 km: tundra region

- Daily runoff and evaporation in mm w.e. or kg/m2 per day at 5.5 km
  for 1979-2017.

Use of the data:

Note that in RACMO2 a positive subl means condensation while negative
subl actually means sublimation.
#+END_QUOTE


**** Extract RACMO Vars

#+BEGIN_SRC jupyter-python :session RACMO :exports both :results raw drawer
import xarray as xr
from dask.diagnostics import ProgressBar
import os

DATADIR="/home/kdm/data"
ROOT=DATADIR+"/RACMO/1km"
msk = xr.open_dataset(ROOT+"/Icemask_Topo_Iceclasses_lon_lat_average_1km.nc")
msk['landmask'] = (msk['Promicemask'] == 0) & (msk['Topography'] != 0)

if not os.path.exists("./dat/RACMO_runoff_ice.nc"):
    area = xr.open_mfdataset("./tmp/err_2D_area_RACMO.nc")
    ds = xr.open_mfdataset(ROOT+"/runoff/runoff_*.nc", 
                           chunks={'time': 100},
                           combine='by_coords')
    da = (ds['runoffcorr'] * (msk['Promicemask'] != 0) * area['Band1'].values) # ice runoff
    da.variable.attrs = {'units':'mm w.e. per day',
                         'long_name':'Downscaled corrected snowmelt',
                         'standard_name':'Downscaled_corrected_snowmelt'}
    ds_sub = da.to_dataset(name='runoff')
    delayed_obj = ds_sub.to_netcdf('./dat/RACMO_runoff_ice.nc', compute=False)
    with ProgressBar(): results = delayed_obj.compute() # 1h20min
    del(ds); del(da); del(ds_sub); del(delayed_obj)    
#+END_SRC

**** TODO Inputs equal outputs?                               :QC:
+ I expect not - the difference should be due to the area scaling

**** Create test files - one year of MAR and RACMO data       :QC:
#+BEGIN_SRC bash :results verbatim
cdo -v selyear,2000 ./dat/MAR_runoff_ice.nc ./tmp/MAR_Y2K_tmp.nc
cdo -v yearsum ./tmp/MAR_Y2K_tmp.nc ./tmp/MAR_Y2K.nc

cdo -v selyear,2000 ./dat/MAR_runoff_land.nc ./tmp/MAR_Y2K_tmp.nc
cdo -v yearsum ./tmp/MAR_Y2K_tmp.nc ./tmp/MAR_Y2K_land.nc

cdo -v selyear,2000 ./dat/RACMO_runoff_ice.nc ./tmp/RACMO_Y2K_tmp.nc
cdo -v yearsum ./tmp/RACMO_Y2K_tmp.nc ./tmp/RACMO_Y2K.nc

rm ./tmp/{MAR,RACMO}_Y2K_tmp.nc
#+END_SRC



*** Freshwater flow rates from RCMs
:PROPERTIES:
:header-args:bash+: :tangle rcm.sh
:END:

#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC

**** Output info table


Have:
| product | loc           | RCM   | DEM       | variable   |
|---------+---------------+-------+-----------+------------|
| runoff  | ice_to_margin | MAR   | ArcticDEM | RUcorr     |
| runoff  | ice_to_margin | RACMO | ArcticDEM | runoffcorr |
| runoff  | land_to_coast | MAR   | ArcticDEM | RUcorr     |
| runoff  | land_to_coast | RACMO | ArcticDEM | runoffcorr |

Can expand to include:
+ [ ] product :: More products (e.g. precip, condensation, etc.)
+ [ ] location :: Add Fjord Surface. Improve linking ice margin to coast
+ [ ] RCM :: More RCMs? More times (future simulations?) Near-realtime Wx forecast?
+ [ ] DEM :: Multiple DEMs? Higher res ArcticDEM?
+ [ ] Other :: Multiple DEM routing schemes (subglacial)

**** SETUP algorithm and prepare data
:PROPERTIES:
:ID:       965c95de-6551-4925-9771-7146ce69d968
:END:

+ The algorithm is designed to capture model data that is over basin ice.
+ This works without extra effort when operating in the ice domain routed to the ice edge, because data outside the domain is masked.
+ However, when working over the ice domain routed to the coast, this includes the land domain. Now 1 km^2 model grid cells that only partially cover an ice basin are included in their entirety.
+ From this, ice runoff routed to the ice edge is not equal to ice runoff routed over land to the coast, but the two should be equal.
+ Therefore, I build a basin mask here
+ Later, we'll apply the smallest version of AND(basin_mask, model_mask) limiting to the smallest ice subset.

#+BEGIN_SRC bash :results verbatim
log_info "Initilazing MAR mapset..."

g.mapset MAR

g.region -d # default region, or raster=basins_merged@coast
r.mapcalc "mask_ice_basin = if(basins@ice_surf, 1, null())"
r.mapcalc "mask_land_basin = if(not(isnull(basins@land_surf)) & isnull(mask_ice_basin), 1, null())"
r.mapcalc "mask_ice_land_basin = if(not(isnull(basins@land_surf)), 1, null())"

g.region MAR@MAR -p
r.in.gdal -o input="NetCDF:${DATADIR}/MAR/3.9/MARv3.9-daily-ERA-Interim-2017.nc:MSK_GIMP" output=MSK_GIMP
r.region map=MSK_GIMP region=MAR@MAR
r.mapcalc "mask_ice_MAR = if((MSK_GIMP == 2) & mask_ice_land_basin, 1, null())"
r.mapcalc "mask_land_MAR = if((MSK_GIMP == 1) & mask_ice_land_basin, 1, null())"
g.region -d

# r.colors map=mask_ice_basin,mask_ice_MAR color=blue
# r.colors map=mask_land_basin,mask_land_MAR color=green
# r.colors map=mask_ice_land_basin color=orange

# r.univar -t map=basins@ice_surf zones=basins@ice_surf | head -n1 | tr '|' '\n' | cat -n
# zone is 1st column; sum is 13th column

# ncdump -v time ./dat/MAR_runoff_ice.nc| grep -A 100000 "^ time =" | grep -o , | wc -l # 14244
# ncdump -v time ./dat/MAR_runoff_ice.nc| grep -A 100000 "^ time =" | tr -dc [,] | wc # 14244

T0=$(ncdump -v time ./dat/MAR_runoff_ice.nc| grep -A 1000 "^ time =" | tr -dc [0-9,] | cut -d, -f1)
T1=$(ncdump -v time ./dat/MAR_runoff_ice.nc| grep -A 100000 "^ time =" | tr -dc [0-9,] | rev | cut -d, -f1 | rev)
#+END_SRC

Below is...
+ NON PARALLEL
+ not tangled
+ Run for 5 days
+ Run parallelized version for 5 days
+ Check outputs are the same

Timing Test:
#+BEGIN_SRC bash :results verbatim :tangle no

r.external -o source="netCDF:./dat/MAR_runoff_ice.nc:runoff" output=model band=1 --o --q
r.region map=model region=MAR@MAR --q

r.mask -r 
time r.univar -t map=model zones=basins@ice_surf > /dev/null # 10-15 sec
#+END_SRC

# Does the mask change results?
# #+BEGIN_SRC bash :results verbatim :tangle no
# r.external -o source="netCDF:./tmp/MAR_Y2K.nc:runoff" output=model band=1 --o --q
# r.region map=model region=MAR@MAR --q

# r.mask -r
# time r.univar map=model zones=basins@ice_surf > ./tmp/r.univar.nomask
# r.mask mask_ice_basin --o
# time r.univar map=model2 zones=basins@ice_surf > ./tmp/r.univar.mask
# diff ./tmp/r.univar.nomask ./tmp/r.univar.mask
# #+END_SRC

# No it does not. Presumably because the mask matches the zones file. It might make a difference for the land data?

# #+BEGIN_SRC bash :results verbatim :tangle no
# r.external -o source="netCDF:./tmp/MAR_Y2K_land.nc:runoff" output=model band=1 --o --q
# r.region map=model region=MAR@MAR --q

# r.mask -r
# time r.univar map=model zones=basins@ice_surf > ./tmp/r.univar.nomask
# r.mask mask_land_basin --o
# time r.univar map=model2 zones=basins@ice_surf > ./tmp/r.univar.mask
# diff ./tmp/r.univar.nomask ./tmp/r.univar.mask
# #+END_SRC

# Yes, here it does, because without the mask all the land cells over ice are included, but we only want the land cells over land.


#+BEGIN_SRC bash :results verbatim :tangle no
### LOOP VERSION (~11 seconds per day)

rm ./tmp/MAR_ice_runoff.noparallel.bsv
rm ./tmp/MAR_ice_runoff.bsv

t=${T0} # DEBUG
for t in $(seq ${T0} 4); do
  date
  tt=$(( $t + 1 )) # T0 is 0-based. r.external is 1-based
  DATESTR=$(date -d"1979-01-01+${t} days" +"%Y-%m-%d")
  r.external -o source="netCDF:./dat/MAR_runoff_ice.nc:runoff" output=model band=${tt} --o --q
  r.region map=model region=MAR@MAR --q
  r.univar -t map=model zones=basins@ice_surf --q | cut -d"|" -f13 | datamash -t"|" transpose | sed s/^sum/${DATESTR}/ >> ./tmp/MAR_ice_runoff.noparallel.bsv
done
#+END_SRC

Implement above code but in parallel
#+BEGIN_SRC bash :results verbatim
function basin_partition() {
    JOB="$1"         # 0 to ndays-1
    SLOT="$2"        # 0 to ncpus-1
    ZONES="$3"       # basins@land_surf, basins@ice_surf, etc.
    RCMfilevar=$4    # MAR_runoff_ice.nc:runoff
    REGION=$5        # MAR@MAR
    
    RCMfile=${RCMfilevar/:*/}  # MAR_runoff_ice.nc

    r.external -o source="netCDF:dat/${RCMfilevar}" output=model_${SLOT} band=${JOB} --o --q 2>/dev/null
    r.region map=model_${SLOT} region=${REGION} --q
    DATESTR0=$(ncdump -h dat/${RCMfile} |grep time:units|cut -d" " -f5)
    DATESTR=$(date -d"${DATESTR0}+$(( ${JOB}-1 )) days" +"%Y-%m-%d")
    r.univar -t map=model_${SLOT} zones=${ZONES} --q 2>/dev/null | cut -d"|" -f13 | datamash -t"|" transpose | sed s/^sum/${DATESTR}/
}
export -f basin_partition

#+END_SRC

DEBUG: Proc 1 day and make sure its same as NON PARALLEL
#+BEGIN_SRC bash :results verbatim :tangle no

seq 5 | parallel --keep-order --bar basin_partition {#} {%} basins@ice_surf "MAR_runoff_ice.nc:runoff" MAR@MAR >> ./tmp/MAR_ice_runoff.bsv # DEBUG

diff -q ./tmp/MAR_ice_runoff.bsv ./tmp/MAR_ice_runoff.noparallel.bsv
head -n1 ./tmp/MAR_ice_runoff.bsv | tr '|' '\n' | wc
tail -n1 ./tmp/MAR_ice_runoff.bsv | tr '|' '\n' | wc
#+END_SRC

We want to calculate
+ ice runoff to ice margin
+ land runoff to coast

All separately. Therefore, easiest to build the ZONES file for r.univar to cover only what we want.

Set up header
#+BEGIN_SRC bash :results verbatim
log_info "Building BSV headers"

r.external -o source="netCDF:./dat/MAR_runoff_ice.nc:runoff" output=model band=1 --o --q # load in a sample day
r.region map=model region=MAR@MAR

r.univar -t map=model zones=basins@ice_surf | sed s/^zone/cat/ | cut -d"|" -f1 | datamash -t"|" transpose > ./dat/ice2margin_header.bsv

r.univar -t map=model zones=basins_no_ice@land_surf | sed s/^zone/cat/ | cut -d"|" -f1 | datamash -t"|" transpose > ./dat/land2coast_header.bsv
#+END_SRC

**** MAR ice runoff at ice outlets

#+BEGIN_SRC bash :results verbatim
FNAME=runoff_ice2margin_MAR.bsv
log_info "Calculating MAR ice runoff at ice outlets: ${FNAME}"
if [[ -e ./dat/${FNAME} ]]; then
  log_warn "Output file ${FNAME} exists. Skipping..."
else
  cp ./dat/ice2margin_header.bsv ./dat/${FNAME}
  seq ${T1} | parallel --keep-order --bar basin_partition {#} {%} basins@ice_surf "MAR_runoff_ice.nc:runoff" MAR@MAR >> ./dat/${FNAME}
fi
#+END_SRC

****** QC: Do outputs match inputs?

I expect outputs to be less than inputs because not every model ice cell is fully sampled, because not every model ice cell has an ice basin under it. Model ice cells over land are not counted.

#+name: MAR_preprocess_in_out_compare 
#+BEGIN_SRC jupyter-python :session QC :exports both :results raw drawer :tangle no :eval no-export
import pandas as pd
import xarray as xr
import numpy as np

DATADIR="/home/kdm/data"
mask = xr.open_dataset(DATADIR+"/MAR/3.9/MARv3.9-daily-ERA-Interim-2017.nc")['MSK_GIMP']

# First day match?   # convert mm/grid cell to m^3
o = pd.read_csv('./dat/runoff_ice2margin_MAR.bsv', sep="|", index_col=0, nrows=1) * 1E-3 * 100 * 100

# first year of input
i = xr.open_dataset('./dat/MAR_runoff_ice.nc').isel(time=0)['runoff'] * 1E-3 * 1000 * 1000 * (mask == 2)

osum = o.sum().sum()
isum = i.sum().values
print(isum, osum)
print(isum/osum)

# check for first year
o = pd.read_csv('./dat/runoff_ice2margin_MAR.bsv', sep="|", index_col=0, nrows=366) * 1E-3 * 100 * 100
i = xr.open_dataset('./dat/MAR_runoff_ice.nc').isel(time=np.arange(366))['runoff'] * 1E-3 * 1000 * 1000 * (mask == 2)
osum = o.sum().sum()
isum = i.sum().values
print(isum, osum)
print(isum/osum)
#+END_SRC

#+RESULTS: MAR_preprocess_in_out_compare
: 2673853.5 2641034.7340516276
: 1.012426480244743
: 231841300000.0 221708223002.34015
: 1.045704563143573

+ Inputs are ~4 % larger than outputs over the first year
  + Due to EPSG:3413 scaling?
  + Due to Arctic Canada in this mask?

**** MAR land runoff at coast outlets
#+BEGIN_SRC bash :results verbatim
FNAME=runoff_land2coast_MAR.bsv
log_info "Calculating MAR land runoff at coast outlets: ${FNAME}"
if [[ -e ./dat/${FNAME} ]]; then
    log_warn "Output file ${FNAME} exists. Skipping..."
else
    cp ./dat/land2coast_header.bsv ./dat/${FNAME}
    seq ${T1} | parallel --keep-order --bar basin_partition {#} {%} basins_no_ice@land_surf "MAR_runoff_land.nc:runoff" MAR@MAR >> ./dat/${FNAME}
fi
#+END_SRC

**** RACMO (same as MAR)
***** Prepare data
#+BEGIN_SRC bash :results verbatim

g.mapset -c RACMO
g.region -d

r.mapcalc "mask_ice_basin = if(basins@ice_surf, 1, null())"
r.mapcalc "mask_land_basin = if(not(isnull(basins@land_surf)) & isnull(mask_ice_basin), 1, null())"
r.mapcalc "mask_ice_land_basin = if(not(isnull(basins@land_surf)), 1, null())"

# log_info "Splitting coast basins into land/ice components"
# r.mapcalc "coast_basins_ice = if(mask_ice_basin, basins@land_surf)"
# r.mapcalc "coast_basins_land = if(mask_land_basin, basins@land_surf)"

g.region RACMO@RACMO -p
FILE=${DATADIR}/RACMO/1km/Icemask_Topo_Iceclasses_lon_lat_average_1km.nc 
r.in.gdal -o input="NetCDF:${FILE}:Icemask" output=mask_ice
r.region map=mask_ice region=RACMO@RACMO
r.mapcalc "mask_ice_RACMO = if((mask_ice == 1) & mask_ice_land_basin, 1, null())"
r.mapcalc "mask_land_RACMO = if((mask_ice == 0) & mask_ice_land_basin, 1, null())"
g.region -d

r.colors map=mask_ice_basin,mask_ice_RACMO color=blue
r.colors map=mask_land_basin,mask_land_RACMO color=green
r.colors map=mask_ice_land_basin color=orange

log_info "Building BSV headers"

r.external -o source="netCDF:./dat/RACMO_runoff_ice.nc:runoff" output=model band=1 --o --q # load in a sample day
r.region map=model region=RACMO@RACMO

log_warn "Overwriting BSV headers"
r.univar -t map=model zones=basins@ice_surf | sed s/^zone/cat/ | cut -d"|" -f1 | datamash -t"|" transpose > ./dat/ice2margin_header.bsv

r.univar -t map=model zones=basins@land_surf | sed s/^zone/cat/ | cut -d"|" -f1 | datamash -t"|" transpose > ./dat/land2coast_header.bsv
#+END_SRC

***** Partition RCMs across basins
#+BEGIN_SRC bash :results verbatim
g.mapset RACMO

FNAME=runoff_ice2margin_RACMO.bsv
log_info "Calculating RACMO ice runoff at ice outlets: ${FNAME}"
if [[ -e ./dat/${FNAME} ]]; then
    log_warn "Output file ${FNAME} exists. Skipping..."
else
    cp ./dat/ice2margin_header.bsv ./dat/${FNAME}
    seq ${T1} | parallel --keep-order --bar basin_partition {#} {%} basins@ice_surf "RACMO_runoff_ice.nc:runoff" RACMO@RACMO >> ./dat/${FNAME}
fi

# FNAME=runoff_ice2coast_RACMO.bsv
# log_info "Calculating RACMO ice runoff at coast outlets: ${FNAME}"
# if [[ -e ./dat/${FNAME} ]]; then
#     log_warn "Output file ${FNAME} exists. Skipping..."
# else
#     cp ./dat/ice2coast_header.bsv ./dat/${FNAME}
#     seq ${T1} | parallel --keep-order --bar basin_partition {#} {%} coast_basins_ice "RACMO_runoff_ice.nc:runoff" RACMO@RACMO >> ./dat/${FNAME}
# fi
#+END_SRC
**** NOTDONE Precipitation (rain+snow) at fjord surface
#+BEGIN_SRC bash :results verbatim :tangle no
grass -c ./G/fjords
g.region -d res=1000 -a -p
r.mask -r

d.mon start=wx0
d.erase
d.rast shade
d.rast land_shade

# fill everything (Disko bay, Geiki, fjords, etc.)
r.grow -m input=head@coast output=grow radius=50000 old=-1 new=1 --o

# shrink back to just the coastal region
r.grow -m input=grow output=shrink radius=-44000 --o

r.null map=shrink setnull=-1

# fill in cells that are part land/coast
# but might have land at the center at 30 m res
r.grow -m input=shrink output=buffer_coast radius=1001 new=1 --o

d.erase
d.rast shade
d.rast buffer_coast

# for display purposes?
r.to.vect input=buffer_coast output=buffer_coast type=point

# then, r.out.xyz for the model data using buffer_coast as a mask. 
# This should produce "x,y,val" for each time step
#+END_SRC


*** Calculate and Prepare Coverage
:PROPERTIES:
:header-args:bash+: :tangle coverage_calc.sh
:END:

**** Calculate
#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC

See [ [[#supplemental:coverage][Coverage]] ]

+ How much of each ice basin is (1) (is not (*)) covered by model ice cells.

#+BEGIN_SRC bash :results verbatim
g.mapset ice_surf

r.mask -r
r.stats --q -aN input=basins@ice_surf,mask_ice_MAR@MAR separator=,  \
	> ./tmp/coverage_ice2margin_MAR.csv
r.stats --q -aN input=basins@ice_surf,mask_ice_RACMO@RACMO separator=,  \
	> ./tmp/coverage_ice2margin_RACMO.csv
#+END_SRC

+ How much of each land basin is (1) (is not (*)) covered by model land cells.

#+BEGIN_SRC bash :results verbatim
g.mapset land_surf

r.mask -r
r.stats --q -aN input=basins_no_ice@land_surf,mask_land_MAR@MAR separator=,  \
	> ./tmp/coverage_land2coast_MAR.csv
#+END_SRC

**** Prepare

Seems the easiest (and fastest) way to apply coverage is to write to NetCDF that can easily be multiplied by the runoff NetCDF files once they are produced.

#+NAME: coverage_prep1
#+BEGIN_SRC jupyter-python :session coverage_prepare :exports results :results drawer
import pandas as pd
import xarray as xr
import numpy as np

if 'c' not in locals(): c = 'ice2margin_MAR'

df_raw = pd.read_csv('./tmp/coverage_'+c+'.csv', index_col=0, names=["c_or_uc", "area"])
df_raw = df_raw.drop(df_raw[df_raw.index == '*'].index)
df_raw.index = df_raw.index.astype(np.int)

df_c = df_raw[df_raw['c_or_uc'] == '1']\
    .drop(labels='c_or_uc', axis='columns')\
    .rename({'area':'covered'}, axis='columns')

df_uc = df_raw[df_raw['c_or_uc'] == '*']\
    .drop(labels='c_or_uc', axis='columns')\
    .rename({'area':'uncovered'}, axis='columns')

df = df_c.merge(df_uc, how='outer', left_index=True, right_index=True)\
         .sort_index()

df.fillna({'uncovered': 0}, inplace=True)

df['runoff'] = df['covered'] / (df['covered'] + df['uncovered'])

cov = df['runoff']
cov.index.name = 'station'
da = xr.DataArray.from_series(cov)
#+END_SRC

#+RESULTS: coverage_prep1


#+NAME: coverage_prepare
#+BEGIN_SRC jupyter-python :session coverage_prepare :exports results :results drawer :tangle coverage_prepare.py
import pandas as pd
import xarray as xr
import numpy as np

for c in ['ice2margin_MAR', 
          'ice2margin_RACMO', 
          'land2coast_MAR']:

    <<coverage_prep1>>
    da.to_netcdf('./tmp/coverage_'+c+'.nc', mode='w')
#+END_SRC

#+RESULTS: coverage_prepare

*** BSV to NC
:PROPERTIES:
:header-args:bash+: :tangle bsv2netcdf.sh
:header-args:jupyter-python+: :tangle bsv2netcdf.py
:END:

+ Split full time series to annual
+ Convert to NetCDF

**** Split BSV to annual files

+ Split each runoff file by year in order to make file sizes manageable

#+BEGIN_SRC bash :results verbatim
# parallel --bar "(datamash -t, transpose < ./freshwater/ice_surf/outlets.csv | tr ',' '|'; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
# 	 ::: $(seq 1979 2017) \
# 	 ::: runoff_ice2margin_MAR.bsv

# parallel --bar "(datamash -t, transpose < ./freshwater/land_surf/outlets.csv  | tr ',' '|'; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
# 	 ::: $(seq 1979 2017) \
# 	 ::: runoff_land2coast_MAR.bsv

parallel --bar "(head -n1 ./dat/{2}; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
	 ::: $(seq 1979 2017) \
	 ::: runoff_ice2margin_MAR.bsv

parallel --bar "(head -n1 ./dat/{2}; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
	 ::: $(seq 1979 2017) \
	 ::: runoff_land2coast_MAR.bsv
#+END_SRC

Repeat for RACMO

#+BEGIN_SRC bash :results verbatim
# parallel --bar "(datamash -t, transpose < ./freshwater/ice_surf/outlets.csv  | tr ',' '|'; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
# 	 ::: $(seq 1979 2017) \
# 	 ::: runoff_ice2margin_RACMO.bsv

parallel --bar "(head -n1 ./dat/{2}; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
	 ::: $(seq 1979 2017) \
	 ::: runoff_ice2margin_RACMO.bsv

# No RACMO land runoff (yet)
# parallel --bar "(datamash -t, transpose < ./freshwater/land_surf/outlets.csv  | tr ',' '|'; grep "^{1}" ./dat/{2}) > ./tmp/{2}.{1}" \
#   ::: $(seq 1979 2017) \
#   ::: runoff_land2coast_RACMO.bsv
#+END_SRC

**** Annual files to NetCDF

Want to produce CF-compliant and user-friendly NetCDF that will work with nco and panoply. 
+ SEE: https://www.nodc.noaa.gov/data/formats/netcdf/v2.0/ timeSeriesProfile
+ https://www.nodc.noaa.gov/data/formats/netcdf/v2.0/timeSeriesOrthogonal.cdl
+ http://cfconventions.org/cf-conventions/cf-conventions.html#time-series-data

Also modeling after:
+ ~/data/Bamber_2018/FWF17.v3_a.nc
+ See also: https://gis.stackexchange.com/questions/67012/using-netcdf-for-point-time-series-observations

This code:
+ Can be run 1x within Org to produce =ds.nc= for testing purposes
+ Is also included in the tangled bsv2netcdf.py script

#+NAME: bsv2xarray
#+BEGIN_SRC jupyter-python :session freshwater :exports both :results raw drawer :tangle no
import pandas as pd
import xarray as xr
import numpy as np
import datetime
import subprocess

# if "BSVFILE" not in locals(): BSVFILE="./tmp/runoff_ice2margin_MAR.bsv.1979"
#if "BSVFILE" not in locals(): BSVFILE="./tmp/runoff_ice2margin_MAR.bsv.2000"
if "BSVFILE" not in locals(): BSVFILE="./tmp/runoff_land2coast_MAR.bsv.1979"

df = pd.read_csv(BSVFILE, index_col=0, delimiter="|")
df.index = pd.to_datetime(df.index)

if 'ice' in BSVFILE: meta = pd.read_csv("./freshwater/ice_surf/outlets.csv", index_col=0).T
if 'land' in BSVFILE: meta = pd.read_csv("./freshwater/land_surf/outlets.csv", index_col=0).T

meta = meta[df.columns.astype(np.int)]

ds = xr.Dataset()

ds["station"] = (("station"), df.columns.astype(np.str).astype(np.uint32))
ds["time"] = (("time"), df.index)

ds["station"].attrs["long_name"] = "outlet id"
ds["station"].attrs["cf_role"] = "timeseries_id"
# ds["station"].attrs["units"] = ""

ds["time"].attrs["long_name"] = "time of measurement"
ds["time"].attrs["standard_name"] = "time"
# ds["time"].attrs["units"] = "day of year"
# ds["time"].attrs["calendar"] = "julian"
ds["time"].attrs["axis"] = "T"

CONV = 1E-3 * 100 * 100 / 86400
ds["runoff"] = (("station", "time"), df.values.T*CONV)
ds["runoff"].attrs["long_name"] = "MAR runoff"
ds["runoff"].attrs["standard_name"] = "water_volume_transport_in_river_channel"
ds["runoff"].attrs["units"] = "m3 s-1"
ds["runoff"].attrs["coordinates"] = "lat lon alt station"

ds["lat"] = (("station"), meta.loc['lat'].astype(np.float32))
#ds["lat"].attrs["coordinates"] = "station"
ds["lat"].attrs["long_name"] = "latitude"
ds["lat"].attrs["standard_name"] = "latitude"
ds["lat"].attrs["units"] = "degrees_north"
ds["lat"].attrs["axis"] = "Y"

ds["lon"] = (("station"), meta.loc['lon'].astype(np.float32))
#ds["lon"].attrs["coordinates"] = "station"
ds["lon"].attrs["long_name"] = "longitude"
ds["lon"].attrs["standard_name"] = "longitude"
ds["lon"].attrs["units"] = "degrees_east"
ds["lon"].attrs["axis"] = "X"

ds["alt"] = (("station"), meta.loc['elev'].astype(np.float32))
ds["alt"].attrs["long_name"] = "height_above_mean_sea_level"
ds["alt"].attrs["standard_name"] = "altitude"
# ds["alt"].attrs["long_name"] = "height above mean sea level"
# ds["alt"].attrs["standard_name"] = "height"
ds["alt"].attrs["units"] = "m"
ds["alt"].attrs["positive"] = "up"
ds["alt"].attrs["axis"] = "Z"

if 'ice' in BSVFILE:
    ds["coast_id"] = (("station"), meta.loc["coast_id"].astype(np.uint32))
    ds["coast_id"].attrs["long_name"] = "ID of coastal outlet"

    ds["coast_lat"] = (("station"), meta.loc['coast_lat'].astype(np.float32))
    ds["coast_lat"].attrs["long_name"] = "latitude"
    ds["coast_lat"].attrs["standard_name"] = "latitude"
    ds["coast_lat"].attrs["units"] = "degrees_north"
    ds["coast_lat"].attrs["axis"] = "Y"

    ds["coast_lon"] = (("station"), meta.loc['coast_lon'].astype(np.float32))
    ds["coast_lon"].attrs["long_name"] = "longitude"
    ds["coast_lon"].attrs["standard_name"] = "longitude"
    ds["coast_lon"].attrs["units"] = "degrees_east"
    ds["coast_lon"].attrs["axis"] = "X"

    ds["coast_alt"] = (("station"), meta.loc['elev'].astype(np.float32))
    ds["coast_alt"].attrs["long_name"] = "height_above_mean_sea_level"
    ds["coast_alt"].attrs["standard_name"] = "altitude"
    ds["coast_alt"].attrs["units"] = "m"
    ds["coast_alt"].attrs["positive"] = "up"
    ds["coast_alt"].attrs["axis"] = "Z"


ds.attrs["featureType"] = "timeSeries"
ds.attrs["title"] = "Greenland runoff"
ds.attrs["summary"] = "Greenland RCM runoff at basin outlets"
ds.attrs["keywords"] = "Hydrology; Greenland; Runoff; Freshwater"
ds.attrs["Conventions"] = "CF-1.7"
ds.attrs["source"] = "git commit: " + \
    subprocess.check_output(["git", "describe", "--always"]).strip().decode('UTF-8')
# ds.attrs["comment"] = "TODO"
# ds.attrs["acknowledgment"] = "TODO"
# ds.attrs["license"] = "TODO"
ds.attrs["date_created"] = datetime.datetime.now().strftime("%Y-%m-%d")
ds.attrs["creator_name"] = "Ken Mankoff"
ds.attrs["creator_email"] = "kdm@geus.dk"
ds.attrs["creator_url"] = "http://kenmankoff.com"
ds.attrs["institution"] = "GEUS"
# ds.attrs["time_coverage_start"] = "TODO"
# ds.attrs["time_coverage_end"] = "TODO"
# ds.attrs["time_coverage_resolution"] = "TODO"
ds.attrs["references"] = "10.22008/promice/data/freshwater_runoff/v01"
ds.attrs["product_version"] = 1.0
#+END_SRC

#+RESULTS: bsv2xarray

And now noweb weave [[bsv2xarray]] to convert all the BSVs to NetCDF files
#+BEGIN_SRC jupyter-python :session freshwater :exports both :results raw drawer
import pandas as pd
import xarray as xr
import numpy as np
from tqdm import tqdm
import os

files = ["runoff_ice2margin_MAR.bsv",
         "runoff_land2coast_MAR.bsv",
         "runoff_ice2margin_RACMO.bsv"]

coverage_files = ["coverage_ice2margin_MAR.nc",
                  "coverage_land2coast_MAR.nc",
                  "coverage_ice2margin_RACMO.nc"]

years = np.arange(1979,2017+1).astype(np.str)

for i,f in enumerate(files):
    cf = coverage_files[i]
    print(f,cf)

    c = xr.open_dataset("./tmp/"+cf)
    c = c.where(c.runoff != 0, np.nan, drop=False)

    fnoext = os.path.splitext(f)[0]
    OUTDIR = "./freshwater/runoff/"+fnoext.split("_")[1].split("2")[1]
    OUTBASE = "_".join([fnoext.split("_")[0],
                        fnoext.split("_")[1].split("2")[0],
                        fnoext.split("_")[2]])

    for y in tqdm(years):
        BSVFILE="./tmp/"+f+"."+y
        <<bsv2xarray>>
        OUTFILE = OUTDIR + "/" + OUTBASE + "_" + y + ".nc"
        ds.runoff.values = ds.runoff/c.runoff # apply coverage
        ds.fillna(0).to_netcdf(OUTFILE, unlimited_dims="time")
#+END_SRC

#+RESULTS:

** Makefile
:PROPERTIES:
:CUSTOM_ID: sec:makefile
:END:

This code, and all code files in this project, are derived products tangled from the sob.org source file.

#+BEGIN_SRC makefile :tangle Makefile
freshwater.zip: G run 
# dist

G:
	grass -e -c EPSG:3413 ./G

run: FORCE
	# basins, outlets, and streams
	grass ./G/PERMANENT --exec ./import.sh
	grass ./G/PERMANENT --exec ./sob.sh 

	grass ./G/PERMANENT --exec ./area_error.sh # model area error
	mkdir -p dat
	python ./preprocess.py
	grass ./G/PERMANENT --exec ./rcm.sh # partition RCM output to basins

	# coverage
	grass ./G/PERMANENT --exec ./coverage_calc.sh
	python coverage_prepare.py

	# post-processing
	mkdir -p freshwater/runoff/coast
	mkdir -p freshwater/runoff/margin
	./bsv2netcdf.sh
	python ./bsv2netcdf.py

dist: freshwater.zip
	zip -r freshwater.zip freshwater

supplemental:
	grass ./G/PERMANENT --exec ./k_basin_change.sh
	grass ./G/PERMANENT --exec ./k_basin_change_diff.sh
	grass ./G/PERMANENT --exec ./k_basin_change_graphics.sh

FORCE: # dummy target

clean_sob:
	rm -fR G/land_* G/ice_* freshwater.zip

clean:
	rm -fR G tmp out freshwater.zip freshwater

clean_RCM:
	rm -fR G/MAR G/RACMO
#+END_SRC
* Data                                                  :noexport:
** Provenance
:PROPERTIES:
:header-args:bash+: :eval no-export :exports both
:END:

+ Show enough information about data files and metadata to aid in reproducibility

*** ArcticDEM

#+NAME: ArcticDEM_provenance
#+BEGIN_SRC bash :results verbatim :exports both
file=${DATADIR}/ArcticDEM/arcticdem_mosaic_100m_v3.0.tif
md5sum ${file}
echo ""
gdalinfo ${file}
#+END_SRC

#+RESULTS: ArcticDEM_provenance
#+begin_example

53f6024b12f216c8d965ffe428289f20  /home/kdm/data/ArcticDEM/arcticdem_mosaic_100m_v3.0.tif

Driver: GTiff/GeoTIFF
Files: /home/kdm/data/ArcticDEM/arcticdem_mosaic_100m_v3.0.tif
Size is 74000, 75000
Coordinate System is:
PROJCS["unnamed",
    GEOGCS["WGS 84",
        DATUM["WGS_1984",
            SPHEROID["WGS 84",6378137,298.257223563,
                AUTHORITY["EPSG","7030"]],
            AUTHORITY["EPSG","6326"]],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433],
        AUTHORITY["EPSG","4326"]],
    PROJECTION["Polar_Stereographic"],
    PARAMETER["latitude_of_origin",70],
    PARAMETER["central_meridian",-45],
    PARAMETER["scale_factor",1],
    PARAMETER["false_easting",0],
    PARAMETER["false_northing",0],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]]]
Origin = (-4000000.000000000000000,4100000.000000000000000)
Pixel Size = (100.000000000000000,-100.000000000000000)
Metadata:
  AREA_OR_POINT=Area
Image Structure Metadata:
  COMPRESSION=LZW
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  (-4000000.000, 4100000.000) (179d17'33.65"E, 40d21'21.16"N)
Lower Left  (-4000000.000,-3400000.000) ( 94d38' 7.67"W, 44d 4' 3.58"N)
Upper Right ( 3400000.000, 4100000.000) ( 95d19'55.77"E, 43d27'58.63"N)
Lower Right ( 3400000.000,-3400000.000) (  0d 0' 0.01"E, 47d35' 3.32"N)
Center      ( -300000.000,  350000.000) (175d36' 4.66"E, 85d44'47.27"N)
Band 1 Block=256x256 Type=Float32, ColorInterp=Gray
  NoData Value=-9999
#+end_example

*** Citterio 2013

#+NAME: Citterio_2013_provenance
#+BEGIN_SRC bash :results verbatim :exports both
file=${DATADIR}/Citterio_2013/PROMICE_250_2015-04-10/PROMICE_250_2015-04-10.shp
md5sum ${file}
#+END_SRC

#+RESULTS: Citterio_2013_provenance
: 
: a69e8f7fa340d8998c69aef539de8c58  /home/kdm/data/Citterio_2013/PROMICE_250_2015-04-10/PROMICE_250_2015-04-10.shp

*** GIMP_0714

#+NAME: GIMP_0714_provenance
#+BEGIN_SRC bash :results verbatim :exports both
file=${DATADIR}/GIMP/0714/GimpOceanMask_90m_v1.1.tif
md5sum ${file}
echo ""
gdalinfo ${file}
#+END_SRC

#+RESULTS: GIMP_0714_provenance
#+begin_example

99e30ed3209ef4c6d4fe4e84cd76596c  /home/kdm/data/GIMP/0714/GimpOceanMask_90m_v1.1.tif

Driver: GTiff/GeoTIFF
Files: /home/kdm/data/GIMP/0714/GimpOceanMask_90m_v1.1.tif
Size is 16620, 30000
Coordinate System is:
PROJCS["unnamed",
    GEOGCS["WGS 84",
        DATUM["WGS_1984",
            SPHEROID["WGS 84",6378137,298.257223563,
                AUTHORITY["EPSG","7030"]],
            AUTHORITY["EPSG","6326"]],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433],
        AUTHORITY["EPSG","4326"]],
    PROJECTION["Polar_Stereographic"],
    PARAMETER["latitude_of_origin",70],
    PARAMETER["central_meridian",-45],
    PARAMETER["scale_factor",1],
    PARAMETER["false_easting",1],
    PARAMETER["false_northing",1],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]]]
Origin = (-640000.000000000000000,-655550.000000000000000)
Pixel Size = (90.000000000000000,-90.000000000000000)
Metadata:
  AREA_OR_POINT=Area
Image Structure Metadata:
  COMPRESSION=DEFLATE
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  ( -640000.000, -655550.000) ( 89d18'44.40"W, 81d33'26.51"N)
Lower Left  ( -640000.000,-3355550.000) ( 55d47'53.80"W, 59d11'57.96"N)
Upper Right (  855800.000, -655550.000) (  7d32'51.02"E, 80d 4'20.46"N)
Lower Right (  855800.000,-3355550.000) ( 30d41'32.31"W, 58d47'45.95"N)
Center      (  107900.000,-2005550.000) ( 41d55'13.60"W, 71d36'44.99"N)
Band 1 Block=16620x1 Type=Int16, ColorInterp=Gray
#+end_example



*** BedMachine v3

#+NAME: BM3_md5sum_ncdump
#+BEGIN_SRC bash :results verbatim :exports both
md5sum ${DATADIR}/Morlighem_2017/*
echo ""
ncdump -chs ${DATADIR}/Morlighem_2017/BedMachine*
#+END_SRC

#+RESULTS: BM3_md5sum_ncdump
#+begin_example
6cabf8b507e3bddea089f60204891168  /home/kdm/data/Morlighem_2017/BedMachineGreenland-2017-09-20.nc

netcdf BedMachineGreenland-2017-09-20 {
dimensions:
	x = 10218 ;
	y = 18346 ;
variables:
	char mapping ;
		mapping:geoid = "eigen-6c4" ;
		mapping:false_easting = 0. ;
		mapping:false_northing = 0. ;
		mapping:grid_mapping_name = "polar_stereographic" ;
		mapping:latitude_of_projection_origin = 90. ;
		mapping:standard_parallel = 70. ;
		mapping:straight_vertical_longitude_from_pole = -45. ;
	int x(x) ;
		x:long_name = "Cartesian x-coordinate" ;
		x:standard_name = "projection_x_coordinate" ;
		x:units = "meter" ;
		x:_Storage = "contiguous" ;
		x:_Endianness = "little" ;
	int y(y) ;
		y:long_name = "Cartesian y-coordinate" ;
		y:standard_name = "projection_y_coordinate" ;
		y:units = "meter" ;
		y:_Storage = "contiguous" ;
		y:_Endianness = "little" ;
	byte mask(y, x) ;
		mask:long_name = "mask (0 = ocean, 1 = ice-free land, 2 = grounded ice, 3 = floating ice, 4 = non-Greenland land)" ;
		mask:grid_mapping = "mapping" ;
		mask:valid_range = 0b, 4b ;
		mask:flag_values = 0b, 1b, 2b, 3b, 4b ;
		mask:flag_meanings = "ocean ice_free_land grounded_ice floating_ice non_greenland_land" ;
		mask:source = "gimpmask v2.0 (http://bprc.osu.edu/GDG/icemask.php) combined with coastline from Jeremie Mouginot" ;
		mask:_Storage = "contiguous" ;
	short surface(y, x) ;
		surface:long_name = "ice surface elevation" ;
		surface:standard_name = "surface_altitude" ;
		surface:units = "meters" ;
		surface:grid_mapping = "mapping" ;
		surface:source = "gimpdem v2.1 (http://bprc.osu.edu/GDG/gimpdem.php)" ;
		surface:_Storage = "contiguous" ;
		surface:_Endianness = "little" ;
	short thickness(y, x) ;
		thickness:long_name = "ice thickness" ;
		thickness:standard_name = "land_ice_thickness" ;
		thickness:units = "meters" ;
		thickness:grid_mapping = "mapping" ;
		thickness:source = "Mass conservation (Mathieu Morlighem)" ;
		thickness:_Storage = "contiguous" ;
		thickness:_Endianness = "little" ;
	short bed(y, x) ;
		bed:long_name = "bed topography" ;
		bed:standard_name = "bedrock_altitude" ;
		bed:units = "meters" ;
		bed:grid_mapping = "mapping" ;
		bed:source = "Mass conservation (Mathieu Morlighem)" ;
		bed:_FillValue = -9999s ;
		bed:_Storage = "contiguous" ;
		bed:_Endianness = "little" ;
	short errbed(y, x) ;
		errbed:long_name = "bed topography/ice thickness error" ;
		errbed:units = "meters" ;
		errbed:grid_mapping = "mapping" ;
		errbed:source = "Mathieu Morlighem" ;
		errbed:_FillValue = -9999s ;
		errbed:_Storage = "contiguous" ;
		errbed:_Endianness = "little" ;
	byte source(y, x) ;
		source:long_name = "data source (0 = none, 1 = gimpdem, 2 = Mass conservation, 3 = synthetic, 4 = interpolation, 5 = hydrostatic equilibrium, 6 = kriging, 7 = RTOPO-2, 8 = gravity inversion, 10+ = bathymetry data)" ;
		source:grid_mapping = "mapping" ;
		source:valid_range = 0b, 40b ;
		source:flag_values = 0b, 1b, 2b, 3b, 4b, 5b, 6b, 7b, 8b, 10b, 11b, 12b, 13b, 14b, 15b, 16b, 17b, 18b, 19b, 20b, 21b, 22b, 23b, 24b, 25b, 26b, 27b, 28b, 29b, 30b, 31b, 32b, 33b, 34b, 35b, 36b, 37b, 38b, 39b, 40b ;
		source:flag_meanings = "none gimpdem mass_conservation synthetic interpolation hydrodstatic_equilibrium kriging RTopo_2 gravity_inversion bathymetry1 bathymetry2 bathymetry3 bathymetry4 bathymetry5 bathymetry6 bathymetry7 bathymetry8 bathymetry9 bathymetry10 bathymetry11 bathymetry12 bathymetry13 bathymetry14 bathymetry15 bathymetry16 bathymetry17 bathymetry18 bathymetry19 bathymetry20 bathymetry21 bathymetry22 bathymetry23 bathymetry24 bathymetry25 bathymetry26 bathymetry27 bathymetry28 bathymetry29 bathymetry30 bathymetry31" ;
		source:source = "Mathieu Morlighem, RTOPO-2" ;
		source:_Storage = "contiguous" ;
	short geoid(y, x) ;
		geoid:long_name = "EIGEN-EC4 Geoid - WGS84 Ellipsoid difference" ;
		geoid:standard_name = "geoid_height_above_reference_ellipsoid" ;
		geoid:units = "meters" ;
		geoid:grid_mapping = "mapping" ;
		geoid:geoid = "eigen-6c4 (Forste et al 2014)" ;
		geoid:_Storage = "contiguous" ;
		geoid:_Endianness = "little" ;

// global attributes:
		:Conventions = "CF-1.6" ;
		:Metadata_Conventions = "CF-1.6, Unidata Dataset Discovery v1.0, GDS v2.0" ;
		:title = "BedMachine Greenland" ;
		:summary = "self-consistent bed/bathymetry/surface/thickness/mask dataset of the Greenland ice sheet based on mass conservation, ice penetrating radar data and bathymetry data" ;
		:keywords = "0720 Glaciers, 0726 Ice sheets, 0730 Ice streams, 0794 Instruments and techniques, 0798 Modeling" ;
		:keywords_vocabulary = "AGU Index Terms" ;
		:author = "Mathieu Morlighem" ;
		:creator_name = "Mathieu Morlighem" ;
		:creator_email = "mathieu.morlighem@uci.edu" ;
		:institution = "Department of Earth System Science, University of California Irvine" ;
		:date_created = "20-Sep-2017 09:03:04" ;
		:product_version = "v3.10" ;
		:cdm_data_type = "Grid" ;
		:nx = 18346. ;
		:ny = 10218. ;
		:Projection = "Polar Stereographic North (70N, 45W)" ;
		:proj4 = "+init=epsg:3413" ;
		:xmin = -652925 ;
		:ymax = -632675 ;
		:spacing = 150 ;
		:no_data = -9999. ;
		:license = "No restrictions on access or use" ;
		:Data_citation = "Morlighem M. et al., (2017), BedMachine v3: Complete bed topography and ocean bathymetry mapping of Greenland from multi-beam echo sounding combined with mass conservation, Geophys. Res. Lett., 44, doi:10.1002/2017GL074954. (http://onlinelibrary.wiley.com/doi/10.1002/2017GL074954/full)" ;
		:_SuperblockVersion = 2 ;
		:_IsNetcdf4 = 1 ;
		:_Format = "netCDF-4 classic model" ;
}
#+end_example
*** COMMENT BedMachine v2

#+NAME: BM2_md5sum_ncdump
#+BEGIN_SRC bash :results verbatim :exports both
md5sum ${DATADIR}/Morlighem_2014/*
echo ""
ncdump -chs ${DATADIR}/Morlighem_2014/MCdataset-2015-04-27.nc
#+END_SRC

#+RESULTS: BM2_md5sum_ncdump
#+begin_example
78cfa2f0bda16b7e3cf1bb69cfc1bae6  /home/kdm/data/Morlighem_2014/MCdataset-2015-04-27.nc

netcdf MCdataset-2015-04-27 {
dimensions:
	x = 10018 ;
	y = 17946 ;
variables:
	int x(x) ;
		x:long_name = "Cartesian x-coordinate" ;
		x:standard_name = "projection_x_coordinate" ;
		x:units = "meter" ;
		x:_Storage = "contiguous" ;
		x:_Endianness = "little" ;
	int y(y) ;
		y:long_name = "Cartesian y-coordinate" ;
		y:standard_name = "projection_y_coordinate" ;
		y:units = "meter" ;
		y:_Storage = "contiguous" ;
		y:_Endianness = "little" ;
	byte mask(y, x) ;
		mask:long_name = "mask (0 = ocean, 1 = ice-free land, 2 = grounded ice, 3 = floating ice, 4 = non-Greenland land)" ;
		mask:units = "none" ;
		mask:grid_mapping = "polar_stereographic" ;
		mask:valid_range = 0b, 4b ;
		mask:flag_values = 0b, 1b, 2b, 3b, 4b ;
		mask:flag_meanings = "ocean ice_free_land grounded_ice floating_ice non_greenland_land" ;
		mask:source = "gimpmask v2.0 (http://bprc.osu.edu/GDG/icemask.php) combined with coastline from Jeremie Mouginot" ;
		mask:_Storage = "contiguous" ;
	short surface(y, x) ;
		surface:long_name = "ice surface elevation" ;
		surface:standard_name = "surface_altitude" ;
		surface:units = "meters" ;
		surface:grid_mapping = "polar_stereographic" ;
		surface:source = "gimpdem v2.1 (http://bprc.osu.edu/GDG/gimpdem.php)" ;
		surface:_Storage = "contiguous" ;
		surface:_Endianness = "little" ;
	short thickness(y, x) ;
		thickness:long_name = "ice thickness" ;
		thickness:standard_name = "land_ice_thickness" ;
		thickness:units = "meters" ;
		thickness:grid_mapping = "polar_stereographic" ;
		thickness:source = "Mass conservation (Mathieu Morlighem)" ;
		thickness:_Storage = "contiguous" ;
		thickness:_Endianness = "little" ;
	short bed(y, x) ;
		bed:long_name = "bed topography" ;
		bed:standard_name = "bedrock_altitude" ;
		bed:units = "meters" ;
		bed:grid_mapping = "polar_stereographic" ;
		bed:source = "Mass conservation (Mathieu Morlighem)" ;
		bed:_FillValue = -9999s ;
		bed:_Storage = "contiguous" ;
		bed:_Endianness = "little" ;
	short errbed(y, x) ;
		errbed:long_name = "bed topography/ice thickness error" ;
		errbed:units = "meters" ;
		errbed:grid_mapping = "polar_stereographic" ;
		errbed:source = "Mathieu Morlighem" ;
		errbed:_FillValue = -9999s ;
		errbed:_Storage = "contiguous" ;
		errbed:_Endianness = "little" ;
	byte source(y, x) ;
		source:long_name = "data source (0 = none, 1 = gimpdem, 2 = Mass conservation, 4 = interpolation, 5 = hydrostatic equilibrium, 6 = kriging, 7 = IBCAO v3, 8 = bathymetry data)" ;
		source:units = "none" ;
		source:grid_mapping = "polar_stereographic" ;
		source:valid_range = 0b, 8b ;
		source:flag_values = 0b, 1b, 2b, 3b, 4b, 5b, 6b, 7b, 8b ;
		source:flag_meanings = "none gimpdem mass_conservation none interpolation hydrodstatic_equilibrium kriging ibcao_v3 bathymetry_data" ;
		source:source = "Mathieu Morlighem, IBCAO v3, Eric Rignot (pers. comm.)" ;
		source:_Storage = "contiguous" ;
	short geoid(y, x) ;
		geoid:long_name = "EIGEN-EC4 Geoid - WGS84 Ellipsoid difference" ;
		geoid:standard_name = "geoid_height_above_reference_ellipsoid" ;
		geoid:units = "meters" ;
		geoid:grid_mapping = "polar_stereographic" ;
		geoid:geoid = "eigen-6c4 (Forste et al 2014)" ;
		geoid:_Storage = "contiguous" ;
		geoid:_Endianness = "little" ;
	byte polar_stereographic ;
		polar_stereographic:geoid = "eigen-6c4" ;
		polar_stereographic:false_easting = 0. ;
		polar_stereographic:false_northing = 0. ;
		polar_stereographic:grid_mapping_name = "polar_stereographic" ;
		polar_stereographic:latitude_of_projection_origin = 90. ;
		polar_stereographic:standard_parallel = 70. ;
		polar_stereographic:straight_vertical_longitude_from_pole = -45. ;

// global attributes:
		:Conventions = "CF-1.4" ;
		:Title = "BedMachine: Greenland dataset based on mass conservation" ;
		:Author = "Mathieu Morlighem" ;
		:version = "27-Apr-2015 (v1.9)" ;
		:nx = 10018. ;
		:ny = 17946. ;
		:Projection = "Polar Stereographic North (70N, 45W)" ;
		:proj4 = "+init=espg:3413" ;
		:xmin = -638000. ;
		:ymax = -657600. ;
		:spacing = 150. ;
		:no_data = -9999. ;
		:Data_citation = "M. Morlighem, E. Rignot, J. Mouginot, H. Seroussi and E. Larour, Deeply incised submarine glacial valleys beneath the Greenland Ice Sheet, Nat. Geosci., 7, 418-422, 2014, doi:10.1038/ngeo2167, http://www.nature.com/ngeo/journal/vaop/ncurrent/full/ngeo2167.html" ;
		:Notes = "Data processed at the Department of Earth System Science, University of California, Irvine" ;
		:_SuperblockVersion = 2 ;
		:_IsNetcdf4 = 1 ;
		:_Format = "netCDF-4 classic model" ;
}
#+end_example

*** MAR
**** File list and md5sums

+ WARN :: May be stale. Using pre-computed md5sum because it takes so long to calculate.

#+BEGIN_SRC bash :results verbatim :exports both
ROOT=${DATADIR}/MAR/3.9
cat ${ROOT}/md5sum.txt
#+END_SRC

#+RESULTS:
#+begin_example

d40925798aba763b74425f6f31070af8  MARv3.9-daily-ERA-Interim-1979.nc
c87d8ab9041f79cff8da1fa374dc9878  MARv3.9-daily-ERA-Interim-1980.nc
30eb6543eb1874770ec3591a4fdf3e82  MARv3.9-daily-ERA-Interim-1981.nc
29875a4bdb543842f52a598e8ad71430  MARv3.9-daily-ERA-Interim-1982.nc
403cbdd00b3a60853e94fafef9dd726b  MARv3.9-daily-ERA-Interim-1983.nc
532c5ba5f6ff9b1ed429904adb708e0e  MARv3.9-daily-ERA-Interim-1984.nc
0f30163620696439ba7e196f95498724  MARv3.9-daily-ERA-Interim-1985.nc
b0b988084fe0bdb303927579c181e9fc  MARv3.9-daily-ERA-Interim-1986.nc
ce0c0180873ff59a1cb21239c5082323  MARv3.9-daily-ERA-Interim-1987.nc
92f4b428251e0a51bb46e82c44f5576b  MARv3.9-daily-ERA-Interim-1988.nc
cb716bcf958c1d3089cf6db13fb7649d  MARv3.9-daily-ERA-Interim-1989.nc
0e9d61168f39478780e555e3971a61fc  MARv3.9-daily-ERA-Interim-1990.nc
2c015972d1f4034efd08c67f37eceb51  MARv3.9-daily-ERA-Interim-1991.nc
9fce5a90921d3a4b2619d55f03d8f762  MARv3.9-daily-ERA-Interim-1992.nc
19b97b659f44547ea9473c86895ca93c  MARv3.9-daily-ERA-Interim-1993.nc
a30e838b89dbd938341a8e545fe10d3e  MARv3.9-daily-ERA-Interim-1994.nc
8642f1211deb6db3726d69fb8676d0a1  MARv3.9-daily-ERA-Interim-1995.nc
9dc1e4beea6376062377925c1d5b1983  MARv3.9-daily-ERA-Interim-1996.nc
dc6a0896bce125c594fae59b014240dd  MARv3.9-daily-ERA-Interim-1997.nc
ba886751e9f3a4d3f738635e69c9eaf5  MARv3.9-daily-ERA-Interim-1998.nc
2ad3cf5f5c9ec95662c0ed042f560648  MARv3.9-daily-ERA-Interim-1999.nc
6190e96ed1162c90266d796565dfbc90  MARv3.9-daily-ERA-Interim-2000.nc
2ea886074013bdccdc412808fa13bf24  MARv3.9-daily-ERA-Interim-2001.nc
768ee3a27a0ea92477f117448e795481  MARv3.9-daily-ERA-Interim-2002.nc
a18b5fc263f9970e602f5e274d3abea9  MARv3.9-daily-ERA-Interim-2003.nc
cae6bca5c0b84468231f696f88aa83c8  MARv3.9-daily-ERA-Interim-2004.nc
5d743a07663176b5380c61e2b30b7477  MARv3.9-daily-ERA-Interim-2005.nc
2362b9b22f40650ddc896110f38fb158  MARv3.9-daily-ERA-Interim-2006.nc
826d61fa629c29fc69ea65498ecdcf3e  MARv3.9-daily-ERA-Interim-2007.nc
d7bc412863ff1fa75bc32565b4576e79  MARv3.9-daily-ERA-Interim-2008.nc
03c75cb56840082dae68c3b914c95faf  MARv3.9-daily-ERA-Interim-2009.nc
b8df46e1aaed7481546679fc724fcd62  MARv3.9-daily-ERA-Interim-2010.nc
ecbe7f291f64d7f839d88f91d21df5bd  MARv3.9-daily-ERA-Interim-2011.nc
a520417182534fe3dfe4e2d9d27b94ce  MARv3.9-daily-ERA-Interim-2012.nc
722f603eb45c593565248b9d19bc880a  MARv3.9-daily-ERA-Interim-2013.nc
ceb0b0655046323b477bf1423dcd3ea2  MARv3.9-daily-ERA-Interim-2014.nc
bd8225d34160df48799c37268287648f  MARv3.9-daily-ERA-Interim-2015.nc
8108d40603e4ee491a222462621bc325  MARv3.9-daily-ERA-Interim-2016.nc
0767d7730dff7c6ae9645c3652b1c717  MARv3.9-daily-ERA-Interim-2017.nc
#+end_example

**** ncdump

#+NAME: MAR_QC_ncdump
#+BEGIN_SRC bash :results verbatim :exports both
ROOT=${DATADIR}/MAR/3.9
ncdump -chs ${ROOT}/MARv3.9-daily-ERA-Interim-1979.nc
#+END_SRC

#+RESULTS: MAR_QC_ncdump
#+begin_example

netcdf MARv3.9-daily-ERA-Interim-1979 {
dimensions:
	time = 365 ;
	x = 1496 ;
	y = 2700 ;
variables:
	float time(time) ;
		time:units = "DAY since 1979-01-01 12:00:00" ;
		time:long_name = "time" ;
		time:standard_name = "time" ;
		time:_Storage = "chunked" ;
		time:_ChunkSizes = 365 ;
		time:_DeflateLevel = 2 ;
		time:_Shuffle = "true" ;
		time:_Endianness = "little" ;
		time:_NoFill = "true" ;
	float x(x) ;
		x:units = "km" ;
		x:long_name = "x" ;
		x:standard_name = "x" ;
		x:_Storage = "chunked" ;
		x:_ChunkSizes = 1496 ;
		x:_DeflateLevel = 2 ;
		x:_Shuffle = "true" ;
		x:_Endianness = "little" ;
		x:_NoFill = "true" ;
	float y(y) ;
		y:units = "km" ;
		y:long_name = "y" ;
		y:standard_name = "y" ;
		y:_Storage = "chunked" ;
		y:_ChunkSizes = 2700 ;
		y:_DeflateLevel = 2 ;
		y:_Shuffle = "true" ;
		y:_Endianness = "little" ;
		y:_NoFill = "true" ;
	float LON(y, x) ;
		LON:units = "degrees" ;
		LON:long_name = "Longitude" ;
		LON:standard_name = "Longitude" ;
		LON:_FillValue = 9.96921e+36f ;
		LON:missing_value = 9.96921e+36f ;
		LON:_Storage = "chunked" ;
		LON:_ChunkSizes = 1350, 748 ;
		LON:_DeflateLevel = 2 ;
		LON:_Shuffle = "true" ;
		LON:_Endianness = "little" ;
		LON:_NoFill = "true" ;
	float LAT(y, x) ;
		LAT:units = "degrees" ;
		LAT:long_name = "Latitude" ;
		LAT:standard_name = "Latitude" ;
		LAT:_FillValue = 9.96921e+36f ;
		LAT:missing_value = 9.96921e+36f ;
		LAT:_Storage = "chunked" ;
		LAT:_ChunkSizes = 1350, 748 ;
		LAT:_DeflateLevel = 2 ;
		LAT:_Shuffle = "true" ;
		LAT:_Endianness = "little" ;
		LAT:_NoFill = "true" ;
	float MSK_GIMP(y, x) ;
		MSK_GIMP:units = "-" ;
		MSK_GIMP:long_name = "GIMP Ice Mask" ;
		MSK_GIMP:standard_name = "GIMP_Ice_Mask" ;
		MSK_GIMP:_FillValue = 9.96921e+36f ;
		MSK_GIMP:missing_value = 9.96921e+36f ;
		MSK_GIMP:_Storage = "chunked" ;
		MSK_GIMP:_ChunkSizes = 1350, 748 ;
		MSK_GIMP:_DeflateLevel = 2 ;
		MSK_GIMP:_Shuffle = "true" ;
		MSK_GIMP:_Endianness = "little" ;
		MSK_GIMP:_NoFill = "true" ;
	float AREA(y, x) ;
		AREA:units = "-" ;
		AREA:long_name = "Area" ;
		AREA:standard_name = "Area" ;
		AREA:_FillValue = 9.96921e+36f ;
		AREA:missing_value = 9.96921e+36f ;
		AREA:_Storage = "chunked" ;
		AREA:_ChunkSizes = 1350, 748 ;
		AREA:_DeflateLevel = 2 ;
		AREA:_Shuffle = "true" ;
		AREA:_Endianness = "little" ;
		AREA:_NoFill = "true" ;
	float PROMICE(y, x) ;
		PROMICE:units = "-" ;
		PROMICE:long_name = "PROMICE Ice Mask" ;
		PROMICE:standard_name = "PROMICE_Ice_Mask" ;
		PROMICE:_FillValue = 9.96921e+36f ;
		PROMICE:missing_value = 9.96921e+36f ;
		PROMICE:_Storage = "chunked" ;
		PROMICE:_ChunkSizes = 1350, 748 ;
		PROMICE:_DeflateLevel = 2 ;
		PROMICE:_Shuffle = "true" ;
		PROMICE:_Endianness = "little" ;
		PROMICE:_NoFill = "true" ;
	float SRF_GIMP(y, x) ;
		SRF_GIMP:units = "m" ;
		SRF_GIMP:long_name = "GIMP Surface height" ;
		SRF_GIMP:standard_name = "GIMP_Surface_height" ;
		SRF_GIMP:_FillValue = 9.96921e+36f ;
		SRF_GIMP:missing_value = 9.96921e+36f ;
		SRF_GIMP:_Storage = "chunked" ;
		SRF_GIMP:_ChunkSizes = 1350, 748 ;
		SRF_GIMP:_DeflateLevel = 2 ;
		SRF_GIMP:_Shuffle = "true" ;
		SRF_GIMP:_Endianness = "little" ;
		SRF_GIMP:_NoFill = "true" ;
	float SRF_BAMBER(y, x) ;
		SRF_BAMBER:units = "m" ;
		SRF_BAMBER:long_name = "Bamber et al.(2013) Surface height" ;
		SRF_BAMBER:standard_name = "Bamber_et_al__2013__Surface_height" ;
		SRF_BAMBER:_FillValue = 9.96921e+36f ;
		SRF_BAMBER:missing_value = 9.96921e+36f ;
		SRF_BAMBER:_Storage = "chunked" ;
		SRF_BAMBER:_ChunkSizes = 1350, 748 ;
		SRF_BAMBER:_DeflateLevel = 2 ;
		SRF_BAMBER:_Shuffle = "true" ;
		SRF_BAMBER:_Endianness = "little" ;
		SRF_BAMBER:_NoFill = "true" ;
	float MSK_MAR(y, x) ;
		MSK_MAR:units = "-" ;
		MSK_MAR:long_name = "MAR 15x15km2 Ice Mask" ;
		MSK_MAR:standard_name = "MAR_15x15km2_Ice_Mask" ;
		MSK_MAR:_FillValue = 9.96921e+36f ;
		MSK_MAR:missing_value = 9.96921e+36f ;
		MSK_MAR:_Storage = "chunked" ;
		MSK_MAR:_ChunkSizes = 1350, 748 ;
		MSK_MAR:_DeflateLevel = 2 ;
		MSK_MAR:_Shuffle = "true" ;
		MSK_MAR:_Endianness = "little" ;
		MSK_MAR:_NoFill = "true" ;
	float SRF_MAR(y, x) ;
		SRF_MAR:units = "m" ;
		SRF_MAR:long_name = "MAR 15x15km2 Surface height" ;
		SRF_MAR:standard_name = "MAR_15x15km2_Surface_height" ;
		SRF_MAR:_FillValue = 9.96921e+36f ;
		SRF_MAR:missing_value = 9.96921e+36f ;
		SRF_MAR:_Storage = "chunked" ;
		SRF_MAR:_ChunkSizes = 1350, 748 ;
		SRF_MAR:_DeflateLevel = 2 ;
		SRF_MAR:_Shuffle = "true" ;
		SRF_MAR:_Endianness = "little" ;
		SRF_MAR:_NoFill = "true" ;
	float RU(time, y, x) ;
		RU:units = "mmWEday" ;
		RU:long_name = "Water run-off (sub-pixel 1)" ;
		RU:standard_name = "Water_run-off__sub-pixel_1_" ;
		RU:_FillValue = 9.96921e+36f ;
		RU:missing_value = 9.96921e+36f ;
		RU:_Storage = "chunked" ;
		RU:_ChunkSizes = 31, 225, 125 ;
		RU:_DeflateLevel = 2 ;
		RU:_Shuffle = "true" ;
		RU:_Endianness = "little" ;
		RU:_NoFill = "true" ;
	float RU2(time, y, x) ;
		RU2:units = "mmWE/month" ;
		RU2:long_name = "Water run-off (sub-pixel 2)" ;
		RU2:standard_name = "Water_run-off__sub-pixel_2_" ;
		RU2:_FillValue = 9.96921e+36f ;
		RU2:missing_value = 9.96921e+36f ;
		RU2:_Storage = "chunked" ;
		RU2:_ChunkSizes = 31, 225, 125 ;
		RU2:_DeflateLevel = 2 ;
		RU2:_Shuffle = "true" ;
		RU2:_Endianness = "little" ;
		RU2:_NoFill = "true" ;
	float SF(time, y, x) ;
		SF:units = "mmWE/day" ;
		SF:long_name = "Snowfall" ;
		SF:standard_name = "Snowfall" ;
		SF:_FillValue = 9.96921e+36f ;
		SF:missing_value = 9.96921e+36f ;
		SF:_Storage = "chunked" ;
		SF:_ChunkSizes = 31, 225, 125 ;
		SF:_DeflateLevel = 2 ;
		SF:_Shuffle = "true" ;
		SF:_Endianness = "little" ;
		SF:_NoFill = "true" ;
	float RF(time, y, x) ;
		RF:units = "mmWE/day" ;
		RF:long_name = "Rainfall" ;
		RF:standard_name = "Rainfall" ;
		RF:_FillValue = 9.96921e+36f ;
		RF:missing_value = 9.96921e+36f ;
		RF:_Storage = "chunked" ;
		RF:_ChunkSizes = 31, 225, 125 ;
		RF:_DeflateLevel = 2 ;
		RF:_Shuffle = "true" ;
		RF:_Endianness = "little" ;
		RF:_NoFill = "true" ;
	float RUcorr(time, y, x) ;
		RUcorr:units = "mmWEday" ;
		RUcorr:long_name = "1km Topography corrected Water run-off (sub-pixel 1)" ;
		RUcorr:standard_name = "1km_Topography_corrected_Water_run-off__sub-pixel_1_" ;
		RUcorr:_FillValue = 9.96921e+36f ;
		RUcorr:missing_value = 9.96921e+36f ;
		RUcorr:_Storage = "chunked" ;
		RUcorr:_ChunkSizes = 31, 225, 125 ;
		RUcorr:_DeflateLevel = 2 ;
		RUcorr:_Shuffle = "true" ;
		RUcorr:_Endianness = "little" ;
		RUcorr:_NoFill = "true" ;

// global attributes:
		:title = "Daily MARv3.9 outputs in 1979 interpolated on the 1x1km^2 grid of GIMP using ERA-Interim" ;
		:institution = "University of Liège" ;
		:grid = "Map Projection:Polar Stereographic Ellipsoid - Map Reference Latitude: 90.0 - Map Reference Longitude: -39.0 - Map Second Reference Latitude: 71.0 - Map Eccentricity: 0.081819190843 ;wgs84 - Map Equatorial Radius: 6378137.0 ;wgs84 meters - Grid Map Origin Column: 160 - Grid Map Origin Row: -120 - Grid Map Units per Cell: 5000 - Grid Width: 301 - Grid Height: 561" ;
		:history = "libUN (2013.05.22) - Thu Nov 29 10:52:53 2018" ;
" ;
		:institute = "University of Liège (Belgium)" ;
		:contact = "xavierfettweis@ulg.ac.be" ;
		:model = "regional climate model MARv3.9" ;
		:forcing = "ERA-Interim" ;
		:creation_date = "2018-11-29-T124240Z" ;
		:frequency = "mon" ;
		:_NCProperties = "version=1|netcdflibversion=4.6.1|hdf5libversion=1.10.3" ;
		:_SuperblockVersion = 0 ;
		:_IsNetcdf4 = 1 ;
		:_Format = "netCDF-4 classic model" ;
}
#+end_example

*** RACMO
**** File list and md5sums

+ WARN :: Only check some to save compute time.

#+NAME: RACMO_QC_md5sum
#+BEGIN_SRC bash :results table :exports both
(cd ${DATADIR}/RACMO/1km/runoff; find . -type f | LC_ALL=C sort | head -n8 | parallel --keep-order md5sum)
(cd ${DATADIR}/RACMO/1km/runoff; find . -type f | LC_ALL=C sort | tail -n8 | parallel --keep-order md5sum)
#+END_SRC

#+RESULTS: RACMO_QC_md5sum
| a0ae77c8af7b77ea70bd26bab31bb929 | ./runoff_WJB_int.1979_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 7804a433973b109f6ae9e808a27f39f3 | ./runoff_WJB_int.1979_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 93aed2f6fd4502112c7fa9c3953a120e | ./runoff_WJB_int.1979_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 0cb42cbf4f06a42ee35eb043307c68ff | ./runoff_WJB_int.1979_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| c5261cb3db35f3bce83fef0f0b59c905 | ./runoff_WJB_int.1980_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 5e17a3553128fd3b3e84776e51d9163d | ./runoff_WJB_int.1980_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 0e6369f5cfeef946dc764bdf2ee677db | ./runoff_WJB_int.1980_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| f1bcad9efe067cbb0dc6e87ae95f01cc | ./runoff_WJB_int.1980_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 737e25dab2ecc33a68392210b3f9e0e1 | ./runoff_WJB_int.2016_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| b6c60498e818b11b0796ac8af9aed2cb | ./runoff_WJB_int.2016_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 9466828e368e9502c6e025e2541a71ac | ./runoff_WJB_int.2016_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 54e339e2a172723a8badfe90822d22f8 | ./runoff_WJB_int.2016_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| cad7f918e92e8803856ca167e7a1f278 | ./runoff_WJB_int.2017_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 712596d7b316d9828e910ce570cb9ab8 | ./runoff_WJB_int.2017_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| eecc63ac0323b1474b80b6c374897b33 | ./runoff_WJB_int.2017_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc |
| 5e275d0cd6e9b48691e41c4161424484 | ./runoff_WJB_int.2017_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc |

**** File list and md5sums

+ WARN :: May be stale
 
#+BEGIN_SRC bash :results verbatim :exports both
ROOT=${DATADIR}/RACMO/1km
cat ${ROOT}/md5sum.txt
#+END_SRC

#+RESULTS:
#+begin_example

a0ae77c8af7b77ea70bd26bab31bb929  runoff/runoff_WJB_int.1979_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7804a433973b109f6ae9e808a27f39f3  runoff/runoff_WJB_int.1979_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
93aed2f6fd4502112c7fa9c3953a120e  runoff/runoff_WJB_int.1979_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0cb42cbf4f06a42ee35eb043307c68ff  runoff/runoff_WJB_int.1979_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c5261cb3db35f3bce83fef0f0b59c905  runoff/runoff_WJB_int.1980_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
5e17a3553128fd3b3e84776e51d9163d  runoff/runoff_WJB_int.1980_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0e6369f5cfeef946dc764bdf2ee677db  runoff/runoff_WJB_int.1980_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f1bcad9efe067cbb0dc6e87ae95f01cc  runoff/runoff_WJB_int.1980_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f773f7da80b61716acdeeec07583122a  runoff/runoff_WJB_int.1981_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
48a684a825fe32eee3993bf5ff491dcb  runoff/runoff_WJB_int.1981_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f88af0d74a73578b3982fadf5ae8900c  runoff/runoff_WJB_int.1981_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
58185d880264866f21df4c6df9cc49fc  runoff/runoff_WJB_int.1981_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
83c963b63041ffe526ed938a69478443  runoff/runoff_WJB_int.1982_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ff498c50eb7dcdabe5169967839c5aa8  runoff/runoff_WJB_int.1982_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0a92a312c93e0dd0a5d5eb099880286e  runoff/runoff_WJB_int.1982_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c84c79bac5443edd6c93d76e0290e6a7  runoff/runoff_WJB_int.1982_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
66ba953db2ca83f235c8219ec8f34322  runoff/runoff_WJB_int.1983_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8f819bbcdee1f3bb8877e1139d12377b  runoff/runoff_WJB_int.1983_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
37518bb73b060ea029d9ba434b24fb4b  runoff/runoff_WJB_int.1983_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
e45289ec7b2207787e19db8f29ac4f7b  runoff/runoff_WJB_int.1983_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b02fbba36068489cd4ecf54944a61e32  runoff/runoff_WJB_int.1984_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c3d1f87ed9a29d43c562f2bd42c50c79  runoff/runoff_WJB_int.1984_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7a53d8933e2c183c1964f6837421526b  runoff/runoff_WJB_int.1984_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
38afc2e26f9c4a4b909d129f324e4317  runoff/runoff_WJB_int.1984_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
69d4ed97d6b980c9eec14c49882ee71c  runoff/runoff_WJB_int.1985_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
778bf3197601c8256b9ca7055efccdc7  runoff/runoff_WJB_int.1985_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
07a77e92bef31eb47b0f1df295b7ca98  runoff/runoff_WJB_int.1985_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0fe046479fb2c109b1523f3c2c2f3716  runoff/runoff_WJB_int.1985_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8164d304847c1eeba15c6faa4b422bd4  runoff/runoff_WJB_int.1986_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b6d92376c04e11213f32ad31fe08cf7f  runoff/runoff_WJB_int.1986_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
17f43ffdf972a49adc9eea74f7972ef9  runoff/runoff_WJB_int.1986_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
03b8799e0f1f379eb8370f85dbc1da09  runoff/runoff_WJB_int.1986_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
94f67bc56849b3fa7ced268047edf939  runoff/runoff_WJB_int.1987_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
31c19ec39b8ebc7cddc88a32d4fbcf27  runoff/runoff_WJB_int.1987_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f0b8ba4b574aa1f9d880444a5b543cd7  runoff/runoff_WJB_int.1987_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8f53d4cd5f09249525c6a4d319d1f216  runoff/runoff_WJB_int.1987_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
65b204cc66012ab918c6d82012c4ae5e  runoff/runoff_WJB_int.1988_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
2a171c2d7c2f5a5fbd3d24605af291a3  runoff/runoff_WJB_int.1988_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
30aaa51abacc6cc4e6e330238df2c91a  runoff/runoff_WJB_int.1988_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0e71c52c5b0cfa4b624845a69debdcd0  runoff/runoff_WJB_int.1988_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a4f057504dbcf811a06f09b6953d7b58  runoff/runoff_WJB_int.1989_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b5950961602f7ce484180d409f8cf205  runoff/runoff_WJB_int.1989_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
83d54cdb26ce02ae52e639ecd7532e3c  runoff/runoff_WJB_int.1989_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
39768229bee8e4dfdede909a0569c777  runoff/runoff_WJB_int.1989_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
4d64412a539d7cbb9d46ac5aae518493  runoff/runoff_WJB_int.1990_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a8ff365699d1be56b5d816372fb0b26f  runoff/runoff_WJB_int.1990_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
82d446aeb05385582a39592d9aa8e394  runoff/runoff_WJB_int.1990_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d01ba4ea623357af3e2aa7ae3162a853  runoff/runoff_WJB_int.1990_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
825508656af65b2de62b0a784c90d4b5  runoff/runoff_WJB_int.1991_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
3e14cc352d2851b8bc478bcd88da8cc2  runoff/runoff_WJB_int.1991_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
10d459ccba710203b97d223d52aadaa7  runoff/runoff_WJB_int.1991_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
2693099486bf82767ab948957bd8ec6b  runoff/runoff_WJB_int.1991_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7183d90eae5a57a3a434043de355e29e  runoff/runoff_WJB_int.1992_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
420f29baf3936a51d3db5d544003b63e  runoff/runoff_WJB_int.1992_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
052a92bca5f1fa20c70b62cb7005c2bf  runoff/runoff_WJB_int.1992_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b7fceb17504500dcf63f6ff20d8d0464  runoff/runoff_WJB_int.1992_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8ba484583c6e2afb921aca10c5024f53  runoff/runoff_WJB_int.1993_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
10e5b924a6969da740f407bed504c970  runoff/runoff_WJB_int.1993_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
2b5b1e409988ecd965b9556536b204ea  runoff/runoff_WJB_int.1993_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7045c21a1ed79e805c94fdcee93d23d8  runoff/runoff_WJB_int.1993_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
4be564721eed0cb9c12d8371f8742c15  runoff/runoff_WJB_int.1994_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
556d87c87055306f4792957bb7805b76  runoff/runoff_WJB_int.1994_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
3610605ecc5d105877eed61dd76990ac  runoff/runoff_WJB_int.1994_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
eb92cd59e2c6beaaa2878c5f11afc140  runoff/runoff_WJB_int.1994_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
df0b77439a323f69ab722d3bcf0ae4a0  runoff/runoff_WJB_int.1995_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c193035140f2088cf5808ad980ec9172  runoff/runoff_WJB_int.1995_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
fab312a1ec0527f98a96b6ab47987a9a  runoff/runoff_WJB_int.1995_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
e630769b51a88cafd115926913324d15  runoff/runoff_WJB_int.1995_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
aa42d4d01ebb32dc86cb8ef8b088db7c  runoff/runoff_WJB_int.1996_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
362ac765a90ea48bffc1ec1c2fbb4f44  runoff/runoff_WJB_int.1996_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
9fa41b4151670cbbf6025c5f8b2a38aa  runoff/runoff_WJB_int.1996_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
22aedaafa348c25ead29c3c2c5d76eae  runoff/runoff_WJB_int.1996_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8538e68c4c552705d53d5c4fb66e978b  runoff/runoff_WJB_int.1997_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8ef7eae118364cb90721ce6347fd11e3  runoff/runoff_WJB_int.1997_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f5b2730fedc88de186a0a5ee45a79483  runoff/runoff_WJB_int.1997_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
1784f926762cbb957445f920bd2d1385  runoff/runoff_WJB_int.1997_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ad01e27473c8d5b673dde55efd50e684  runoff/runoff_WJB_int.1998_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
311f34707e53a9d90fa2fbd2a915dcd9  runoff/runoff_WJB_int.1998_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d7e8240473ac18b293b90054355aac6c  runoff/runoff_WJB_int.1998_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7fc9fd52eed12868ff1e07af97d241b8  runoff/runoff_WJB_int.1998_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ef304deb8becb60f3f5633254b56010e  runoff/runoff_WJB_int.1999_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
77b1fecdd88114632b5eb6ef37a71ac5  runoff/runoff_WJB_int.1999_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
bf929e251d2ed9cfa022a11aa6e1b910  runoff/runoff_WJB_int.1999_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
71b7cd3f86532c6ef3504517963cd4b3  runoff/runoff_WJB_int.1999_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
bda12fbdc6713ece33f3737543da75a8  runoff/runoff_WJB_int.2000_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a3ab74093e90fff58cf60d9482b71d49  runoff/runoff_WJB_int.2000_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8a8cb3ebe5b2f140671b16caf6906cba  runoff/runoff_WJB_int.2000_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
89bbdd9e45c585c0b78d4448a30d9b05  runoff/runoff_WJB_int.2000_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
45cc758a9990942530198b75a85f7acf  runoff/runoff_WJB_int.2001_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7c1f455679102ef1137bdcf7e4152e7d  runoff/runoff_WJB_int.2001_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8550dede648a1007b6d0659842d4517f  runoff/runoff_WJB_int.2001_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c7a1fa79907621ec615507d88a842c4b  runoff/runoff_WJB_int.2001_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f1db77355af40c0b96ef02db54fd2aed  runoff/runoff_WJB_int.2002_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ef5c035d3e2247198d3c537be199fd2f  runoff/runoff_WJB_int.2002_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7e72a397ee9386d890c35e316ccfd136  runoff/runoff_WJB_int.2002_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c6740a6f197b9651edab5b8416fca703  runoff/runoff_WJB_int.2002_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8336a524818913510db33222c7dece22  runoff/runoff_WJB_int.2003_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c9ae671853bd8ae52d59e83a26ef73bc  runoff/runoff_WJB_int.2003_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
683b312bfb2cb9b864211f1f6097b1ac  runoff/runoff_WJB_int.2003_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
78ef16a1155b4c88861a40390c8af098  runoff/runoff_WJB_int.2003_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
6cc70b588759afba9f725e96a569eb26  runoff/runoff_WJB_int.2004_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
56239b08a3c9d74048f874ff82b83448  runoff/runoff_WJB_int.2004_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
71f749d3fc4fd5326dbabc1d210d7e31  runoff/runoff_WJB_int.2004_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8a6f9240a38a6b5dff9e2d8ba4d942c0  runoff/runoff_WJB_int.2004_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
3570ad23bf077f03eb5dc82143b80bb7  runoff/runoff_WJB_int.2005_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8c4596509588b09d3ca57ad0ef7d76a9  runoff/runoff_WJB_int.2005_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f045d39899f0c86967ab6716f301c06a  runoff/runoff_WJB_int.2005_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
224fd80b1f00e9c69c9b5893ec217c3f  runoff/runoff_WJB_int.2005_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
9db96b1d7ac4a544b7f551a19db44e6c  runoff/runoff_WJB_int.2006_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
2327960883a107115c701f1e386a11ac  runoff/runoff_WJB_int.2006_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
5424f11f212aba60ad374b2bd8727353  runoff/runoff_WJB_int.2006_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
44ea76e2d8fce715493cc9aad7e2d41f  runoff/runoff_WJB_int.2006_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
5cf15955c9751caa207125777770e562  runoff/runoff_WJB_int.2007_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d560e7214b13692e7d11559b1bff0820  runoff/runoff_WJB_int.2007_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
55c10880efcbbe57781a4d2f5ab732a8  runoff/runoff_WJB_int.2007_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
76028b9dc9f11c4f106c92d6d09a3b85  runoff/runoff_WJB_int.2007_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d30fad951b7a1a1df51c2a66a450aee6  runoff/runoff_WJB_int.2008_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c6067894272fbedec3f6956b7c489fa5  runoff/runoff_WJB_int.2008_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
6d32bfb2e32d12901322b2347389645c  runoff/runoff_WJB_int.2008_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
add6e11d3ce678a106afc380d7283cf9  runoff/runoff_WJB_int.2008_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
17d2b712c1c0ad87ccd16bdc46c54393  runoff/runoff_WJB_int.2009_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
3ff78be38eacf2f3b1c5669b0545dd7d  runoff/runoff_WJB_int.2009_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d1930c0bc9daa56df08fd31699812894  runoff/runoff_WJB_int.2009_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
1c9df25f65706f330defc63c5311399d  runoff/runoff_WJB_int.2009_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
99b6dc1db084f49900c59ae431c9921c  runoff/runoff_WJB_int.2010_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
0375e5f036dafebaa84350cce3814296  runoff/runoff_WJB_int.2010_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a4e11e07800f90909ce698c7544f9340  runoff/runoff_WJB_int.2010_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a0c3367f391dc70e9264aa17338560b7  runoff/runoff_WJB_int.2010_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ca6808476cf96c312cd4b8078b21804e  runoff/runoff_WJB_int.2011_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
7d745690d429be3dffe0a5a9fac4b284  runoff/runoff_WJB_int.2011_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
da822d42da7aa4401c63c4f7d26f1433  runoff/runoff_WJB_int.2011_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
32f8329739dff8504c728643299fbac0  runoff/runoff_WJB_int.2011_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
950348d26d3b4f52c09bb11805370c1e  runoff/runoff_WJB_int.2012_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
3c7d70369834b5d48613f57d3f95178b  runoff/runoff_WJB_int.2012_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
d080fe010bf237d5cd0222d3d4bf74b3  runoff/runoff_WJB_int.2012_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
fbd6b61d8706192ac9290a70773cfe75  runoff/runoff_WJB_int.2012_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
5fb12a7685ced7cf4792660b291db84e  runoff/runoff_WJB_int.2013_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
c2c048086baa809864c11c72742c1ff6  runoff/runoff_WJB_int.2013_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a80a52ee110752f485780b96acd5a6a9  runoff/runoff_WJB_int.2013_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
aa03f847d7cbf1c79c8153e70aeaf158  runoff/runoff_WJB_int.2013_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
98ab231d85c9436ce4d111ac962f1404  runoff/runoff_WJB_int.2014_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
8b64fc50a12f25117cbb12e70b75bf76  runoff/runoff_WJB_int.2014_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
f20660c1d31c466a7bcd5fe837c20372  runoff/runoff_WJB_int.2014_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ef66093fa70e85f11d0ac0fa30a21fe5  runoff/runoff_WJB_int.2014_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
a2e339331ad7d45a60c8cb6a3e18127e  runoff/runoff_WJB_int.2015_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
ba30155d2fdaae4f9eabd91c52c733d7  runoff/runoff_WJB_int.2015_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b3559db2e9c481edcd25543268fc140f  runoff/runoff_WJB_int.2015_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
e1e1f10799cfd797fc2883a6784d643b  runoff/runoff_WJB_int.2015_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
737e25dab2ecc33a68392210b3f9e0e1  runoff/runoff_WJB_int.2016_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
b6c60498e818b11b0796ac8af9aed2cb  runoff/runoff_WJB_int.2016_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
9466828e368e9502c6e025e2541a71ac  runoff/runoff_WJB_int.2016_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
54e339e2a172723a8badfe90822d22f8  runoff/runoff_WJB_int.2016_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
cad7f918e92e8803856ca167e7a1f278  runoff/runoff_WJB_int.2017_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
712596d7b316d9828e910ce570cb9ab8  runoff/runoff_WJB_int.2017_JAS.BN_RACMO2.3p2_FGRN055_1km.DD.nc
eecc63ac0323b1474b80b6c374897b33  runoff/runoff_WJB_int.2017_JFM.BN_RACMO2.3p2_FGRN055_1km.DD.nc
5e275d0cd6e9b48691e41c4161424484  runoff/runoff_WJB_int.2017_OND.BN_RACMO2.3p2_FGRN055_1km.DD.nc
#+end_example

**** ncdump

#+NAME: RACMO_QC_ncdump
#+BEGIN_SRC bash :results verbatim :exports both
ROOT=${DATADIR}/RACMO/1km/runoff
ncdump -chs ${ROOT}/runoff_WJB_int.1979_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD.nc
#+END_SRC

#+RESULTS: RACMO_QC_ncdump
#+begin_example

netcdf runoff_WJB_int.1979_AMJ.BN_RACMO2.3p2_FGRN055_1km.DD {
dimensions:
	time = 91 ;
	x = 1496 ;
	y = 2700 ;
variables:
	float time(time) ;
		time:units = "DAYS since 1979-04-01 00:00:00" ;
		time:long_name = "time" ;
		time:standard_name = "time" ;
	float x(x) ;
		x:units = "km" ;
		x:long_name = "x" ;
		x:standard_name = "x" ;
	float y(y) ;
		y:units = "km" ;
		y:long_name = "y" ;
		y:standard_name = "y" ;
	float LON(y, x) ;
		LON:units = "km" ;
		LON:long_name = "Easting" ;
		LON:standard_name = "Easting" ;
		LON:actual_range = 0.f, 0.f ;
		LON:missing_value = 0.f, -1.225254e+28f ;
	float LAT(y, x) ;
		LAT:units = "km" ;
		LAT:long_name = "Northing" ;
		LAT:standard_name = "Northing" ;
		LAT:actual_range = 0.f, 0.f ;
		LAT:missing_value = 0.f, -1.225254e+28f ;
	float runoffcorr(time, y, x) ;
		runoffcorr:units = "mm w.e. per day" ;
		runoffcorr:long_name = "Downscaled corrected snowmelt" ;
		runoffcorr:standard_name = "Downscaled_corrected_snowmelt" ;
		runoffcorr:actual_range = 0.f, 508.326f ;
		runoffcorr:missing_value = -1.e+30f ;

// global attributes:
		:title = "Daily runoff field (RACMO2.3p2)" ;
		:institution = "IMAU (Brice Noel)" ;
		:grid = "Map Projection:Polar Stereographic Ellipsoid - Map Reference Latitude: 90.0 - Map Reference Longitude: -39.0 - Map Second Reference Latitude: 71.0 - Map Eccentricity: 0.081819190843 ;wgs84 - Map Equatorial Radius: 6378137.0 ;wgs84 meters - Grid Map Origin Column: 160 - Grid Map Origin Row: -120 - Grid Map Units per Cell: 5000 - Grid Width: 301 - Grid Height: 561" ;
		:history = "libUN (2013.05.22) - Fri Mar 16 18:19:46 2018" ;
" ;
		:_Format = "classic" ;
}
#+end_example



*** Bamber 2018
#+NAME: bamber_2018
#+BEGIN_SRC bash :results verbatim :exports both
FILE=${DATADIR}/Bamber_2018/FWF17.v3_a.nc
md5sum ${FILE}
ncdump -chs ${FILE}
#+END_SRC

#+RESULTS: bamber_2018
#+begin_example

ed9d9bd0580e124146a5503832ced95e  /home/kdm/data/Bamber_2018/FWF17.v3_a.nc
netcdf FWF17.v3_a {
dimensions:
	Y = 785 ;
	X = 752 ;
	TIME = 708 ;
variables:
	double Y(Y) ;
		Y:_FillValue = NaN ;
		Y:units = "meters" ;
		Y:standard_name = "projection_y_coordinate" ;
		Y:point_spacing = "even" ;
		Y:axis = "Y" ;
		Y:_Storage = "contiguous" ;
		Y:_Endianness = "little" ;
	double X(X) ;
		X:_FillValue = NaN ;
		X:units = "meters" ;
		X:standard_name = "projection_x_coordinate" ;
		X:point_spacing = "even" ;
		X:axis = "X" ;
		X:_Storage = "contiguous" ;
		X:_Endianness = "little" ;
	int64 TIME(TIME) ;
		TIME:units = "days since 1958-01-01 00:00:00" ;
		TIME:calendar = "proleptic_gregorian" ;
		TIME:_Storage = "contiguous" ;
		TIME:_Endianness = "little" ;
	short runoff_tundra(TIME, Y, X) ;
		runoff_tundra:_FillValue = -9999s ;
		runoff_tundra:long_name = "Tundra runoff" ;
		runoff_tundra:units = "km3" ;
		runoff_tundra:grid_mapping = "polar_stereographic" ;
		runoff_tundra:description = "WARNING! This variable contains runoff routed from all land tundra (i.e. including CAA, Svalbard, Iceland), whereas the paper only shows tundra runoff from Greenland. To reproduce Greenland-only runoff you must mask the tundra variable with the LSMGr mask provided in order to set all tundra runoff originating outside the Greenland land mass to zero." ;
		runoff_tundra:scale_factor = 0.01 ;
		runoff_tundra:_Storage = "chunked" ;
		runoff_tundra:_ChunkSizes = 118, 131, 126 ;
		runoff_tundra:_DeflateLevel = 4 ;
		runoff_tundra:_Shuffle = "true" ;
		runoff_tundra:_Endianness = "little" ;
	double lon(Y, X) ;
		lon:_FillValue = NaN ;
		lon:grid_mapping = "polar_stereographic" ;
		lon:units = "degrees" ;
		lon:standard_name = "longitude" ;
		lon:_Storage = "contiguous" ;
		lon:_Endianness = "little" ;
	short runoff_ice(TIME, Y, X) ;
		runoff_ice:_FillValue = -9999s ;
		runoff_ice:long_name = "Ice sheet runoff" ;
		runoff_ice:units = "km3" ;
		runoff_ice:grid_mapping = "polar_stereographic" ;
		runoff_ice:scale_factor = 0.01 ;
		runoff_ice:_Storage = "chunked" ;
		runoff_ice:_ChunkSizes = 118, 131, 126 ;
		runoff_ice:_DeflateLevel = 4 ;
		runoff_ice:_Shuffle = "true" ;
		runoff_ice:_Endianness = "little" ;
	double lat(Y, X) ;
		lat:_FillValue = NaN ;
		lat:grid_mapping = "polar_stereographic" ;
		lat:units = "degrees" ;
		lat:standard_name = "latitude" ;
		lat:_Storage = "contiguous" ;
		lat:_Endianness = "little" ;
	byte polar_stereographic ;
		polar_stereographic:grid_mapping_name = "polar_stereographic" ;
		polar_stereographic:scale_factor_at_central_origin = 1. ;
		polar_stereographic:standard_parallel = 70. ;
		polar_stereographic:straight_vertical_longitude_from_pole = -45. ;
		polar_stereographic:false_easting = 0. ;
		polar_stereographic:false_northing = 0. ;
		polar_stereographic:latitude_of_projection_origin = 90. ;
	byte LSMGr(Y, X) ;
		LSMGr:_FillValue = -99b ;
		LSMGr:long_name = "Hole-filled Greenland land mass mask" ;
		LSMGr:units = "none" ;
		LSMGr:grid_mapping = "polar_stereographic" ;
		LSMGr:_Storage = "chunked" ;
		LSMGr:_ChunkSizes = 785, 752 ;
		LSMGr:_DeflateLevel = 4 ;
		LSMGr:_Shuffle = "true" ;
	byte ocean_basins(Y, X) ;
		ocean_basins:_FillValue = -99b ;
		ocean_basins:long_name = "ID number of oceanographic basin which each coastal pixel drains into." ;
		ocean_basins:units = "none" ;
		ocean_basins:grid_mapping = "polar_stereographic" ;
		ocean_basins:basins = ", 26:Labrador Sea, 27:Hudson Strait, 28:Davis Strait, 29:Baffin Bay, 30:Lincoln Sea, 32:Irish Sea and St. George\'s Channel, 33:Inner Seas off the West Coast of Scotland, 55:Gulf of Riga, 56:Baltic Sea, 57:Gulf of Finland, 58:Gulf of Bothnia, 59:White Sea, 76:North Atlantic Ocean, 77:Gulf of St. Lawrence, 80:Celtic Sea, 82:Hudson Bay, 83:The Northwestern Passages, 84:Arctic Ocean, 86:Barentsz Sea, 87:Greenland Sea, 88:North Sea, 96:Kattegat, 98:Skagerrak, 99:Norwegian Sea" ;
		ocean_basins:history = "Basins are as defined by \"Limits of Oceans & Seas, Special Publication No. 23\" published by the IHO in 1953. The dataset was composed by the Flanders Marine Data and Information Centre and downloaded from www.marineregions.org on 6 February 2017. Coastal runoff pixels were allocated an ocean basin to run off into using fwf/allocate_coast_to_basin.py." ;
		ocean_basins:_Storage = "chunked" ;
		ocean_basins:_ChunkSizes = 785, 752 ;
		ocean_basins:_DeflateLevel = 4 ;
		ocean_basins:_Shuffle = "true" ;
	short solid_ice(TIME, Y, X) ;
		solid_ice:_FillValue = -9999s ;
		solid_ice:long_name = "Solid ice discharge" ;
		solid_ice:units = "km3" ;
		solid_ice:grid_mapping = "polar_stereographic" ;
		solid_ice:description = "the monthly discharge data are mean annual values divided by 12." ;
		solid_ice:scale_factor = 0.001 ;
		solid_ice:_Storage = "chunked" ;
		solid_ice:_ChunkSizes = 118, 131, 126 ;
		solid_ice:_DeflateLevel = 4 ;
		solid_ice:_Shuffle = "true" ;
		solid_ice:_Endianness = "little" ;

// global attributes:
		:Conventions = "CF-1.4" ;
		:institution = "University of Bristol (Andrew Tedstone)" ;
		:title = "Monthly freshwater fluxes to the ocean across the Arctic, 1958-2016" ;
		:nx = 752. ;
		:ny = 785. ;
		:xmin = -1777980. ;
		:ymax = -67308. ;
		:spacing = 5000. ;
		:description = "This is the dataset that underlies the paper \"Bamber, J., A. Tedstone, M. King, I. Howat, E. Enderlin, M. van den Broeke and B. Noel (2018) Land ice freshwater budget of the Arctic and North Atlantic Oceans. Part I: Data, methods and results. Journal of Geophysical Research: Oceans.\"" ;
		:_NCProperties = "version=1|netcdflibversion=4.4.1.1|hdf5libversion=1.10.1" ;
		:_SuperblockVersion = 0 ;
		:_IsNetcdf4 = 1 ;
		:_Format = "netCDF-4" ;
}
#+end_example


*** van As 2018
#+NAME: van_As_2018_provenance
#+BEGIN_SRC bash :results verbatim :exports both
dir=${DATADIR}/van_As_2018
md5sum ${dir}/*
echo ""
head ${dir}/Watson_discharge_day_v03.txt 
echo ""
tail ${dir}/Watson_discharge_day_v03.txt
#+END_SRC

#+RESULTS: van_As_2018_provenance
#+begin_example

d0cf2ba4bf7339cfa6ee3f9da74eb894  /home/kdm/data/van_As_2018/Watson_discharge_day_v03.txt
f25d973f65f778d3d935b779774deefe  /home/kdm/data/van_As_2018/Watson_discharge_hour_v03.txt
21cc48d77e497413be0b37dca18263bb  /home/kdm/data/van_As_2018/Watson_discharge.pdf
2ef04fb38fff2ba5b975aa45f516354b  /home/kdm/data/van_As_2018/Watson_discharge_year.txt

Year MonthOfYear DayOfMonth DayOfYear DayOfCentury WaterFluxDiversOnly(m3/s) Uncertainty(m3/s) WaterFluxDivers&Temperature(m3/s) Uncertainty(m3/s) WaterFluxCumulative(km3) Uncertainty(km3)
 2006    4   10  100 2292 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   11  101 2293 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   12  102 2294 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   13  103 2295 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   14  104 2296 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   15  105 2297 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   16  106 2298 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   17  107 2299 -999.00 -999.00    0.00    0.00    0.00    0.00
 2006    4   18  108 2300 -999.00 -999.00    0.00    0.00    0.00    0.00

2017   10   18  291 6501 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   19  292 6502 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   20  293 6503 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   21  294 6504 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   22  295 6505 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   23  296 6506 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   24  297 6507 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   25  298 6508 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   26  299 6509 -999.00 -999.00    0.00    0.00    4.28    0.65
 2017   10   27  300 6510 -999.00 -999.00    0.00    0.00    4.28    0.65
#+end_example

** Import Data
:PROPERTIES:
:header-args:bash+: :tangle import.sh :eval no
:END:

#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC

*** Masks
**** GIMP Ocean Mask
#+NAME: GIMP_0714
#+BEGIN_SRC bash :results verbatim
g.mapset -c GIMP_0714
r.in.gdal -o input=${DATADIR}/GIMP/0714/GimpOceanMask_90m_v1.1.tif output=mask_ocean_lakes
# ocean mask has some cut-off oceans a.k.a lakes. See for example near -274731,-2747470.
g.region raster=mask_ocean_lakes

# Let's fill the lakes and treat as land.
# Easier than connecting all the lakes to the nearest ocean cell.
r.null map=mask_ocean_lakes setnull=0 # only operate on ocean cells
r.clump input=mask_ocean_lakes output=clumps
main_clump=$(r.stats -c -n clumps sort=desc | head -n1 | cut -d" " -f1)
r.mapcalc "mask_ocean = if(clumps == ${main_clump}, 1, null())"
r.null mask_ocean null=0
#+END_SRC

**** Citterio 2013 Ice Mask
#+NAME: citterio_2013
#+BEGIN_SRC bash :results verbatim
g.mapset -c Citterio_2013
# v.import input=${DATADIR}/Citterio_2013/PROMICE_250_2015-04-10 output=mask
v.in.ogr input=${DATADIR}/Citterio_2013/PROMICE_250_2015-04-10_3413.gpkg output=mask

g.region raster=mask_ocean@GIMP_0714
v.to.rast input=mask output=mask_ice_holes use=val val=1

# Everything should route to the coast, this means we need to fill in
# all the nunatuks so that there are no interior drainage basns.
r.mapcalc "not_ice = if(isnull(mask_ice_holes), 1, null())"
r.clump input=not_ice output=clumps
main_clump=$(r.stats -c -n clumps sort=desc | head -n1 | cut -d" " -f1) # ocean
r.mapcalc "mask_ice = mask_ice_holes ||| if(clumps != ${main_clump})"
r.null mask_ice null=0
#+END_SRC

*** ArcticDEM
#+BEGIN_SRC bash :results verbatim
log_info "Importing ArcticDEM"
g.mapset -c ArcticDEM

r.external source=${DATADIR}/ArcticDEM/arcticdem_mosaic_100m_v3.0.tif output=arctic_raw # all arctic

g.region raster=mask_ocean@GIMP_0714 align=arctic_raw

g.region save=ArcticDEM
g.mapset PERMANENT
g.region region=ArcticDEM@ArcticDEM
g.region -sp # default location
g.mapset ArcticDEM

r.mapcalc "mask_land = if((mask_ice@Citterio_2013 == 0) && (mask_ocean@GIMP_0714 == 0), 1, 0)"

# set up mask: (o)cean=1 (l)and=2 (i)ce=3
r.mapcalc "mask_o_l_i_4 = (mask_ocean@GIMP_0714 + mask_land*2 + mask_ice@Citterio_2013*3)"
r.mapcalc "mask_o_l_i = if(mask_o_l_i_4 == 4, 1, mask_o_l_i_4)" # cleanup some multi-flagged as ocean.
r.mapcalc "z_s_ocean = arctic_raw" # subset and move from external to internal
r.null map=z_s_ocean null=0
r.mapcalc "z_s = if(mask_o_l_i == 1, null(), z_s_ocean)"

#+END_SRC


*** BedMachine v3
:PROPERTIES:
:CUSTOM_ID: import_BM3
:END:
#+BEGIN_SRC bash :results verbatim
log_info "Importing BedMachine"
g.mapset -c BedMachine

ROOT=${DATADIR}/Morlighem_2017
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:bed output=z_b
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:surface output=z_s
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:thickness output=thickness
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:errbed output=errbed
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:geoid output=geoid
r.external source=netCDF:${ROOT}/BedMachineGreenland-2017-09-20.nc:source output=source
g.region raster=z_b -pa
#+END_SRC

*** TODO GEM
*** INPROGRESS WMS
 
#+BEGIN_SRC bash :results verbatim
grass -c ./G/WMS
g.region rows=50 cols=50
export GRASS_OVERWRITE=1

# r.in.wms --verbose output=img format=png layers=s2cloudless-2018_3857 srs=3857 url="https://tiles.maps.eox.at/wms?service=wms&request=getcapabilities"

# r.in.wms url=http://irs.gis-lab.info layers=landsat output=img format=png

r.in.wms output=akl_srtm url="http://onearth.jpl.nasa.gov/wms.cgi" -c layers=worldwind_dem format=geotiff style=short_int maxcols=1600 maxrows=1600

d.mon start=wx0
d.erase
d.rast img
#+END_SRC

*** NSIDC 0713 Basemap
#+BEGIN_SRC bash :results verbatim
g.mapset -c NSIDC_0713
g.region -d
r.external -o input=${DATADIR}/GIMP/0713/RGB.vrt output=rgb
#+END_SRC

*** Other
#+BEGIN_SRC bash :results verbatim
<<xy_permanent>>
#+END_SRC
* Quality control                                       :noexport:
:PROPERTIES:
:header-args: :tangle no
:header-args:bash+: :tangle no :eval no
:header-args:jupyter-python+: :tangle no
:END:
** Streams, Outlets, and Basins
*** Compare streams and outlets with Google Earth    :noexport:QC:

Data are too large for Google Earth (app), but using Google Earth tiles in QGIS works fine.

See [[./freshwater.qgz]] and add one or more of the following to QGIS Tile Server (XYZ)

Google Maps: https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}
Google Satellite: http://www.google.cn/maps/vt?lyrs=s@189&gl=cn&x={x}&y={y}&z={z}
Google Satellite Hybrid: https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}
Google Terrain: https://mt1.google.com/vt/lyrs=t&x={x}&y={y}&z={z}
Bing Aerial: http://ecn.t3.tiles.virtualearth.net/tiles/a{q}.jpeg?g=1

*** Find lakes and compare w/ Google Earth           :noexport:QC:

#+BEGIN_SRC bash :results verbatim :eval no
g.mapset -c lakes
r.fill.dir input=head@land_surf output=filled direction=dir areas=problems format=grass
r.mapcalc "lakes = if(filled - head@land_surf > 0.0, 1, null() )"
r.to.vect input=lakes output=lakes type=area
#+END_SRC

Then load in QGIS

** Outputs
*** Check CF Compliance
#+NAME: cf_check
#+BEGIN_SRC bash :results verbatim :eval no-export :exports both
cfchecks ./freshwater/runoff/margin/runoff_ice_MAR_2000.nc
#+END_SRC

#+RESULTS: cf_check
#+begin_example
CHECKING NetCDF FILE: ./freshwater/runoff/margin/runoff_ice_MAR_2000.nc
=====================
Using CF Checker Version 4.0.0
Checking against CF Version CF-1.7
Using Standard Name Table Version 71 (2020-02-04T12:00Z)
Using Area Type Table Version 9 (07 August 2018)
Using Standardized Region Name Table Version 4 (18 December 2018)


------------------
Checking variable: runoff
------------------

------------------
Checking variable: lat
------------------

------------------
Checking variable: lon
------------------

------------------
Checking variable: alt
------------------

------------------
Checking variable: coast_id
------------------
INFO: (3.1): No units attribute set.  Please consider adding a units attribute for completeness.

------------------
Checking variable: coast_lat
------------------
INFO: attribute axis is being used in a non-standard way

------------------
Checking variable: coast_lon
------------------
INFO: attribute axis is being used in a non-standard way

------------------
Checking variable: coast_alt
------------------
INFO: attribute positive is being used in a non-standard way
INFO: attribute axis is being used in a non-standard way

------------------
Checking variable: station
------------------
WARN: (3.1): units attribute should be present

------------------
Checking variable: time
------------------

ERRORS detected: 0
WARNINGS given: 1
INFORMATION messages: 5
#+end_example

*** NetCDF header
#+NAME: netcdf-header-one-file
#+BEGIN_SRC bash :results verbatim :eval no-export :exports both
ncdump -chs ./freshwater/runoff/margin/runoff_ice_MAR_2000.nc
#+END_SRC

#+RESULTS: netcdf-header-one-file
#+begin_example
netcdf runoff_ice_MAR_2000 {
dimensions:
	time = UNLIMITED ; // (366 currently)
	station = 18902 ;
variables:
	double runoff(station, time) ;
		runoff:_FillValue = NaN ;
		runoff:long_name = "MAR runoff" ;
		runoff:standard_name = "water_volume_transport_in_river_channel" ;
		runoff:units = "m3 s-1" ;
		runoff:coordinates = "lat lon alt station" ;
		runoff:_Storage = "chunked" ;
		runoff:_ChunkSizes = 18902, 1 ;
		runoff:_Endianness = "little" ;
	float lat(station) ;
		lat:_FillValue = NaNf ;
		lat:long_name = "latitude" ;
		lat:standard_name = "latitude" ;
		lat:units = "degrees_north" ;
		lat:axis = "Y" ;
		lat:_Storage = "contiguous" ;
		lat:_Endianness = "little" ;
	float lon(station) ;
		lon:_FillValue = NaNf ;
		lon:long_name = "longitude" ;
		lon:standard_name = "longitude" ;
		lon:units = "degrees_east" ;
		lon:axis = "X" ;
		lon:_Storage = "contiguous" ;
		lon:_Endianness = "little" ;
	float alt(station) ;
		alt:_FillValue = NaNf ;
		alt:long_name = "height_above_mean_sea_level" ;
		alt:standard_name = "altitude" ;
		alt:units = "m" ;
		alt:positive = "up" ;
		alt:axis = "Z" ;
		alt:_Storage = "contiguous" ;
		alt:_Endianness = "little" ;
	uint coast_id(station) ;
		coast_id:long_name = "ID of coastal outlet" ;
		coast_id:_Storage = "contiguous" ;
		coast_id:_Endianness = "little" ;
	float coast_lat(station) ;
		coast_lat:_FillValue = NaNf ;
		coast_lat:long_name = "latitude" ;
		coast_lat:standard_name = "latitude" ;
		coast_lat:units = "degrees_north" ;
		coast_lat:axis = "Y" ;
		coast_lat:_Storage = "contiguous" ;
		coast_lat:_Endianness = "little" ;
	float coast_lon(station) ;
		coast_lon:_FillValue = NaNf ;
		coast_lon:long_name = "longitude" ;
		coast_lon:standard_name = "longitude" ;
		coast_lon:units = "degrees_east" ;
		coast_lon:axis = "X" ;
		coast_lon:_Storage = "contiguous" ;
		coast_lon:_Endianness = "little" ;
	float coast_alt(station) ;
		coast_alt:_FillValue = NaNf ;
		coast_alt:long_name = "height_above_mean_sea_level" ;
		coast_alt:standard_name = "altitude" ;
		coast_alt:units = "m" ;
		coast_alt:positive = "up" ;
		coast_alt:axis = "Z" ;
		coast_alt:_Storage = "contiguous" ;
		coast_alt:_Endianness = "little" ;
	uint64 station(station) ;
		station:long_name = "outlet id" ;
		station:cf_role = "timeseries_id" ;
		station:_Storage = "contiguous" ;
		station:_Endianness = "little" ;
	int64 time(time) ;
		time:long_name = "time of measurement" ;
		time:standard_name = "time" ;
		time:axis = "T" ;
		time:units = "days since 2000-01-01 00:00:00" ;
		time:calendar = "proleptic_gregorian" ;
		time:_Storage = "chunked" ;
		time:_ChunkSizes = 366 ;
		time:_Endianness = "little" ;

// global attributes:
		:featureType = "timeSeries" ;
		:title = "Greenland runoff" ;
		:summary = "Greenland RCM runoff at catchment outlets" ;
		:keywords = "Hydrology; Greenland; Runoff; Freshwater" ;
		:Conventions = "CF-1.7" ;
		:source = "git commit: 2feba9a" ;
		:date_created = "2019-12-30" ;
		:creator_name = "Ken Mankoff" ;
		:creator_email = "kdm@geus.dk" ;
		:creator_url = "http://kenmankoff.com" ;
		:institution = "GEUS" ;
		:references = "10.22008/promice/data/freshwater_runoff/v01" ;
		:product_version = 1. ;
		:_NCProperties = "version=1|netcdflibversion=4.4.1.1|hdf5libversion=1.10.1" ;
		:_SuperblockVersion = 0 ;
		:_IsNetcdf4 = 1 ;
		:_Format = "netCDF-4" ;
}
#+end_example

** Raw v. processed for ice & land

Build a data frame with 
+ The final product
+ The raw RCM inputs
+ The raw RCM inputs scaled by the area scale (EPSG:3413 error)
+ Bamber 2018 comparison

Because of memory errors, compute annual sums outside Python

#+BEGIN_SRC bash :results verbatim
mkdir -p ./tmp/QC
parallel --progress "[[ -e ./tmp/QC/{/} ]] || cdo --verbose yearsum ${DATADIR}/MAR/3.9/{/} ./tmp/QC/{/}" \
	 ::: $(ls ${DATADIR}/MAR/3.9/*.nc)
#+END_SRC

#+NAME: QC_df
#+BEGIN_SRC jupyter-python :session QC :exports results :results raw drawer

<<load_this_data>>

df_QC = df.copy(deep=True)\
          .resample('A')\
          .sum()

ds = xr.open_mfdataset("./tmp/QC/MARv3.9-daily-ERA-Interim-????.nc", combine='by_coords')\
       .resample({'time':'A'}).sum()

ds0 = ds.isel(time=0)
ice_mask = (ds0['MSK_GIMP'] == 2)

# convert from mm wEq / grid cell to km^3
RCM_to_km3 = 1E-3 * 1000 * 1000 / 1E9
#   mm -> m  * grid cell  / km^3

df_tmp = (ds['RUcorr'] * RCM_to_km3 * ice_mask)\
    .sum(dim=['x','y'])\
    .to_dataframe(name="MAR ice raw")
df_QC = df_QC.merge(df_tmp, left_index=True, right_index=True)

# bit of work to remove Canada
land_mask = (ds0['MSK_GIMP'] == 1) & (ds0['SRF_GIMP'] > 0) #  & (ds0['SRF_GIMP'] < 3E3)

df_tmp = (ds['RU2'] * RCM_to_km3 * land_mask)\
    .sum(dim=['x','y'])\
    .to_dataframe(name="MAR land raw")
df_QC = df_QC.merge(df_tmp, left_index=True, right_index=True)

df_QC
#+END_SRC

#+RESULTS: QC_df
| time                | MAR ice | MAR land | RACMO ice | MAR ice raw | MAR land raw |
|---------------------+---------+----------+-----------+-------------+--------------|
| 1979-12-31 00:00:00 | 239.215 |  120.519 |   261.792 |     234.315 |      133.467 |
| 1980-12-31 00:00:00 | 321.245 |  116.775 |   347.483 |     315.372 |       129.57 |
| 1981-12-31 00:00:00 | 343.306 |  118.648 |   391.154 |     336.839 |      130.783 |
| 1982-12-31 00:00:00 | 271.162 |  102.364 |   312.212 |     266.092 |       112.51 |
| 1983-12-31 00:00:00 | 203.528 |  136.643 |   216.894 |     200.999 |       149.17 |
| 1984-12-31 00:00:00 |  345.82 |  136.167 |    335.31 |     338.892 |      150.707 |
| 1985-12-31 00:00:00 | 353.941 |  111.216 |   379.942 |     347.483 |      124.221 |
| 1986-12-31 00:00:00 | 244.377 |  113.092 |   258.204 |     241.864 |       124.97 |
| 1987-12-31 00:00:00 | 370.967 |  134.777 |   388.581 |     365.048 |      150.908 |
| 1988-12-31 00:00:00 | 362.103 |  123.501 |   363.659 |     354.354 |      138.159 |
| 1989-12-31 00:00:00 | 354.811 |  112.768 |   367.989 |     348.322 |      125.331 |
| 1990-12-31 00:00:00 | 385.618 |  131.495 |   428.978 |     375.815 |       146.14 |
| 1991-12-31 00:00:00 | 350.413 |  126.976 |   362.512 |     344.487 |      141.364 |
| 1992-12-31 00:00:00 | 136.595 |  112.908 |   191.468 |     135.199 |      122.912 |
| 1993-12-31 00:00:00 | 335.916 |  130.219 |   395.871 |     330.267 |      143.472 |
| 1994-12-31 00:00:00 | 281.519 |  116.345 |   322.976 |      277.18 |      128.633 |
| 1995-12-31 00:00:00 | 382.108 |  118.946 |   432.718 |      375.14 |      131.335 |
| 1996-12-31 00:00:00 | 262.361 |  134.357 |    294.48 |     257.455 |      148.236 |
| 1997-12-31 00:00:00 | 327.286 |  136.939 |   350.949 |     321.416 |      150.742 |
| 1998-12-31 00:00:00 | 463.182 |  135.165 |   487.184 |     452.808 |      149.619 |
| 1999-12-31 00:00:00 |  335.31 |  126.997 |   362.449 |     329.537 |      139.776 |
| 2000-12-31 00:00:00 | 369.192 |  131.905 |   386.502 |     363.435 |      144.696 |
| 2001-12-31 00:00:00 | 369.755 |  130.326 |   405.228 |     361.704 |      143.245 |
| 2002-12-31 00:00:00 | 440.602 |  146.097 |   484.532 |     428.395 |       160.67 |
| 2003-12-31 00:00:00 | 574.072 |  133.605 |   561.886 |     560.765 |      149.788 |
| 2004-12-31 00:00:00 | 451.576 |  144.358 |   470.637 |     442.234 |      158.447 |
| 2005-12-31 00:00:00 | 517.627 |  160.801 |   507.213 |     503.434 |      176.248 |
| 2006-12-31 00:00:00 | 415.921 |  141.183 |   420.856 |     408.156 |      152.736 |
| 2007-12-31 00:00:00 |  573.23 |  131.716 |   546.749 |     562.305 |      144.646 |
| 2008-12-31 00:00:00 | 561.339 |  158.919 |   547.155 |     544.517 |      172.462 |
| 2009-12-31 00:00:00 | 396.559 |  120.676 |    411.83 |      384.55 |      134.462 |
| 2010-12-31 00:00:00 | 668.999 |   128.12 |   666.347 |     657.674 |      144.246 |
| 2011-12-31 00:00:00 |  550.38 |  112.614 |   540.873 |     536.108 |      124.458 |
| 2012-12-31 00:00:00 | 785.476 |  142.703 |   693.246 |      769.56 |          159 |
| 2013-12-31 00:00:00 |  367.48 |  113.598 |   387.134 |     357.901 |       125.88 |
| 2014-12-31 00:00:00 | 499.922 |   127.11 |   502.671 |     488.504 |      141.742 |
| 2015-12-31 00:00:00 | 430.788 |  137.286 |   438.269 |     416.333 |      152.057 |
| 2016-12-31 00:00:00 | 613.969 |  124.751 |   582.834 |     599.061 |      137.929 |
| 2017-12-31 00:00:00 | 437.565 |  152.327 |   427.326 |       427.8 |      167.327 |

*** MAR change due to area

#+NAME: QC_change_from_area
#+BEGIN_SRC jupyter-python :session QC :exports results :results raw drawer

area = xr.open_dataset("./tmp/err_2D_area_MAR.nc")['Band1'].values

ds = xr.open_mfdataset("./tmp/QC/MARv3.9-daily-ERA-Interim-????.nc", combine='by_coords')\
       .resample({'time':'A'}).sum()

df_tmp = (ds['RUcorr'] * RCM_to_km3 * area * ice_mask)\
    .sum(dim=['x','y'])\
    .to_dataframe(name="MAR ice raw area")
df_QC = df_QC.merge(df_tmp, left_index=True, right_index=True)

df_tmp = (ds['RU2'] * RCM_to_km3 * area * land_mask)\
    .sum(dim=['x','y'])\
    .to_dataframe(name="MAR land raw area")
df_QC = df_QC.merge(df_tmp, left_index=True, right_index=True)

df_QC
#+END_SRC

#+RESULTS: QC_change_from_area
| time                | MAR ice | MAR land | RACMO ice | MAR ice raw | MAR land raw | MAR ice raw area | MAR land raw area |
|---------------------+---------+----------+-----------+-------------+--------------+------------------+-------------------|
| 1979-12-31 00:00:00 | 239.215 |  120.519 |   261.792 |     234.315 |      133.467 |          231.859 |           131.632 |
| 1980-12-31 00:00:00 | 321.245 |  116.775 |   347.483 |     315.372 |       129.57 |          311.321 |           128.213 |
| 1981-12-31 00:00:00 | 343.306 |  118.648 |   391.154 |     336.839 |      130.783 |          332.662 |           128.986 |
| 1982-12-31 00:00:00 | 271.162 |  102.364 |   312.212 |     266.092 |       112.51 |          263.048 |           111.152 |
| 1983-12-31 00:00:00 | 203.528 |  136.643 |   216.894 |     200.999 |       149.17 |          197.593 |           146.616 |
| 1984-12-31 00:00:00 |  345.82 |  136.167 |    335.31 |     338.892 |      150.707 |          334.545 |           148.958 |
| 1985-12-31 00:00:00 | 353.941 |  111.216 |   379.942 |     347.483 |      124.221 |          343.754 |            122.55 |
| 1986-12-31 00:00:00 | 244.377 |  113.092 |   258.204 |     241.864 |       124.97 |          237.208 |            122.77 |
| 1987-12-31 00:00:00 | 370.967 |  134.777 |   388.581 |     365.048 |      150.908 |          359.968 |           148.668 |
| 1988-12-31 00:00:00 | 362.103 |  123.501 |   363.659 |     354.354 |      138.159 |          350.879 |           136.027 |
| 1989-12-31 00:00:00 | 354.811 |  112.768 |   367.989 |     348.322 |      125.331 |          343.122 |           123.379 |
| 1990-12-31 00:00:00 | 385.618 |  131.495 |   428.978 |     375.815 |       146.14 |          372.778 |           144.019 |
| 1991-12-31 00:00:00 | 350.413 |  126.976 |   362.512 |     344.487 |      141.364 |          340.165 |           139.157 |
| 1992-12-31 00:00:00 | 136.595 |  112.908 |   191.468 |     135.199 |      122.912 |          132.452 |           121.005 |
| 1993-12-31 00:00:00 | 335.916 |  130.219 |   395.871 |     330.267 |      143.472 |          326.163 |           141.873 |
| 1994-12-31 00:00:00 | 281.519 |  116.345 |   322.976 |      277.18 |      128.633 |          273.686 |           126.732 |
| 1995-12-31 00:00:00 | 382.108 |  118.946 |   432.718 |      375.14 |      131.335 |           370.67 |           129.487 |
| 1996-12-31 00:00:00 | 262.361 |  134.357 |    294.48 |     257.455 |      148.236 |           253.47 |           145.829 |
| 1997-12-31 00:00:00 | 327.286 |  136.939 |   350.949 |     321.416 |      150.742 |          316.788 |           148.571 |
| 1998-12-31 00:00:00 | 463.182 |  135.165 |   487.184 |     452.808 |      149.619 |           448.53 |           148.424 |
| 1999-12-31 00:00:00 |  335.31 |  126.997 |   362.449 |     329.537 |      139.776 |           325.32 |           137.975 |
| 2000-12-31 00:00:00 | 369.192 |  131.905 |   386.502 |     363.435 |      144.696 |          358.235 |           142.958 |
| 2001-12-31 00:00:00 | 369.755 |  130.326 |   405.228 |     361.704 |      143.245 |          358.567 |           140.937 |
| 2002-12-31 00:00:00 | 440.602 |  146.097 |   484.532 |     428.395 |       160.67 |          425.467 |           158.371 |
| 2003-12-31 00:00:00 | 574.072 |  133.605 |   561.886 |     560.765 |      149.788 |           556.65 |           147.297 |
| 2004-12-31 00:00:00 | 451.576 |  144.358 |   470.637 |     442.234 |      158.447 |           437.22 |           155.982 |
| 2005-12-31 00:00:00 | 517.627 |  160.801 |   507.213 |     503.434 |      176.248 |           500.34 |           173.154 |
| 2006-12-31 00:00:00 | 415.921 |  141.183 |   420.856 |     408.156 |      152.736 |          403.293 |            151.18 |
| 2007-12-31 00:00:00 |  573.23 |  131.716 |   546.749 |     562.305 |      144.646 |          556.078 |           142.895 |
| 2008-12-31 00:00:00 | 561.339 |  158.919 |   547.155 |     544.517 |      172.462 |          542.657 |            170.73 |
| 2009-12-31 00:00:00 | 396.559 |  120.676 |    411.83 |      384.55 |      134.462 |          383.131 |           132.726 |
| 2010-12-31 00:00:00 | 668.999 |   128.12 |   666.347 |     657.674 |      144.246 |          648.941 |           142.206 |
| 2011-12-31 00:00:00 |  550.38 |  112.614 |   540.873 |     536.108 |      124.458 |          534.031 |            123.41 |
| 2012-12-31 00:00:00 | 785.476 |  142.703 |   693.246 |      769.56 |          159 |          763.551 |           156.815 |
| 2013-12-31 00:00:00 |  367.48 |  113.598 |   387.134 |     357.901 |       125.88 |          355.559 |           124.503 |
| 2014-12-31 00:00:00 | 499.922 |   127.11 |   502.671 |     488.504 |      141.742 |          484.161 |           140.374 |
| 2015-12-31 00:00:00 | 430.788 |  137.286 |   438.269 |     416.333 |      152.057 |           416.52 |           150.858 |
| 2016-12-31 00:00:00 | 613.969 |  124.751 |   582.834 |     599.061 |      137.929 |          594.937 |           136.767 |
| 2017-12-31 00:00:00 | 437.565 |  152.327 |   427.326 |       427.8 |      167.327 |          423.755 |           165.535 |

*** Bamber 2018

#+NAME: QC_B2018
#+BEGIN_SRC jupyter-python :session QC :exports results :results raw drawer

<<B2018>>
df_b2018
#+END_SRC

#+RESULTS: QC_B2018
|                     | B2018 ice | B2018 land | MAR ice | MAR land | RACMO ice |
|---------------------+-----------+------------+---------+----------+-----------|
| 1979-12-31 00:00:00 |    282.78 |      82.25 | 239.215 |  120.519 |   261.792 |
| 1980-12-31 00:00:00 |    375.86 |       79.8 | 321.245 |  116.775 |   347.483 |
| 1981-12-31 00:00:00 |    398.82 |      79.62 | 343.306 |  118.648 |   391.154 |
| 1982-12-31 00:00:00 |    340.33 |      73.14 | 271.162 |  102.364 |   312.212 |
| 1983-12-31 00:00:00 |    217.46 |     109.78 | 203.528 |  136.643 |   216.894 |
| 1984-12-31 00:00:00 |    340.84 |      98.73 |  345.82 |  136.167 |    335.31 |
| 1985-12-31 00:00:00 |    409.56 |      76.01 | 353.941 |  111.216 |   379.942 |
| 1986-12-31 00:00:00 |    261.07 |      78.59 | 244.377 |  113.092 |   258.204 |
| 1987-12-31 00:00:00 |    398.38 |     104.64 | 370.967 |  134.777 |   388.581 |
| 1988-12-31 00:00:00 |    379.52 |      83.84 | 362.103 |  123.501 |   363.659 |
| 1989-12-31 00:00:00 |    371.58 |      74.93 | 354.811 |  112.768 |   367.989 |
| 1990-12-31 00:00:00 |    437.38 |      85.32 | 385.618 |  131.495 |   428.978 |
| 1991-12-31 00:00:00 |    375.62 |       90.5 | 350.413 |  126.976 |   362.512 |
| 1992-12-31 00:00:00 |    191.35 |      86.46 | 136.595 |  112.908 |   191.468 |
| 1993-12-31 00:00:00 |    413.17 |      98.09 | 335.916 |  130.219 |   395.871 |
| 1994-12-31 00:00:00 |    324.02 |      86.83 | 281.519 |  116.345 |   322.976 |
| 1995-12-31 00:00:00 |    457.09 |      73.24 | 382.108 |  118.946 |   432.718 |
| 1996-12-31 00:00:00 |    297.81 |     102.56 | 262.361 |  134.357 |    294.48 |
| 1997-12-31 00:00:00 |    353.93 |      95.32 | 327.286 |  136.939 |   350.949 |
| 1998-12-31 00:00:00 |    498.08 |      93.76 | 463.182 |  135.165 |   487.184 |
| 1999-12-31 00:00:00 |    369.42 |         85 |  335.31 |  126.997 |   362.449 |
| 2000-12-31 00:00:00 |    368.38 |      93.03 | 369.192 |  131.905 |   386.502 |
| 2001-12-31 00:00:00 |    409.83 |      85.73 | 369.755 |  130.326 |   405.228 |
| 2002-12-31 00:00:00 |    490.93 |      88.26 | 440.602 |  146.097 |   484.532 |
| 2003-12-31 00:00:00 |    588.16 |      89.53 | 574.072 |  133.605 |   561.886 |
| 2004-12-31 00:00:00 |     468.3 |      90.22 | 451.576 |  144.358 |   470.637 |
| 2005-12-31 00:00:00 |    519.26 |      112.4 | 517.627 |  160.801 |   507.213 |
| 2006-12-31 00:00:00 |    407.76 |      90.26 | 415.921 |  141.183 |   420.856 |
| 2007-12-31 00:00:00 |     569.5 |      87.85 |  573.23 |  131.716 |   546.749 |
| 2008-12-31 00:00:00 |    577.08 |      90.21 | 561.339 |  158.919 |   547.155 |
| 2009-12-31 00:00:00 |    436.45 |      83.56 | 396.559 |  120.676 |    411.83 |
| 2010-12-31 00:00:00 |    691.68 |      87.99 | 668.999 |   128.12 |   666.347 |
| 2011-12-31 00:00:00 |    573.65 |      76.86 |  550.38 |  112.614 |   540.873 |
| 2012-12-31 00:00:00 |    728.37 |     109.91 | 785.476 |  142.703 |   693.246 |
| 2013-12-31 00:00:00 |    404.42 |      68.85 |  367.48 |  113.598 |   387.134 |
| 2014-12-31 00:00:00 |    522.98 |      92.59 | 499.922 |   127.11 |   502.671 |
| 2015-12-31 00:00:00 |    459.59 |      93.55 | 430.788 |  137.286 |   438.269 |
| 2016-12-31 00:00:00 |    611.87 |      82.67 | 613.969 |  124.751 |   582.834 |


*** Land percentage

#+NAME: QC_land
#+BEGIN_SRC jupyter-python :session QC :exports results :results raw drawer

df_b2018['MAR land %'] = df_b2018['MAR land'] / df_b2018['MAR ice'] * 100
df_b2018['Bamber land %'] = df_b2018['B2018 land'] / df_b2018['B2018 ice'] * 100

df_b2018
#+END_SRC

#+RESULTS: QC_land
|                     | B2018 ice | B2018 land | MAR ice | MAR land | RACMO ice | MAR land % | Bamber land % |
|---------------------+-----------+------------+---------+----------+-----------+------------+---------------|
| 1979-12-31 00:00:00 |    282.78 |      82.25 | 239.215 |  120.519 |   261.792 |    50.3813 |       29.0862 |
| 1980-12-31 00:00:00 |    375.86 |       79.8 | 321.245 |  116.775 |   347.483 |    36.3508 |       21.2313 |
| 1981-12-31 00:00:00 |    398.82 |      79.62 | 343.306 |  118.648 |   391.154 |    34.5605 |       19.9639 |
| 1982-12-31 00:00:00 |    340.33 |      73.14 | 271.162 |  102.364 |   312.212 |      37.75 |       21.4909 |
| 1983-12-31 00:00:00 |    217.46 |     109.78 | 203.528 |  136.643 |   216.894 |    67.1375 |       50.4829 |
| 1984-12-31 00:00:00 |    340.84 |      98.73 |  345.82 |  136.167 |    335.31 |    39.3753 |       28.9667 |
| 1985-12-31 00:00:00 |    409.56 |      76.01 | 353.941 |  111.216 |   379.942 |    31.4221 |       18.5589 |
| 1986-12-31 00:00:00 |    261.07 |      78.59 | 244.377 |  113.092 |   258.204 |    46.2777 |        30.103 |
| 1987-12-31 00:00:00 |    398.38 |     104.64 | 370.967 |  134.777 |   388.581 |    36.3312 |       26.2664 |
| 1988-12-31 00:00:00 |    379.52 |      83.84 | 362.103 |  123.501 |   363.659 |    34.1066 |       22.0911 |
| 1989-12-31 00:00:00 |    371.58 |      74.93 | 354.811 |  112.768 |   367.989 |    31.7826 |       20.1652 |
| 1990-12-31 00:00:00 |    437.38 |      85.32 | 385.618 |  131.495 |   428.978 |    34.0998 |       19.5071 |
| 1991-12-31 00:00:00 |    375.62 |       90.5 | 350.413 |  126.976 |   362.512 |    36.2361 |       24.0935 |
| 1992-12-31 00:00:00 |    191.35 |      86.46 | 136.595 |  112.908 |   191.468 |    82.6589 |       45.1842 |
| 1993-12-31 00:00:00 |    413.17 |      98.09 | 335.916 |  130.219 |   395.871 |    38.7653 |       23.7408 |
| 1994-12-31 00:00:00 |    324.02 |      86.83 | 281.519 |  116.345 |   322.976 |    41.3277 |       26.7977 |
| 1995-12-31 00:00:00 |    457.09 |      73.24 | 382.108 |  118.946 |   432.718 |    31.1288 |       16.0231 |
| 1996-12-31 00:00:00 |    297.81 |     102.56 | 262.361 |  134.357 |    294.48 |    51.2106 |       34.4381 |
| 1997-12-31 00:00:00 |    353.93 |      95.32 | 327.286 |  136.939 |   350.949 |    41.8408 |       26.9319 |
| 1998-12-31 00:00:00 |    498.08 |      93.76 | 463.182 |  135.165 |   487.184 |    29.1819 |       18.8243 |
| 1999-12-31 00:00:00 |    369.42 |         85 |  335.31 |  126.997 |   362.449 |    37.8744 |        23.009 |
| 2000-12-31 00:00:00 |    368.38 |      93.03 | 369.192 |  131.905 |   386.502 |    35.7281 |       25.2538 |
| 2001-12-31 00:00:00 |    409.83 |      85.73 | 369.755 |  130.326 |   405.228 |    35.2466 |       20.9184 |
| 2002-12-31 00:00:00 |    490.93 |      88.26 | 440.602 |  146.097 |   484.532 |    33.1586 |       17.9781 |
| 2003-12-31 00:00:00 |    588.16 |      89.53 | 574.072 |  133.605 |   561.886 |    23.2732 |       15.2221 |
| 2004-12-31 00:00:00 |     468.3 |      90.22 | 451.576 |  144.358 |   470.637 |    31.9675 |       19.2654 |
| 2005-12-31 00:00:00 |    519.26 |      112.4 | 517.627 |  160.801 |   507.213 |     31.065 |       21.6462 |
| 2006-12-31 00:00:00 |    407.76 |      90.26 | 415.921 |  141.183 |   420.856 |    33.9446 |       22.1356 |
| 2007-12-31 00:00:00 |     569.5 |      87.85 |  573.23 |  131.716 |   546.749 |    22.9778 |       15.4258 |
| 2008-12-31 00:00:00 |    577.08 |      90.21 | 561.339 |  158.919 |   547.155 |    28.3108 |       15.6321 |
| 2009-12-31 00:00:00 |    436.45 |      83.56 | 396.559 |  120.676 |    411.83 |    30.4307 |       19.1454 |
| 2010-12-31 00:00:00 |    691.68 |      87.99 | 668.999 |   128.12 |   666.347 |     19.151 |       12.7212 |
| 2011-12-31 00:00:00 |    573.65 |      76.86 |  550.38 |  112.614 |   540.873 |    20.4611 |       13.3984 |
| 2012-12-31 00:00:00 |    728.37 |     109.91 | 785.476 |  142.703 |   693.246 |    18.1677 |       15.0899 |
| 2013-12-31 00:00:00 |    404.42 |      68.85 |  367.48 |  113.598 |   387.134 |    30.9127 |       17.0244 |
| 2014-12-31 00:00:00 |    522.98 |      92.59 | 499.922 |   127.11 |   502.671 |     25.426 |       17.7043 |
| 2015-12-31 00:00:00 |    459.59 |      93.55 | 430.788 |  137.286 |   438.269 |    31.8685 |       20.3551 |
| 2016-12-31 00:00:00 |    611.87 |      82.67 | 613.969 |  124.751 |   582.834 |    20.3189 |        13.511 |

** Watson
*** Check v. MAR, RACMO
*** Add MAR Land
*** Increase basins to the S to match van As basin

** GEM rivers

#+BEGIN_SRC bash :results verbatim
grass -c ./G/GEM

v.in.ascii in=${DATADIR}/GEM/meta.csv out=GEM separator=comma columns="name VARCHAR(99), x integer, y integer" x=2 y=3 skip=1

#+END_SRC

View in QGIS. Select basin IDs next to each GEM outlet

| Outlet Name    | Basin ID |
|----------------+----------|
| Kobbefjord     |   141100 |
| Oriartorfik    |   140660 |
| Teqinngalip    |   140669 |
| Kingigtorssuaq |   140937 |
| Röde_Elv       |    91818 |
| Zackenberg     |    49123 |

*** Scatter Plot

#+NAME: GEM_compare
#+BEGIN_SRC jupyter-python :session GEM :exports results :results raw drawer
import numpy as np
import pandas as pd
import xarray as xr

meta = pd.read_csv("/home/kdm/data/GEM/meta.csv")
GEM = pd.read_csv("/home/kdm/data/GEM/GEM.csv", index_col=0)

# from manual inspection of basins + GEM locations in QGIS
GEM_meta = pd.Series(index=GEM.columns)
GEM_meta['Kobbefjord']     = 141100 
GEM_meta['Oriartorfik']    = 140660
GEM_meta['Teqinngalip']    = 140669
GEM_meta['Kingigtorssuaq'] = 140937
GEM_meta['Röde_Elv']       = 91818
GEM_meta['Zackenberg']     = 49123

ds_land = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
ds_ice = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')

if 'MAR' not in locals():
    MAR = pd.DataFrame(columns=GEM.columns)
    for c in MAR.columns:
        coast_outlet = GEM_meta[c]
        MAR[c] = ds_land.sel(station=coast_outlet).to_dataframe()['runoff']

        margin_ids = ds_ice.isel({'time':0})\
                           .isel({'station':ds_ice.coast_id[0,:] == coast_outlet})\
                           .station.values
        if len(margin_ids) > 0:
            print(margin_ids)
            foo = ds_ice.sel(station=margin_ids)\
                        .to_dataframe()['runoff']\
                        .groupby("time")\
                        .sum()
            MAR[c] = MAR[c] + foo
            

from matplotlib import rc
rc('font', size=12)
rc('text', usetex=False)
# matplotlib.pyplot.xkcd()

import matplotlib.pyplot as plt
plt.close(1)
fig = plt.figure(1, figsize=(12,6)) # w,h
fig.clf()
fig.set_tight_layout(True)
# import matplotlib.gridspec as gridspec
# gs = gridspec.GridSpec(3, 2) #w,h
# ax = plt.subplot(gs[:,:])

from adjust_spines import adjust_spines as adj

for i in np.arange(6):
    ax = fig.add_subplot(2,3,i+1)
    c = GEM.columns[i]
    tmp = pd.DataFrame(GEM[c])\
            .rename({c:'GEM'}, axis='columns')\
            .merge(MAR[c], left_index=True, right_index=True, how='inner')\
            .rename({c:'MAR'}, axis='columns')\
            .dropna()

    alpha = 0.5
    # tmp = tmp.ewm(span=10).mean()
    tmp = tmp.rolling('10 D').mean()
    fname = './fig/GEM_scatter.png'
    
    s = tmp.plot(kind='scatter', 
                 x='GEM', y='MAR', 
                 alpha = alpha,
                 title = c,
                 marker = '.',
                 c = tmp.index.dayofyear,
                 colormap = 'viridis',
                 colorbar = True,
                 ax=ax)

    ax.errorbar(tmp['GEM'], tmp['MAR'], yerr=tmp['MAR']*0.15/2, 
                linestyle='', errorevery=1, ecolor='black', alpha=0.1)

    ax.plot([0,np.max([ax.get_xlim()[1],ax.get_ylim()[1]])],
            [0,np.max([ax.get_xlim()[1],ax.get_ylim()[1]])],
            'k--')
    ax.set_xlabel('GEM [m$^{3}$ s$^{-1}$]')
    ax.set_ylabel('MAR [m$^{3}$ s$^{-1}$]')
    adj(ax, ['left','bottom'])

f = plt.gcf()
(f.get_axes()[-1]).set_ylabel('Day of Year')
plt.savefig(fname, transparent=False, bbox_inches='tight', dpi=150)
#+END_SRC

*** COMMENT Time Series All Years
#+BEGIN_SRC jupyter-python :session GEM :exports results :results raw drawer
fig = plt.figure(1, figsize=(8,8)) # w,h
fig.clf()

for i in np.arange(6):
    ax = fig.add_subplot(6,1,i+1)
    c = GEM.columns[i]
    tmp = pd.DataFrame(GEM[c])\
            .rename({c:'GEM'}, axis='columns')\
            .merge(MAR[c], left_index=True, right_index=True, how='inner')\
            .rename({c:'MAR'}, axis='columns')\
            .dropna()

    alpha = 0.5
    # tmp = tmp.resample('10 D').mean()
    
    doy_mean = tmp.groupby(tmp.index.dayofyear).mean()
    doy_std = tmp.groupby(tmp.index.dayofyear).std()
    plt.plot(doy_mean.index, doy_mean['GEM'], 
             color='orange')
    plt.fill_between(doy_mean.index, 
                     doy_mean['GEM']-doy_std['GEM'],
                     doy_mean['GEM']+doy_std['GEM'],
                     color = 'orange', alpha=0.25)
    plt.plot(doy_mean.index, doy_mean['MAR'], color='k') #, drawstyle='steps')
    plt.fill_between(doy_mean.index, 
                     doy_mean['MAR']-doy_std['MAR'],
                     doy_mean['MAR']+doy_std['MAR'],
                     color = 'black', alpha=0.25)

    plt.text(0.98, 0.8, c, horizontalalignment='right',
            verticalalignment='center', transform=ax.transAxes)
    plt.xlim([100,300])
    
    if i == 0: plt.legend(loc=2)
    if i == 5:
        ax.set_xlabel('Time [day of year]')
        ax.set_ylabel('Discharge\n[m$^{3}$ s$^{-1}$]', labelpad=-60)

fname = './fig/GEM_10day_ts_doy.png'
plt.savefig(fname, transparent=False, bbox_inches='tight', dpi=150)
#+END_SRC

#+RESULTS:

#+RESULTS: GEM_compare
: /home/kdm/local/anaconda/envs/sci/lib/python3.6/site-packages/matplotlib/figure.py:2369: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.
:   warnings.warn("This figure includes Axes that are not compatible "

*** Time Series: 2017
#+BEGIN_SRC jupyter-python :session GEM :exports results :results raw drawer

plt.close(1)
fig = plt.figure(1, figsize=(8,8)) # w,h
fig.clf()
fig.set_tight_layout(True)

from adjust_spines import adjust_spines as adj

for i in np.arange(6):
    ax = fig.add_subplot(6,1,i+1)
    c = GEM.columns[i]
    tmp = pd.DataFrame(GEM[c])\
            .rename({c:'GEM'}, axis='columns')\
            .merge(MAR[c], left_index=True, right_index=True, how='inner')\
            .rename({c:'MAR'}, axis='columns')\
            .dropna()

    alpha = 0.5
    # tmp = tmp.resample('10 D').mean()
    
    tmp = tmp[tmp.index.year == 2017]

    plt.plot(tmp.index.dayofyear, tmp['GEM'], color='orange', drawstyle='steps')
    plt.plot(tmp.index.dayofyear, tmp['MAR'], color='k', drawstyle='steps')

    plt.fill_between(tmp.index.dayofyear, tmp['MAR']*0.925, tmp['MAR']*1.075, 
                     color='k', step='pre', alpha=0.25)

    # tmp2 = tmp.rolling('10 D').mean()
    # tmp2 = tmp.ewm(span=10).mean()
    # plt.plot(tmp2.index.dayofyear, tmp2['MAR'], color='k', 
    #          alpha=0.33, linewidth=3, label='MAR 10 day EWM')

    plt.text(0.98, 0.8, c, horizontalalignment='right',
            verticalalignment='center', transform=ax.transAxes)
    plt.xlim([100,300])

    if i != 5:
        adj(ax, ['left'])
    else:
        adj(ax, ['left','bottom'])

    if i == 0: 
        ax.set_ylabel('Discharge\n[m$^{3}$ s$^{-1}$]', labelpad=-50)
    if i == 1:
        plt.legend(loc=2)
    if i == 5:
        ax.set_xlabel('Time [day of year of 2017]')

fname = './fig/GEM_ts_doy.pdf'
plt.savefig(fname, transparent=False, bbox_inches='tight', dpi=150)
#+END_SRC

#+RESULTS:


* Usage Examples                                        :noexport:
:PROPERTIES:
:header-args: :tangle no
:header-args:jupyter-python+: :eval no
:header-args:bash+: :eval no
:END:
** Load Data

+ Load the data products produced by this work

#+NAME: load_this_data
#+BEGIN_SRC jupyter-python :session session :exports results :results raw drawer :eval no-export
import numpy as np
import pandas as pd
import xarray as xr

m3s_to_km3day = 86400 / 1E9

base = './freshwater/runoff/margin/'
ds = xr.open_mfdataset(base+'runoff_ice_MAR_*.nc', combine='by_coords')\
       .sum(dim='station')
df = (m3s_to_km3day * ds['runoff']).to_dataframe()\
                                   .rename({'runoff':'MAR ice'}, axis='columns')

base = './freshwater/runoff/coast/'
ds = xr.open_mfdataset(base+'runoff_land_MAR_*.nc', combine='by_coords')\
       .sum(dim='station')
df = df.merge((m3s_to_km3day * ds['runoff']).to_dataframe()\
              .rename({'runoff':'MAR land'}, axis='columns'),
              left_index=True, right_index=True)

base = './freshwater/runoff/margin/'
ds = xr.open_mfdataset(base+'runoff_ice_RACMO_*.nc', combine='by_coords')\
       .sum(dim='station')
df = df.merge((m3s_to_km3day * ds['runoff']).to_dataframe()\
              .rename({'runoff':'RACMO ice'}, axis='columns'),
              left_index=True, right_index=True)

df.head()
#+END_SRC

#+RESULTS: load_this_data
| time                |    MAR ice |   MAR land | RACMO ice |
|---------------------+------------+------------+-----------|
| 1979-04-01 00:00:00 | 0.00163387 | 0.00796036 | 0.0152787 |
| 1979-04-02 00:00:00 | 0.00168998 |  0.0117111 | 0.0152285 |
| 1979-04-03 00:00:00 |  0.0016814 |  0.0255354 |   0.01525 |
| 1979-04-04 00:00:00 | 0.00174199 |  0.0284625 | 0.0155653 |
| 1979-04-05 00:00:00 | 0.00181553 |  0.0219171 | 0.0287935 |

*** Add Bamber 2018

#+NAME: B2018
#+BEGIN_SRC jupyter-python :session session :exports results :results raw drawer :eval no-export

<<load_this_data>>

if 'b2018' not in locals():
    ds_b2018 = xr.open_mfdataset('/home/kdm/data/Bamber_2018/FWF17.v3_a.nc', 
                              data_vars='minimal',
                              combine='by_coords')
    b2018_runoff = (ds_b2018[['runoff_ice','runoff_tundra']] * ds_b2018['LSMGr'])\
        .resample(TIME='A')\
        .sum()\
        .sum(dim=['X','Y'])\
        .to_dataframe()\
        .rename({'runoff_ice':'B2018 ice','runoff_tundra':'B2018 land'}, axis='columns')

# b2018_runoff.head()

df_b2018 = b2018_runoff.merge(df.resample('A').sum(), left_index=True, right_index=True)
#+END_SRC

#+RESULTS: B2018

** All outlets inside a region

+ KML area boundary
  + Similar code for Shapefile, GeoPackage, etc.
+ Find all outlets within an area
+ Convert to CSV file for further analysis

#+header: :eval no-export
#+NAME: example_points_inside_boundary
#+BEGIN_SRC jupyter-python :session ex_points_in_boundary :exports results :results raw drawer
import numpy as np
import pandas as pd
import xarray as xr
from shapely.geometry import Point, Polygon
import shapely.speedups
import geopandas as gpd

shapely.speedups.enable()
gpd.io.file.fiona.drvsupport.supported_drivers['KML'] = 'rw'

# load the points from this data product
ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_2000.nc', combine='by_coords')
df = ds[['lon','lat']].to_dataframe().drop('alt', axis='columns')
geom = [Point(x,y) for x,y in zip(df['lon'],df['lat'])]
gdf_runoff = gpd.GeoDataFrame(index=df.index, geometry=geom, crs="epsg:4326")

# Load a KML area (or shapefile?) and get the Geometry into a Shapely Polgon object
area = gpd.read_file('./tmp/sample_area.kml', driver='KML').to_crs(epsg=4326).geometry.values[0]

# Find points within the area
pts = gdf_runoff.within(area)\
                .replace(to_replace=False, value=np.nan)\
                .dropna()\
                .replace(to_replace=1.0, value=True)

stations = pts.index

# Subset the NetCDF runoff files to these stations
# We'll take the first 5 stations just to keep output small
subset = ds.sel(station=stations[0:5])  

# If a small enough subset, convert to a DataFrame and write to CSV
df = pd.DataFrame(index=subset['time'].values, 
                  columns=subset['station'].values, 
                  data=subset['runoff'].values.T)
df.columns = pd.MultiIndex.from_arrays([df.columns, 
                                        subset['lon'].values,
                                        subset['lat'].values,
                                        subset['alt'].values],
                                       names=['station','lon','lat','alt'])

df.to_csv("subset.csv")
print(df.replace(to_replace=0, value=np.nan).dropna().head())
#+END_SRC


#+RESULTS: example_points_inside_boundary
: station         57933      57937      57945      57947      57950
: lon        -50.102306 -50.076244 -50.045834 -50.034046 -50.036995
: lat         67.163429  67.159874  67.157356  67.155975  67.148735
: alt             340.0      364.0      498.0      513.0      520.0
: 2000-05-19   0.015975   0.041059   0.036552   0.043098   0.234455
: 2000-05-20   0.035963   0.094175   0.088719   0.110411   0.629077
: 2000-05-21   0.057389   0.149936   0.148062   0.191808   1.150305
: 2000-05-22   0.052557   0.134829   0.138068   0.184658   1.118734
: 2000-05-23   0.035194   0.088458   0.089229   0.118607   0.692093

** Outlet nearest a single point

+ Given a point, find the nearest outlet

+ WARN :: This uses the nearest land outlet which only has land
          runoff. These values are *not* representative of Watson
          river discharge which is mostly ice runoff. See next example
          for looking up what ice outlets drain through a downstream
          land outlet.

#+NAME: example_outlet_near_point
#+BEGIN_SRC jupyter-python :session ex_out_near_pt :exports results :results raw drawer :eval no-export 
import numpy as np
import pandas as pd
import xarray as xr
from shapely.geometry import Point, Polygon
import geopandas as gpd

# Create a new point nearby the Watson River outlet
pt = Point((-50.68, 67.01))

# load the points from this data product
ds = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
df = ds[['lon','lat']].to_dataframe().drop('alt', axis='columns')
df['dist'] = np.sqrt( (pt.x - df['lon'])**2 + (pt.y - df['lat'])**2)

station = df['dist'].idxmin()

watson = ds.sel(station=station)\
           .to_dataframe()\
           .drop(['station','lat','lon','alt'], axis='columns')

print("Watson station ID: ", station)
watson.resample('A').sum() * 86400 / 1E9 # annual sum and convert from m^3/s to km^3/year
#+END_SRC

#+RESULTS: example_outlet_near_point
:RESULTS:
: Watson station ID:  114085
| time                |    runoff |
|---------------------+-----------|
| 1979-12-31 00:00:00 | 0.08974   |
| 1980-12-31 00:00:00 | 0.0399997 |
| 1981-12-31 00:00:00 | 0.104223  |
| 1982-12-31 00:00:00 | 0.047897  |
| 1983-12-31 00:00:00 | 0.118672  |
| 1984-12-31 00:00:00 | 0.0806003 |
| 1985-12-31 00:00:00 | 0.0709616 |
| 1986-12-31 00:00:00 | 0.108679  |
| 1987-12-31 00:00:00 | 0.0657091 |
| 1988-12-31 00:00:00 | 0.0729222 |
| 1989-12-31 00:00:00 | 0.0941922 |
| 1990-12-31 00:00:00 | 0.0611273 |
| 1991-12-31 00:00:00 | 0.108951  |
| 1992-12-31 00:00:00 | 0.0489381 |
| 1993-12-31 00:00:00 | 0.0603297 |
| 1994-12-31 00:00:00 | 0.0694203 |
| 1995-12-31 00:00:00 | 0.0830603 |
| 1996-12-31 00:00:00 | 0.0865953 |
| 1997-12-31 00:00:00 | 0.114467  |
| 1998-12-31 00:00:00 | 0.067885  |
| 1999-12-31 00:00:00 | 0.0703707 |
| 2000-12-31 00:00:00 | 0.069962  |
| 2001-12-31 00:00:00 | 0.120072  |
| 2002-12-31 00:00:00 | 0.0618902 |
| 2003-12-31 00:00:00 | 0.0917338 |
| 2004-12-31 00:00:00 | 0.0970538 |
| 2005-12-31 00:00:00 | 0.128975  |
| 2006-12-31 00:00:00 | 0.0900687 |
| 2007-12-31 00:00:00 | 0.109273  |
| 2008-12-31 00:00:00 | 0.106662  |
| 2009-12-31 00:00:00 | 0.0567749 |
| 2010-12-31 00:00:00 | 0.0744363 |
| 2011-12-31 00:00:00 | 0.0629914 |
| 2012-12-31 00:00:00 | 0.109866  |
| 2013-12-31 00:00:00 | 0.0598411 |
| 2014-12-31 00:00:00 | 0.0414301 |
| 2015-12-31 00:00:00 | 0.0678111 |
| 2016-12-31 00:00:00 | 0.0490366 |
| 2017-12-31 00:00:00 | 0.0841888 |
:END:

** Ice outlets draining through a nearby coast outlet

+ Watson River sample site located at "67.01 N by 50.68 W" according
  to citet:van-as_2018_reconstructing.
+ Find the nearest coast outlet
+ Find all the ice outlets that drain through that coast outlet.

#+NAME: runoff_watson
#+BEGIN_SRC jupyter-python :session session :exports results :results raw drawer :eval no
def runoff_watson():
    <<runoff_nearest_watson>>
    return watson
#+END_SRC

Now implement the function:

#+NAME: runoff_nearest_watson
#+BEGIN_SRC jupyter-python :session watson :exports results :results raw drawer :eval no-export 
import numpy as np
import pandas as pd
import xarray as xr
from shapely.geometry import Point, Polygon
import geopandas as gpd

# Create a new point nearby the Watson River outlet
pt = Point((-50.68, 67.01))

df = pd.read_csv("./freshwater/ice_surf/outlets.csv", index_col=0)\
    .drop(['x','y','elev','coast_x','coast_y'], axis='columns')
df['dist'] = np.sqrt( (pt.x - df['coast_lon'])**2 + (pt.y - df['coast_lat'])**2)

coast_nearest_idx = df['dist'].idxmin()
coast_outlet = df.loc[coast_nearest_idx, 'coast_id']
margin_outlets = df[df['coast_id'] == coast_outlet]

# now open all the runoff data and extract the margin outlets
ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')
watson_ice = ds.sel(station=margin_outlets.index)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()

ds = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
watson_land = ds.sel(station=coast_outlet)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()

watson = pd.DataFrame(index=watson_ice.index, data=watson_ice.values, columns=['MAR ice'])
watson['MAR land'] = watson_land.values

ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_RACMO_*.nc', combine='by_coords')
watson_ice = ds.sel(station=margin_outlets.index)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()
watson_ice.name = 'RACMO ice'

watson = watson.merge(watson_ice, left_index=True, right_index=True)
#+END_SRC

#+RESULTS: runoff_nearest_watson


#+BEGIN_SRC jupyter-python :session watson :exports results :results raw drawer :eval no-export
watson.resample('A').sum().tail() * 86400 / 1E9 # annual sum and convert from m^3/s to km^3/year
#+END_SRC

#+RESULTS:
| time                | MAR ice |  MAR land | RACMO ice |
|---------------------+---------+-----------+-----------|
| 2013-12-31 00:00:00 | 2.83574 | 0.0598411 |   3.25065 |
| 2014-12-31 00:00:00 | 3.81297 | 0.0414301 |   3.98435 |
| 2015-12-31 00:00:00 | 2.62778 | 0.0678111 |   2.69092 |
| 2016-12-31 00:00:00 | 4.32991 | 0.0490366 |   4.61081 |
| 2017-12-31 00:00:00 | 3.40902 | 0.0841888 |   3.45771 |

** Subset by simple region, sum across region and by month

| Lat/Lon | West of 45° | East of 45° |
|---------+-------------+-------------|
|  >76 °N |           9 |          10 |
|   72-76 |           8 |           7 |
|   68-72 |           6 |           5 |
|   64-68 |           4 |           3 |
|     <64 |           2 |           1 |

#+BEGIN_SRC jupyter-python :exports both :results raw drawer :eval no
import numpy as np
import pandas as pd
import xarray as xr

ds = xr.open_mfdataset("./freshwater/runoff/margin/runoff_ice_MAR_*.nc", combine='by_coords')\
       .resample(time='MS')\
       .sum()['runoff']

df = pd.DataFrame(index=ds['time'].values)

df['<45 76N'] = ds.where((ds['lon']<-45) & (ds['lat']>76)).sum(dim='station')
df['<45 72-76N'] = ds.where((ds['lon']<-45) & (ds['lat']>72) & (ds['lat']<76)).sum(dim='station')
df['<45 68-72N'] = ds.where((ds['lon']<-45) & (ds['lat']>68) & (ds['lat']<72)).sum(dim='station')
df['<45 64-68N'] = ds.where((ds['lon']<-45) & (ds['lat']>64) & (ds['lat']<68)).sum(dim='station')
df['<45 64N'] = ds.where((ds['lon']<-45) & (ds['lat']<64)).sum(dim='station')

df['>45 76N'] = ds.where((ds['lon']>-45) & (ds['lat']>76)).sum(dim='station')
df['>45 72-76N'] = ds.where((ds['lon']>-45) & (ds['lat']>72) & (ds['lat']<76)).sum(dim='station')
df['>45 68-72N'] = ds.where((ds['lon']>-45) & (ds['lat']>68) & (ds['lat']<72)).sum(dim='station')
df['>45 64-68N'] = ds.where((ds['lon']>-45) & (ds['lat']>64) & (ds['lat']<68)).sum(dim='station')
df['>45 64N'] = ds.where((ds['lon']>-45) & (ds['lat']<64)).sum(dim='station')

df.index.name='Date'
# df.to_csv("./tmp/ice_runoff_quads_MAR.csv", float_format="%.5f")

(df.iloc[:,0:6]*86400/1E9).resample('AS').sum()
#+END_SRC

* Supplemental Material                                 :noexport:
:PROPERTIES:
:header-args:bash+: :eval no
:header-args:jupyter-python+: :eval no
:END:
** Coverage
:PROPERTIES:
:CUSTOM_ID: supplemental:coverage
:END:
*** Introduction

The 1) MAR and RACMO models, 2) basins based on the GIMP surface, and 3) reality, are not always correctly aligned. Misalignment includes the following:

#+NAME: tab:misalignment
| Reality | Basin   | Model   | Comment |
|---------+---------+---------+---------|
| Glacier | Glacier | Glacier | aligned |
| Land    | Land    | Land    | aligned |
|---------+---------+---------+---------|
| Glacier | Glacier | Land    |         |
| Glacier | Land    | Glacier |         |
| Glacier | Land    | Land    |         |
| Land    | Land    | Glacier |         |
| Land    | Glacier | Land    |         |
| Land    | Glacier | Glacier |         |

We ignore "Reality" and treat the basin output as the standard, which reduces Table [[tab:misalignment]] to just two cases where basins and model disagree, with the following effects:

1) Where basin = glacier and model = land, glacier runoff is lost
2) Where basin = land and model = glacier, land runoff is lost

#+NAME: coverage_report
#+BEGIN_SRC bash :results none :exports none :var mapset="coverage_report" :eval no-export
<<grass_init_mapset>>
g.mapset -c coverage_report --q
g.region -d

r.mapcalc "basins_ice = if(isnull(basins@ice_surf), 0, 1)" --q
r.mapcalc "basins_land = if(isnull(basins@land_surf), 0, 1)" --q # includes upstream ice
r.mapcalc "basins = 2-(basins_ice + basins_land)" --q
r.category --q map=basins separator=: rules=- << EOF
0:basin ice
1:basin land
2:basin fjord
EOF

r.mapcalc "model = 2 - int(MSK_GIMP@MAR)" --q
r.category --q map=model separator=: rules=- << EOF
0:model ice
1:model land
2:model fjord
EOF

r.report --q -h map=basins,model units=k output=./tmp/coverage_report --o
#+END_SRC

#+NAME: coverage_report
#+BEGIN_SRC bash :results drawer :exports results :eval no-export
cat ./tmp/coverage_report
#+END_SRC

#+RESULTS: coverage_report
:results:
+-----------------------------------------------------------------------------+
|                      Category Information                        |  square  |
|description                                                     |kilometers|
|-----------------------------------------------------------------------------|
|0|basin ice                                                       | 1,807,264|
| |----------------------------------------------------------------|----------|
| |0|model ice. . . . . . . . . . . . . . . . . . . . . . . . . . .| 1,769,087|
| |1|model land . . . . . . . . . . . . . . . . . . . . . . . . . .|    37,699|
| |2|model fjord. . . . . . . . . . . . . . . . . . . . . . . . . .|       479|
|------------------------------------------------------------------|----------|
|1|basin land                                                      |   336,497|
| |----------------------------------------------------------------|----------|
| |0|model ice. . . . . . . . . . . . . . . . . . . . . . . . . . .|    10,569|
| |1|model land . . . . . . . . . . . . . . . . . . . . . . . . . .|   306,256|
| |2|model fjord. . . . . . . . . . . . . . . . . . . . . . . . . .|    19,672|
|------------------------------------------------------------------|----------|
|2|basin fjord                                                     | 1,895,048|
| |----------------------------------------------------------------|----------|
| |0|model ice. . . . . . . . . . . . . . . . . . . . . . . . . . .|       251|
| |1|model land . . . . . . . . . . . . . . . . . . . . . . . . . .|   328,429|
| |2|model fjord. . . . . . . . . . . . . . . . . . . . . . . . . .| 1,566,218|
| |*|no data. . . . . . . . . . . . . . . . . . . . . . . . . . . .|       150|
|-----------------------------------------------------------------------------|
|TOTAL                                                             | 4,038,810|
+-----------------------------------------------------------------------------+
:end:

We adjust the model results to the basin in the following ways. For speed, the following is done once using a basin and model mask, not using the daily values. A coverage factor is calculated one time, and then used as a daily multiplier later in the workflow.

Where a basin reports ice and the model reports land, we divide the daily runoff values of the basin cells that do have model ice by the ratio of the total basin area to the area with ice (with runoff data). That is, the model land runoff is discarded, and the nearby model ice runoff is scaled to compensate for the uncovered basin cells. For example, if an ice basin is 90 % covered by model ice, model runoff is divided by 0.9 to scale it to an estimate of what 100 % runoff would be. This scenario occurs frequently at the ice margin because the 1 km^{2} model grid cell rarely matches 90 m^{2} basin boundary. It also occurs wherever nunatuks exist, because ice sheet interior "holes" are filled, otherwise they act as interior drains that block large areas from routing to the coast, something unlikely to occur in reality. When a small basin has no model cells covering any part of it, that basin never has any reported runoff. 

Where a basin reports land and the model reports ice, the same treatment as above is performed, but for land. That is, the model ice runoff is discarded, and the nearby model land runoff is scaled to compensate for the uncovered basin cells. As above, this occurs frequently at the ice margin for the same reason. Large areas of model ice (and reality ice) are occasionally reported over land basins where outlet glaciers are not properly captured in the model masks (FIGURE near UAK).

Where the model mask reports ocean, no basins exist and model runoff, both land and ice, are discarded. Large amounts of real ocean and fjord locations are classified as land in the MAR model mask variable.

The above means that model runoff is not conserved. 

*** Algorithm                                           :noexport:
:PROPERTIES:
:ID:       f4817a3a-ba97-45b3-8c46-1894f75e91a4
:END:
**** Test Manual
Scale the model area covering each basin so that it equals the basin area.

First, lets test this - some visual examination
#+BEGIN_SRC bash :results verbatim :tangle no :session foo
rm -fR ./G/test_coverage
grass -c ./G/test_coverage

g.mapset -c coverage_test
g.region -d
r.mask -r

# pick one and zoom in
r.mapcalc "land_basin = if(basins@ice_surf == 353, 353, null())"  --q --o
r.colors map=land_basin color=green
r.mapcalc "ice_basin = if(basins@ice_surf == 12, 12, null())"  --q --o
r.colors map=ice_basin color=water

g.region zoom=land_basin --q

d.mon start=wx0
d.erase
d.rast land_basin
d.rast ice_basin
# # check if model ice exists here
d.rast mask_ice_MAR@MAR # yes

r.report --q -h map=ice_basin,mask_ice_MAR@MAR units=k | grep -A4 "|12|"
# SAME -> setting mask not needed for ice.

g.region zoom=land_basin --q
r.report --q -h map=land_basin,mask_land_MAR@MAR units=k | grep -A4 "|353|"

g.region zoom=land_basin --q
r.report --q -h map=ice_basins@land_surf,mask_ice_MAR@MAR units=k | grep -A4 "|353|"

# coverage report
r.report --q -h map=basins@land_surf,mask_ice_MAR@MAR units=k
#+END_SRC


Generate a test file

#+BEGIN_SRC bash :results verbatim :tangle no-export
grass -c ./G/test_coverage
r.report --q -h map=basins@ice_surf,mask_ice_MAR@MAR units=k | head -n 100
r.stats --q -aN input=basins@ice_surf,mask_ice_MAR@MAR separator=,  > ./tmp/coverage_test.csv
exit
#+END_SRC

#+RESULTS:

Compute coverage

#+BEGIN_SRC jupyter-python :session coverage_test :exports results :results raw drawer :eval no-export
import numpy as np
import pandas as pd

df_raw = pd.read_csv("./tmp/coverage_test.csv", index_col=0, names=["c_or_uc", "area"])
df_raw = df_raw.drop(df_raw[df_raw.index == '*'].index)
df_raw.index = df_raw.index.astype(np.int)

df_c = df_raw[df_raw['c_or_uc'] == '1']\
    .drop(labels='c_or_uc', axis='columns')\
    .rename({'area':'covered'}, axis='columns')

df_uc = df_raw[df_raw['c_or_uc'] == '*']\
    .drop(labels='c_or_uc', axis='columns')\
    .rename({'area':'uncovered'}, axis='columns')

df = df_c.merge(df_uc, how='outer', left_index=True, right_index=True)\
         .sort_index()\
         .fillna(0)

df['coverage'] = df['covered'] / (df['covered'] + df['uncovered'])

# If we take the model area, divide by coverage, is it equal to the basin area?
# df['test'] = ((df['covered']+df['uncovered']) - (df['covered']/df['coverage'])) < 0.001
# some tests are False because coverage is 0: df[df['test'] == False].coverage.sum()

df.head(30)
#+END_SRC

#+RESULTS:
|     |    covered | uncovered |  coverage |
|-----+------------+-----------+-----------|
|   1 |   1.22e+06 |     60000 |  0.953125 |
|   4 |     750000 |    550000 |  0.576923 |
|   7 |     900000 |  1.93e+06 |  0.318021 |
|   8 |   2.24e+07 |  7.72e+06 |  0.743692 |
|   9 |    5.7e+06 |  1.17e+06 |  0.829694 |
|  11 |     930000 |    780000 |   0.54386 |
|  12 |   1.55e+06 |    190000 |  0.890805 |
|  16 |   6.12e+06 |    330000 |  0.948837 |
|  19 |      20000 |  1.05e+06 | 0.0186916 |
|  22 |    1.7e+06 |    320000 |  0.841584 |
|  26 |          0 |  1.36e+06 |         0 |
|  34 |     930000 |    200000 |  0.823009 |
|  37 |   2.43e+06 |    540000 |  0.818182 |
|  44 | 1.2776e+08 | 3.962e+07 |  0.763293 |
|  45 |     860000 |    150000 |  0.851485 |
|  50 |          0 |  1.91e+06 |         0 |
|  55 |          0 |  1.19e+06 |         0 |
|  56 |   5.02e+06 |  1.24e+06 |  0.801917 |
|  58 |          0 |  1.66e+06 |         0 |
|  59 |     470000 |  2.99e+06 |  0.135838 |
|  63 |          0 |  1.17e+06 |         0 |
|  69 |   1.19e+06 |    820000 |   0.59204 |
|  74 |          0 |  1.14e+06 |         0 |
|  75 |   2.76e+06 |     60000 |  0.978723 |
|  91 |   4.11e+06 |    430000 |  0.905286 |
|  95 |          0 |  1.03e+06 |         0 |
|  98 |   3.04e+06 |  3.71e+06 |   0.45037 |
| 100 |   2.01e+06 |     30000 |  0.985294 |
| 101 |   1.44e+06 |     70000 |  0.953642 |
| 111 |     820000 |  1.84e+06 |  0.308271 |

**** Solution

The key line is:

#+BEGIN_SRC bash :results none :eval no
r.stats --q -aN input=basins@ice_surf,mask_ice_MAR@MAR separator=,  > ./tmp/coverage_test.csv
#+END_SRC

In the main processing loop, I'll add a line like:

#+BEGIN_SRC bash :results none :eval no
r.stats --q -aN input=basins@<MAPSET>,mask_<domain>_<model>@<model> separator=,  \
	> ./tmp/coverage_<mapset>_<domain>_<model>.csv
#+END_SRC

And then in post-processing I will calculate coverage and apply it to each basin.

*** Figure

#+BEGIN_SRC bash :results verbatim
g.mapset -c test_alignment

g.region n=-3227490 s=-3253500 w=7110 e=48960 res=90 -pa align=mask_ice_basin@MAR
g.region save=test --o

# MAR grid to this mapset and region subset
r.to.vect input=mask_ice_MAR@MAR output=MAR_grid_ice type=area
r.to.vect input=mask_land_MAR@MAR output=MAR_grid_land type=area

# MAR grid centers at MAR res to this mapset and region subset
g.region res=1000 -p
r.to.vect input=mask_ice_MAR@MAR output=MAR_grid_ice_point type=point
r.to.vect input=mask_land_MAR@MAR output=MAR_grid_land_point type=point
g.region region=test -p

d.mon start=wx1
d.erase

d.vect basins@land_surf fill_color=178:223:138 color=100:100:100 legend_label="Land Basin"
d.vect basins@ice_surf fill_color=166:206:227 color=100:100:100 legend_label="Ice Basin" 
# d.vect outlets@land_surf fill_color=green icon=basic/circle size=7 legend_label="Ice Outlet"
# d.vect outlets@ice_surf fill_color=blue icon=basic/circle size=7 legend_label="Land Outlet"

d.vect MAR_grid_ice fill_color=none color=black width=3 legend_label="MAR Ice/Land Boundary"
d.vect MAR_grid_ice_point icon=basic/box color=black fill_color=blue size=3 legend_label="MAR Ice Cell"
d.vect MAR_grid_land_point icon=basic/box color=black fill_color=green size=3 legend_label="MAR Land Cell"
#+END_SRC

NOTE - better figure generated in QGIS, but using the data created above. See [[./fig/alignment.qgz]] and output ./fig/basin_MAR_align.png

#+BEGIN_SRC bash :results verbatim
ps.map -e input=./tmp/basin_MAR_align.psmap output=./fig/basin_MAR_align.eps --o
convert -trim -density 300 ./fig/basin_MAR_align.eps ./fig/basin_MAR_align.png
o ./fig/basin_MAR_align.png
#+END_SRC
#+RESULTS:

#+NAME: basin_MAR_align_psmap
#+BEGIN_SRC bash :results verbatim :tangle ./tmp/basin_MAR_align.psmap :mkdirp tmp
border n
# scale 1:1000000
paper a4
  end

vareas MAR_grid_ice
  color black
  pat $GISBASE/etc/paint/patterns/diag_down.eps
  scale 1
  fcolor 55:126:184
  width 1
  label "MAR ice"
  end

vareas MAR_grid_land
  color black
  pat $GISBASE/etc/paint/patterns/diag_up.eps
  scale 1
  fcolor 51:160:44
  width 1
  label "MAR land"
  end

# hatch fill
vareas basins@ice_surf
  # pat $GISBASE/etc/paint/patterns/diag_up.eps
  # scale 0.5
  # fcolor 55:126:184
  color 55:126:184
  # fcolor 166:206:227
  fcolor 240:240:240
  label "Basin ice"
  end

# vareas basins@ice_surf
#   color 55:126:184
#   fcolor 166:206:227
#   end

vareas basins@land_surf
  color 51:160:44
  fcolor 127:223:138
  label "Basin land"
  end

# # crosses on land
# vpoints MAR_grid_land_point
#   type point
#   color 51:160:44
#   scale 3
#   # see ${GISBAS}/etc/symbol/basic/
#   symbol basic/x
#   label "Model Land Grid Cell"
#   end

vlegend
  where 5.7 1.1
  fontsize 14
  end

scalebar f
   length 4
   units kilometers
   segment 2
   where 1 5
   fontsize 14
   end
#+END_SRC


#+NAME: fig:alignment
#+ATTR_LATEX: :width \textwidth :placement [!h]
#+CAPTION: Example region near southren Greenland showing 90 m basin delineation and 1000 m model boundary. Basins are delineated by gray line and classified as ice (blue) and land (green). Model ice/land boundary is delineated by black line and cells are classified by a small blue (ice) or green (land) box at cell center.
[[./fig/basin_MAR_align.png]]



** Basin changes with changing k

+ First, calculate basins with a range of \(k\). This uses the same basin delineation code as the main work, but with the head calculated from BedMachine instead of ArcticDEM so that we can take advantage of BedMachine bed and thickness.

+ To find out how much each upstream cell moved between two basin
  delineations, we take the ArcticDEM outlet locations as baseline,
  and...
  + For each outlet (ArcticDEM and other inputs), get the x and y
    coordinate and the outlet ID (also the basin ID).
  + Build two raster maps, x and y, where each cell in x(y) has the
    x(y) coordinate of the outlet for that cell.
  + Distance in outlet location is then sqrt((base_x-x)^2 + (base_y-y)^2) for each cell.

*** Calculate basins with changing k
:PROPERTIES:
:header-args:bash+: :tangle k_basin_change.sh
:header-args:bash+: :comments both
:header-args:bash+: :tangle-mode (identity #o744)
:header-args:bash+: :shebang #!/usr/bin/env bash
:END:

#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC


+ We'll do this work with BedMachine v3 so that the surface and subglacial are consistent.
+ This is similar to <<head>> calculation elsewhere, but uses BedMachine instead of ArcticDEM.

#+NAME: head_BM3
#+BEGIN_SRC bash :results verbatim :tangle no
r.mapcalc "head_unfilled = if(mask_o_l_i@ArcticDEM == 1, null(), z_s@BedMachine)"
r.fill.dir input=head_unfilled output=head direction=fill_dir areas=fill_problem_areas
#+END_SRC

+ And again, head_sub

#+NAME: head_sub_BM3
#+BEGIN_SRC bash :results verbatim :tangle no
log_info "Calculating subglacial head with k: ${k}"
r.mapcalc "head_unfilled = if(mask_o_l_i@ArcticDEM == 1, null(), 0) + if(mask_o_l_i@ArcticDEM == 2, z_s@BedMachine, 0) + if(mask_o_l_i@ArcticDEM == 3, (z_b@BedMachine) + ${k} * 0.917 * thickness@BedMachine)"
r.fill.dir input=head_unfilled output=head direction=fill_dir areas=fill_problem_areas
#+END_SRC

#+BEGIN_SRC bash :results verbatim

g.mapset -c ice_surf_BM3
<<ice_domain>>
<<head_BM3>>
<<sob>>

g.mapset -c land_surf_BM3
<<land_domain>>
<<head_BM3>>
<<sob>>

#+END_SRC


#+BEGIN_SRC bash :results verbatim

for k_pct in 100 90 80; do
    k=$(echo "scale=2; ${k_pct}/100" | bc -l)
    log_info "Running algorithm with k = ${k_pct}"

    g.mapset -c ice_sub_BM3_${k_pct}
    <<ice_domain>>
    <<head_sub_BM3>>
    <<sob>>

    g.mapset -c land_sub_BM3_${k_pct}
    <<land_domain>>
    <<head_sub_BM3>>
    <<sob>>
done
#+END_SRC

*** Generate difference maps for different basins
:PROPERTIES:
:header-args:bash+: :tangle k_basin_change_diff.sh
:header-args:bash+: :comments both
:header-args:bash+: :tangle-mode (identity #o744)
:header-args:bash+: :shebang #!/usr/bin/env bash
:END:

#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC

**** Extract the x and y coordinates of each outlet
#+BEGIN_SRC bash :results verbatimn
g.mapset -c k_basin_change

r.out.xyz input=outlets@ice_surf | awk -F'|' '{print $3, $1}' > ./tmp/outlets_ice_surf_x
r.out.xyz input=outlets@ice_surf | awk -F'|' '{print $3, $2}' > ./tmp/outlets_ice_surf_y
r.out.xyz input=outlets@ice_surf_BM3 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_ice_surf_BM3_x
r.out.xyz input=outlets@ice_surf_BM3 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_ice_surf_BM3_y
r.out.xyz input=outlets@ice_sub_BM3_100 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_ice_sub_BM3_100_x
r.out.xyz input=outlets@ice_sub_BM3_100 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_ice_sub_BM3_100_y
r.out.xyz input=outlets@ice_sub_BM3_90 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_ice_sub_BM3_90_x
r.out.xyz input=outlets@ice_sub_BM3_90 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_ice_sub_BM3_90_y
r.out.xyz input=outlets@ice_sub_BM3_80 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_ice_sub_BM3_80_x
r.out.xyz input=outlets@ice_sub_BM3_80 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_ice_sub_BM3_80_y

r.out.xyz input=outlets@land_surf | awk -F'|' '{print $3, $1}' > ./tmp/outlets_land_surf_x
r.out.xyz input=outlets@land_surf | awk -F'|' '{print $3, $2}' > ./tmp/outlets_land_surf_y
r.out.xyz input=outlets@land_surf_BM3 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_land_surf_BM3_x
r.out.xyz input=outlets@land_surf_BM3 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_land_surf_BM3_y
r.out.xyz input=outlets@land_sub_BM3_100 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_land_sub_BM3_100_x
r.out.xyz input=outlets@land_sub_BM3_100 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_land_sub_BM3_100_y
r.out.xyz input=outlets@land_sub_BM3_90 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_land_sub_BM3_90_x
r.out.xyz input=outlets@land_sub_BM3_90 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_land_sub_BM3_90_y
r.out.xyz input=outlets@land_sub_BM3_80 | awk -F'|' '{print $3, $1}' > ./tmp/outlets_land_sub_BM3_80_x
r.out.xyz input=outlets@land_sub_BM3_80 | awk -F'|' '{print $3, $2}' > ./tmp/outlets_land_sub_BM3_80_y
#+END_SRC

**** Basins map where pixel encodes the x and y coordinate of its outlet
#+BEGIN_SRC bash :results verbatim
# g.copy basins@ice_surf,basins_ice_surf_x
# g.copy basins@ice_surf,basins_ice_surf_y
# r.category map=basins_ice_surf_x rules=./tmp/outlets_ice_surf_x separator=space
# r.category map=basins_ice_surf_y rules=./tmp/outlets_ice_surf_y separator=space

for domain in ice land; do
  for coord in x y; do
    for k 1in surf surf_BM3 sub_BM3_100 sub_BM3_90 sub_BM3_80; do
      g.copy basins@${domain}_${k},basins_${domain}_${k}_${coord}
      r.category map=basins_${domain}_${k}_${coord} rules=./tmp/outlets_${domain}_${k}_${coord} separator=space
    done
  done
done
#+END_SRC

**** Compute the diff in the outlet location between basin maps

Difference of each pixel between routing schemes
+ Surface (surf) to the various subglacial routes
+ 100 % and 80 % effective pressure using BedMachine v3 (BM3)

#+BEGIN_SRC bash :results verbatim

log_info "Calculating basin outlet differences."
log_warn "This takes a while..."

for domain in ice land; do

# ArcticDEM surface v. BM3 surface
r.mapcalc "diff_${domain}_surf_ArcticDEM_surfBM3 = ((@basins_${domain}_surf_x - @basins_${domain}_surf_BM3_x)^2 + (@basins_${domain}_surf_y - @basins_${domain}_surf_BM3_y)^2)^0.5"

# ArcticDEM surface v. BM3 100 subglacial...
r.mapcalc "diff_${domain}_surf_sub_BM3_100 = ((@basins_${domain}_surf_x - @basins_${domain}_sub_BM3_100_x)^2 + (@basins_${domain}_surf_y - @basins_${domain}_sub_BM3_100_y)^2)^0.5"

r.mapcalc "diff_${domain}_surf_sub_BM3_90 = ((@basins_${domain}_surf_x - @basins_${domain}_sub_BM3_90_x)^2 + (@basins_${domain}_surf_y - @basins_${domain}_sub_BM3_90_y)^2)^0.5"

r.mapcalc "diff_${domain}_surf_sub_BM3_80 = ((@basins_${domain}_surf_x - @basins_${domain}_sub_BM3_80_x)^2 + (@basins_${domain}_surf_y - @basins_${domain}_sub_BM3_80_y)^2)^0.5"

done
#+END_SRC

**** Color the difference maps

#+BEGIN_SRC ascii :tangle ./tmp/categories.txt :mkdirp t :eval no :comments nil
0 = 1 no change
0 thru 999 = 1 < 1 km
1000 thru 2999 = 2 1 to < 3 km
3000 thru 10000 = 3 3 to < 10 km
10001 thru 29999 = 4 10 to < 30 km
30000 thru 99999 = 5 30 to < 100 km
100000 thru 10000000 = 6 > 100 km
#+END_SRC

#+BEGIN_SRC bash :results verbatim :tangle no
for raster in $(g.list type=raster |grep "^diff_" | grep -v "_class$"); do
  r.reclass input=${raster} output=${raster}_class --o rules=./tmp/categories.txt
  r.colors map=${raster}_class color=viridis
done
#+END_SRC

*** Visualize Maps
:PROPERTIES:
:header-args:bash+: :tangle k_basin_change_graphics.sh
:header-args:bash+: :comments both
:header-args:bash+: :tangle-mode (identity #o744)
:header-args:bash+: :shebang #!/usr/bin/env bash
:END:

#+BEGIN_SRC bash :results verbatim
<<init>>
#+END_SRC

**** Prepare coastline vectors
#+BEGIN_SRC bash :results verbatim
g.mapset k_basin_change

g.region -d
r.mapcalc "outline = if(mask_o_l_i@ArcticDEM != 1)"
r.to.vect input=outline output=outline type=area

g.region res=1000 -a
r.mapcalc "outline_low = if(mask_o_l_i@ArcticDEM != 1)"
r.to.vect input=outline_low output=outline_low type=area
g.region -d
#+END_SRC
**** Prepare some contours
+ Could be useful to show an elevation contour representative of the max melt elevation
#+BEGIN_SRC bash :results verbatim
r.mask outline maskcats=1 --o
g.region res=1000
r.mapcalc "z_s = z_s@BedMachine" # mask
r.contour input=z_s output=z_s levels=1000,1500,2000
g.region -d
r.mask -r
#+END_SRC

**** PSMAP commands
***** Shared
#+NAME: psmap
#+BEGIN_SRC bash :results verbatim :tangle ./tmp/psmap.psmap
border n
# scale 1:1000000
paper a3
  end
raster ${d}

vlines z_s
  type line
  where level = 1500
  color black
  width 1
  end
vlines z_s
  type line
  where level = 1500
  color white
  width 5
  end
vareas outline
  color gray
  fcolor none
  width 0.1
  end

#+END_SRC
***** Legend for all of Greenland
#+NAME: psmap_legend_GL
#+BEGIN_SRC bash :results verbatim :tangle ./tmp/psmap_legend_GL.psmap
colortable y
  nodata n
  where 5.5 12
  fontsize 24
  end
scalebar s
  length 100
  units kilometers
  segment 1
  where 7 11.5
  fontsize 24
  end
#+END_SRC

***** Legend for zoom region
#+NAME: psmap_legend_zoom
#+BEGIN_SRC bash :results verbatim :tangle ./tmp/psmap_legend_zoom.psmap
# vareas outline
#   color gray
#   fcolor none
#   width 0.1
#   end

# 10 km^2:  10000000 
# 100 km^2: 100000000
# vareas basins@ice_surf
#   where area > 100000000
#   color white
#   fcolor none
#   width 0.3
#   end
# vareas basins@ice_100
#   where area > 100000000
#   color red
#   fcolor none
#   width 0.3
#   end
colortable y
  nodata n
  fontsize 24
  end

scalebar s
  length 30
  units kilometers
  segment 1
  where 2 6
  fontsize 24
  end
#+END_SRC

**** TEST Generate an image
***** All Greenland
#+BEGIN_SRC bash :results verbatim :tangle no :session *freshwater-shell* 
# All of Greenland

g.region -d 
g.region res=500 -a

d=diff_land_surf_ArcticDEM_surfBM3_class
fname=${d}
cat << EOF | ps.map -e input=- output=./tmp/${fname}.eps --o
<<psmap>>
<<psmap_legend_GL>>
EOF
convert -trim ./tmp/${fname}.{eps,png}
o ./tmp/${fname}.png
g.region -d

#+END_SRC

***** Zoomed

#+BEGIN_SRC bash :results verbatim :tangle no :session *freshwater-shell*
# Zoom 

g.region n=-2200000 s=-2400000 w=-276000 e=-90000 res=100 -p # Jakobshavn
g.region n=-2735300 s=-2843700 w=-339200 e=-178900 res=100 -p # Gothåbsfjord
g.region n=-2387800 s=-2717400 w=-398900 e=88300 res=100 -p # Watson Basin

g.region save=zoom
d=diff_ice_surf_ArcticDEM_surfBM3_class

fname=diff_${d}_zoom
cat << EOF | ps.map -e input=- output=./tmp/${fname}.eps --o
<<psmap>>
<<psmap_legend_zoom>>
EOF
convert -trim ./tmp/${fname}.{eps,png}
o ./tmp/${fname}.png
g.region -d
#+END_SRC

**** Generate EPS files: Greenland
+ Use the PSMAP block above
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*

mkdir -p ./fig

g.region -d
g.region res=1000 -a
r.mask -r
for d in $(g.list type=raster |grep "^diff_.*_class"); do
  fname=${d}
  cat << EOF | ps.map input=- output=./tmp/${fname}.ps --o
<<psmap>>
<<psmap_legend_GL>>
EOF
  convert -trim -transparent white ./tmp/${fname}.ps ./fig/${fname}.png
done
g.region -d
#+END_SRC

**** Generate EPS files: Zoomed
+ Use the PSMAP block above
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*

g.region n=-2200000 s=-2400000 w=-276000 e=-90000 res=100 -p # Jakobshavn
for d in $(g.list type=raster |grep "^diff_.*_class"); do
  fname=${d}_zoom_jako
  cat << EOF | ps.map input=- output=./tmp/${fname}.ps --o
<<psmap>>
<<psmap_legend_zoom>>
EOF
  convert -trim -transparent white ./tmp/${fname}.ps ./fig/${fname}.png
done
g.region -d


g.region n=-2735300 s=-2843700 w=-339200 e=-178900 res=100 -p # Gothåbsfjord
for d in $(g.list type=raster |grep "^diff_.*_class"); do
  fname=${d}_zoom_gothabs
  cat << EOF | ps.map input=- output=./tmp/${fname}.ps --o
<<psmap>>
<<psmap_legend_zoom>>
EOF
  convert -trim -transparent white ./tmp/${fname}.ps ./fig/${fname}.png
done
g.region -d

g.region n=-2387800 s=-2717400 w=-398900 e=88300 res=100 -p # Watson Basin
for d in $(g.list type=raster |grep "^diff_.*_class"); do
  fname=${d}_zoom_watson
  cat << EOF | ps.map input=- output=./tmp/${fname}.ps --o
<<psmap>>
<<psmap_legend_zoom>>
EOF
  convert -trim -transparent white ./tmp/${fname}.ps ./fig/${fname}.png
done
g.region -d


#+END_SRC



* Figures
:PROPERTIES:
:clearpage: t    
:header-args:bash+: :eval no :session
:header-args:jupyter-python+: :eval no
:END:

# %% ONE-COLUMN FIGURES
# %\begin{figure}[t]
# %\includegraphics[width=8.3cm]{FILE NAME}
# %\caption{TEXT}
# %\end{figure}
# %
# %%% TWO-COLUMN FIGURES
# %\begin{figure*}[t]
# %\includegraphics[width=12cm]{FILE NAME}
# %\caption{TEXT}
# %\end{figure*}

** Overview

#+NAME: fig_prep
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell* :export no :results none
g.mapset -c figs

# Figure 2: Alignment
# g.mapset -c test_alignment
# g.region n=-3227490 s=-3253500 w=7110 e=48960 res=90 -pa align=mask_ice_basin@MAR
# g.region save=test --o
g.region region=test@test_alignment
v.mkgrid map=fig2_outline grid=1,1 position=region 
eval $(g.region -pg)
topleft_fig2=$( echo ${w} ${n} )
text_fig2="Fig. 2"
g.region -d


g.region n=-2464500 s=-2557600 w=-282200 e=-119000 res=100 align=mask_ice_basin@MAR
g.region save=watson
v.mkgrid map=fig5_outline grid=1,1 position=region 
eval $(g.region -pg)
topleft_fig5=$( echo ${w} ${n} )
text_fig5="Fig. 5"
g.region -d


g.region region=BM_v_ArcticDEM@BM_v_ArcticDEM
v.mkgrid map=fig6_outline grid=1,1 position=region 
eval $(g.region -pg)
topleft_fig6=$( echo ${w} ${n} )
text_fig6="Fig. 6"
g.region -d


g.region n=-2200000 s=-2400000 w=-276000 e=-90000 res=100 -p # Jakobshavn
v.mkgrid map=fig7_outline grid=1,1 position=region 
eval $(g.region -pg)
topleft_fig7=$( echo ${w} ${n} )
text_fig7="Fig. 7"
g.region -d
#+END_SRC

#+NAME: fig_overview
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell* :export no
cat << EOF | ps.map -e input=- output=./fig/overview.eps --o
border n

paper a4
  end

vareas fig2_outline
  fcolor none
  lpos 0
  end

text ${topleft_fig2} ${text_fig2}
  fontsize 14
  ref lower left
  xoffset -5
  yoffset -5
  end

vareas fig5_outline
  fcolor none
  lpos 0
  end

text ${topleft_fig5} ${text_fig5}
  fontsize 14
  ref lower left
  xoffset -5
  yoffset -5
  end

vareas fig6_outline
  fcolor none
  lpos 0
  end

text ${topleft_fig6} ${text_fig6}
  fontsize 14
  ref lower left
  xoffset -5
  yoffset -5
  end

vareas fig7_outline
  fcolor none
  lpos 0
  end

text ${topleft_fig7} ${text_fig7}
  fontsize 14
  ref lower left
  xoffset -5
  yoffset -5
  end

# hatch fill
vareas basins@ice_surf
  # pat $GISBASE/etc/paint/patterns/diag_up.eps
  # scale 0.5
  # fcolor 55:126:184
  color 55:126:184
  # fcolor 166:206:227
  fcolor 240:240:240
  label Ice basin
  end

vareas basins@land_surf
  color 51:160:44
  fcolor 127:223:138
  label Land basin
  end

EOF
convert -trim -density 300 ./fig/overview.eps ./fig/overview.png
o ./fig/overview.png
#+END_SRC

#+RESULTS: fig_overview
#+begin_example

> > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > Scale set to 1 : 10967002
...
...
...
...
...
...
Reading text file ...
ps.map complete. PostScript file './fig/overview.eps' successfully written.
#+end_example


# #+ATTR_LATEX: :float wrap :placement [23]{l}{0.4\textwidth} :width 0.4\textwidth

#+NAME: fig:overview
#+ATTR_LATEX: :height 0.8\textheight :placement [!h]
#+CAPTION: Overview showing ice basins (blue) and land basins (green), and insets of Figures [[fig:coverage]], [[fig:watson_basins]], and [[fig:diff_land_surf_aDEM_BM3_jako]].
[[./fig/overview.png]]


** Coverage
:PROPERTIES:
:clearpage: t
:END:

#+NAME: fig:coverage
#+ATTR_LATEX: :width \textwidth :placement [!h]
#+CAPTION: Example of model (MAR) and basin misalignment (MAR ice over basin land, or MAR land over basin ice). See Sec. \ref{sec:methods:coverage}.
[[./fig/basin_MAR_align.png]]


** Annual Runoff
:PROPERTIES:
:clearpage: t
:END:


#+header: :eval no-export
#+BEGIN_SRC jupyter-python :session timeseries :exports none :results none

from matplotlib import rc
rc('font', size=12)
rc('text', usetex=False)
import datetime

import matplotlib.pyplot as plt

<<B2018>>

runoff = df_b2018.copy(deep=True)
runoff.loc[runoff.index[0] - datetime.timedelta(365)] = runoff.iloc[0]
runoff.sort_index(inplace=True)
runoff = runoff.shift(1, freq='Y')

fig = plt.figure(1, figsize=(5,4)) # w,h
fig.clf()
fig.set_tight_layout(True)
import matplotlib.gridspec as gridspec
gs = gridspec.GridSpec(10, 1) #w,h
ax = plt.subplot(gs[0:6,:])
axins = plt.subplot(gs[6:,:])


runoff[['MAR ice','RACMO ice','B2018 ice']].plot(ax=ax, 
                                         drawstyle='steps', 
                                         legend=False, 
                                         fontsize=12,
                                         figsize=(6,4))

runoff['MAR land'].plot(ax=ax,
                        drawstyle='steps', 
                        color=ax.lines[0].get_c(),
                        linestyle='--',
                        # legend=False,
                        use_index=True)
runoff['B2018 land'].plot(ax=ax,
                        drawstyle='steps', 
                        color=ax.lines[2].get_c(),
                        linestyle='--',
                        # legend=False,
                        use_index=True)

ax.fill_between(runoff.index, runoff['MAR ice']*0.925, runoff['MAR ice']*1.075,
                color=ax.lines[0].get_c(), alpha=0.25, step='pre')
ax.fill_between(runoff.index, runoff['MAR land']*0.925, runoff['MAR land']*1.075,
                color=ax.lines[0].get_c(), alpha=0.25, step='pre')
ax.fill_between(runoff.index, runoff['RACMO ice']*0.925, runoff['RACMO ice']*1.075,
                color=ax.lines[1].get_c(), alpha=0.25, step='pre')


# ax.legend(loc=4, fontsize=6)
legend = ax.legend(fontsize=8, loc=(0.0, -0.6), fancybox=False, frameon=False)
legend.remove()
axins.add_artist(legend)

# ax.set_ylim([0,800])
ax.set_xlabel("Time [Year]")
ax.set_ylabel("[km$^{3}$ yr$^{-1}$]")
ax.set_ylim([0,800])
ax.set_yticklabels(['0\n','200','400','600','800'])

### ZOOM

if 'MAR_daily' not in locals():
    ds_MAR = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')
    MAR_daily = ds_MAR['runoff']\
        .sum(dim='station')\
        .to_dataframe()\
        .rename({'runoff':'MAR'}, axis='columns') * 86400/1E9 # m^3/s -> km^3/day

    ds_RACMO = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_RACMO_*.nc', combine='by_coords')
    RACMO_daily = ds_RACMO['runoff']\
        .sum(dim='station')\
        .to_dataframe()\
        .rename({'runoff':'RACMO'}, axis='columns') * 86400/1E9 # m^3/s -> km^3/day

    b2018 = xr.open_mfdataset('/home/kdm/data/Bamber_2018/FWF17.v3_a.nc',
                              data_vars='minimal',
                              combine='by_coords')
    Bamber_monthly = (b2018['runoff_ice'] * b2018['LSMGr'])\
        .sum(dim=['X','Y'])\
        .to_series()\
        .rename('Bamber 2018') / 30 # monthly to daily


M1999 = MAR_daily[MAR_daily.index.year == 1999]
R1999 = RACMO_daily[RACMO_daily.index.year == 1999]
M1999.plot(ax=axins, 
           drawstyle='steps', 
           color=ax.lines[0].get_c(),
           legend=False,
           use_index=True)
R1999.plot(ax=axins, 
           drawstyle='steps', 
           color=ax.lines[1].get_c(),
           legend=False,
           use_index=True)

axins.fill_between(M1999.index, M1999.values.flatten()*0.925, M1999.values.flatten()*1.075,
                color=ax.lines[0].get_c(), alpha=0.25, step='pre')
axins.fill_between(R1999.index, R1999.values.flatten()*0.925, R1999.values.flatten()*1.075,
                color=ax.lines[1].get_c(), alpha=0.25, step='pre')

Bamber_monthly.loc['1998-12-01':'1999-12-01']\
    .resample('1M', loffset='1M').mean()\
                                  .plot(ax=axins, 
                                        drawstyle='steps', 
                                        color=ax.lines[2].get_c(),
                                        legend=False,
                                        use_index=True)

axins.set_xlabel("")
axins.set_ylim([0,10])
axins.set_ylabel("[km$^{3}$ d$^{-1}$]", labelpad=10)
axins.set_xlim(np.array(axins.get_xlim())-[0,31])

from adjust_spines import adjust_spines as adj
adj(axins, ['left','bottom'])
adj(ax, ['left','top'])

axins.tick_params(axis='x', which='minor', top=False)
axins.tick_params(axis='y', which='minor', bottom=False)

plt.savefig("./fig/timeseries.png", dpi=300, bbox_inches='tight')
#+END_SRC

# #+NAME: ts_svg2png
# #+BEGIN_SRC bash :results verbatim :eval yes :exports none
# inkscape -z ./fig/timeseries.svg -e ./fig/timeseries.png
# #+END_SRC

#+NAME: fig:annual_runoff
#+ATTR_LATEX: :width 0.9\textwidth :placement [!h]
#+CAPTION: Top panel: Annual Greenland ice sheet runoff from RACMO and MAR as calculated in this product, and B2018 citep:bamber_2018_freshwater. Dashed lines show runoff from land. Bottom panel: 1999 ice runoff at daily resolution (this) or monthly for B2018.
[[./fig/timeseries.png]]

** Watson runoff
:PROPERTIES:
:clearpage: t
:END:

*** Code                                                :noexport:

+ Manually pick the Watson outlet ID in QGIS to verify.
+ ID :: 114085

#+BEGIN_SRC jupyter-python :session fig_watson :exports results :results raw drawer :display text/org 
import numpy as np
import xarray as xr

OUTLET = 114085

ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')
margin_ids = ds.isel({'time':0})\
               .isel({'station':ds.coast_id[0,:] == OUTLET})\
               .station.values

# now open all the runoff data and extract the margin outlets
watson_ice = ds.sel(station=margin_ids)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()

ds = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
watson_land = ds.sel(station=OUTLET)\
                .to_dataframe()['runoff']\
                .groupby("time")\
                .sum()

watson = pd.DataFrame(index=watson_ice.index, data=watson_ice.values, columns=['MAR ice'])
watson['MAR land'] = watson_land.values

ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_RACMO_*.nc', combine='by_coords')
watson_ice = ds.sel(station=margin_ids)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()
watson_ice.name = 'RACMO ice'

watson = watson.merge(watson_ice, left_index=True, right_index=True)

watson['MAR runoff'] = watson['MAR ice'] + watson['MAR land']
watson['RACMO runoff'] = watson['RACMO ice']

# load Watson River data
w = pd.read_csv("/home/kdm/data/van_As_2018/Watson_discharge_day_v03.txt", sep="\s+",
                parse_dates=[[0,1,2]],
                index_col=0)\
      .drop(["DayOfYear", "DayOfCentury"], axis='columns')\
      .rename({"WaterFluxDiversOnly(m3/s)"         : "divers",
               "Uncertainty(m3/s)"                 : "divers_err",
               "WaterFluxDivers&Temperature(m3/s)" : "divers_t",
               "Uncertainty(m3/s).1"               : "divers_t_err",
               "WaterFluxCumulative(km3)"          : "cum",
               "Uncertainty(km3)"                  : "cum_err"}, 
              axis='columns')

watson['vanAs2018'] = w['divers_t']
watson['vanAs2018_min'] = w['divers_t'] - w['divers_t_err']
watson['vanAs2018_max'] = w['divers_t'] + w['divers_t_err']

# watson[watson.index.year > 2006].plot()

import matplotlib.pyplot as plt

ax = watson.plot(kind='scatter', x='vanAs2018', y='MAR runoff', 
                 xlim=[0,3000], ylim=[0,3000], 
                 xerr = w['divers_t_err']/2,
                 yerr = watson['MAR runoff']*0.15/2,
                 label='MAR',
                 color='k',
                 alpha=0.05)

watson.plot(ax=ax,
            kind='scatter', x='vanAs2018', y='RACMO runoff', 
            xlim=[0,3000], ylim=[0,3000], 
            xerr = w['divers_t_err']/2,
            yerr = watson['RACMO runoff']*0.15/2,
            label='RACMO',
            color='b',
            alpha=0.05)

ax.legend()
ax.plot([0,3000],[0,3000], 'k--', alpha=0.1)
ax.set_xlabel('Observed runoff (van As (2018)) [m$^3$ s$^{-1}$]')
ax.set_ylabel('Modeled runoff (this work) [m$^3$ s$^{-1}$]')

from adjust_spines import adjust_spines as adj
adj(ax, ['left','bottom'])

plt.savefig("./fig/watson_scatter.png", dpi=300, bbox_inches='tight')
#+END_SRC

#+RESULTS:

**** Add Basins to the south
#+BEGIN_SRC jupyter-python :session fig_watson :exports results :results raw drawer :display text/org 
import numpy as np
import xarray as xr

OUTLET = 114085

ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')
margin_ids = ds.isel({'time':0})\
               .isel({'station':ds.coast_id[0,:] == OUTLET})\
               .station.values

margin_ids = np.append(margin_ids, 58168)
margin_ids = np.append(margin_ids, 58207)

# now open all the runoff data and extract the margin outlets
watson_ice = ds.sel(station=margin_ids)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()


ds = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
watson_land = ds.sel(station=OUTLET)\
                .to_dataframe()['runoff']\
                .groupby("time")\
                .sum()

watson = pd.DataFrame(index=watson_ice.index, data=watson_ice.values, columns=['MAR ice'])
watson['MAR land'] = watson_land.values

ds = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_RACMO_*.nc', combine='by_coords')
watson_ice = ds.sel(station=margin_ids)\
               .to_dataframe()['runoff']\
               .groupby("time")\
               .sum()
watson_ice.name = 'RACMO ice'

watson = watson.merge(watson_ice, left_index=True, right_index=True)

watson['MAR runoff'] = watson['MAR ice'] + watson['MAR land']
watson['RACMO runoff'] = watson['RACMO ice']

# load Watson River data
w = pd.read_csv("/home/kdm/data/van_As_2018/Watson_discharge_day_v03.txt", sep="\s+",
                parse_dates=[[0,1,2]],
                index_col=0)\
      .drop(["DayOfYear", "DayOfCentury"], axis='columns')\
      .rename({"WaterFluxDiversOnly(m3/s)"         : "divers",
               "Uncertainty(m3/s)"                 : "divers_err",
               "WaterFluxDivers&Temperature(m3/s)" : "divers_t",
               "Uncertainty(m3/s).1"               : "divers_t_err",
               "WaterFluxCumulative(km3)"          : "cum",
               "Uncertainty(km3)"                  : "cum_err"}, 
              axis='columns')

watson['vanAs2018'] = w['divers_t']
watson['vanAs2018_min'] = w['divers_t'] - w['divers_t_err']
watson['vanAs2018_max'] = w['divers_t'] + w['divers_t_err']

watson[watson.index.year > 2006].plot()

import matplotlib.pyplot as plt
ax = watson.plot(kind='scatter', x='vanAs2018', y='MAR runoff', 
                 xlim=[0,3000], ylim=[0,3000], 
                 xerr = w['divers_t_err']/2,
                 yerr = watson['MAR runoff']*0.15/2,
                 label='MAR',
                 color='k',
                 alpha=0.05)

watson.plot(ax=ax,
            kind='scatter', x='vanAs2018', y='RACMO runoff', 
            xlim=[0,3000], ylim=[0,3000], 
            xerr = w['divers_t_err']/2,
            yerr = watson['RACMO runoff']*0.15/2,
            label='RACMO',
            color='b',
            alpha=0.05)

ax.legend()
ax.plot([0,3000],[0,3000], 'k--', alpha=0.1)
ax.set_xlabel('Observed runoff (van As (2018)) [m$^3$ s$^{-1}$]')
ax.set_ylabel('Modeled runoff (this work) [m$^3$ s$^{-1}$]')

from adjust_spines import adjust_spines as adj
adj(ax, ['left','bottom'])

plt.savefig("./fig/watson_scatter_basins_south.png", dpi=300, bbox_inches='tight')
#+END_SRC

#+RESULTS:


*** Figure                                                :ignore:

#+BEGIN_SRC bash :results verbatim
convert ./fig/watson_scatter.png \
	./fig/watson_scatter_basins_south.png \
	+append \
	./fig/watson_scatter_combine.png
#+END_SRC

#+RESULTS:


#+NAME: fig:vanAs_compare
#+ATTR_LATEX: :width 0.9\textwidth :placement [!h]
#+CAPTION: Comparison for Watson River basin runoff between citet:van-as_2018_reconstructing and this product (this product based on ArcticDEM basin in Fig. [[fig:watson_basins]]). Left panel is runoff from the Watson River basin as defined by ArcticDEM. Right panel is runoff from the Watson River basin plus the two large basins immediately to the south. MAR includes both ice and land contribution to the outlet while RACMO only includes ice contribution.
[[./fig/watson_scatter_combine.png]]


** Watson basins
:PROPERTIES:
:clearpage: t
:END:

*** Code                                                :noexport:
+ Find all basins upstream of Watson.
+ Watson River sample site located at "67.01 N by 50.68 W" according
  to citet:van-as_2018_reconstructing.

#+NAME: example_watson_basins
#+BEGIN_SRC bash :session ex_out_near_pt :exports results :results raw drawer :eval no-export :var mapset="watson_basins"  :session *freshwater-shell*
<<grass_init_mapset>>

# g.mapset -c watson_basins

echo "-50.68|67.01" | m.proj -i input=- | v.in.ascii input=- output=near

g.mapsets -l separator=newline | grep '^land_'
for mapset in $(g.mapsets -l separator=newline | grep '^land_'); do
cat=$(v.distance from=near to=outlets@${mapset} from_type=point to_type=point -p upload=cat --q --o \
      | tail -n1 \
      | cut -d"|" -f2)
v.extract input=basins@${mapset} where="cat == ${cat}" output=${mapset}
done
#+END_SRC

#+RESULTS: example_watson_basins
:results:

GRASS 7.4.0 (G):~/projects/freshwater > > > > > > > GRASS 7.4.0 (G):~/projects/freshwater > GRASS 7.4.0 (G):~/projects/freshwater > GRASS 7.4.0 (G):~/projects/freshwater > GRASS 7.4.0 (G):~/projects/freshwater > ERROR: option <output>: <near> exists. To overwrite, use the --overwrite flag
close failed in file object destructor:
sys.excepthook is missing
lost sys.stderr
GRASS 7.4.0 (G):~/projects/freshwater > Available mapsets:
[01;31m[Kland_[m[Ksub_BM3_100
[01;31m[Kland_[m[Ksub_BM3_80
[01;31m[Kland_[m[Ksub_BM3_90
[01;31m[Kland_[m[Ksurf
[01;31m[Kland_[m[Ksurf_BM3
> > > > Available mapsets:
: <land_sub_BM3_100> exists. To overwrite, use the --overwrite flag
: <land_sub_BM3_80> exists. To overwrite, use the --overwrite flag
: <land_sub_BM3_90> exists. To overwrite, use the --overwrite flag
: <land_surf> exists. To overwrite, use the --overwrite flag
: <land_surf_BM3> exists. To overwrite, use the --overwrite flag
:end:

#+BEGIN_SRC bash :results none :session *freshwater-shell* :eval no-export

g.region n=-2387800 s=-2717400 w=-398900 e=88300 res=100 -p # Watson Basin big
g.region n=-2464500 s=-2557600 w=-282200 e=-119000 res=100 -p # Watson local
g.region save=watson --o

r.mapcalc "mask_o_l_i = mask_o_l_i@ArcticDEM"
cat << EOF | r.colors map=mask_o_l_i rules=-
1 166:206:227
2 127:223:138
3 250:250:250
EOF


#   fcolor 55:126:184
#   color 55:126:184
#   label "Ice Basin"
#   end

# vareas basins@ice_surf
#   color 55:126:184
#   fcolor 166:206:227
#   end

# vareas basins@land_surf
#   color 51:160:44
#   fcolor 127:223:138
#   label "Land Basin"
#   end

# # crosses on land
# vpoints MAR_grid_land_point
#   type point
#   color 51:160:44
#   scale 3





# contour lines
r.mask mask_o_l_i@ArcticDEM maskcats=3 --o
# g.region res=1000
r.contour input=z_s@ArcticDEM output=z_s levels=1000,1500,2000,2500
# v.label lables=./tmp/z_s_labels
# g.region res=100
r.mask -r

#+END_SRC

#+BEGIN_SRC bash :results verbatim :session *freshwater-shell* :eval no-export :results none

fname=watson_land_surf
# g.region res=100 -p
cat << EOF | ps.map input=- output=./tmp/${fname}.ps --o

border n
paper a3
  end

raster mask_o_l_i

# this shows ice basin outlines over the filled patterned land basins on ice
vareas basins@ice_surf
  label 
  color gray
  fcolor none
  width 0.1
  end

vlines z_s
  label Elevation (1000,1500)
  type line
  style 000111
  color gray
  width 0.1
  end

vareas land_surf_BM3
  label BedMachine surface
  color black
  # fcolor 255:255:255
  pat $GISBASE/etc/paint/patterns/diag_up.eps
  scale 1
  end


vareas land_sub_BM3_100
  label BedMachine subglacial k=1
  color black
  # fcolor 255:255:255
  pat $GISBASE/etc/paint/patterns/diag_down.eps
  scale 1
  end

vareas land_sub_BM3_90
  label BedMachine subglacial k=0.9
  color black
  # fcolor 255:255:255
  pat $GISBASE/etc/paint/patterns/horiz_line.eps
  scale 1
  end

vareas land_sub_BM3_80
  label BedMachine subglacial k=0.8
  color black
  # fcolor 255:255:255
  pat $GISBASE/etc/paint/patterns/vert_line.eps
  scale 1
  end

vareas land_surf
  color black
  fcolor gray
  width 1
  label ArcticDEM
  end

vpoints near
  #symbol mills/windmill
  label Outlet (ArcticDEM)
  color orange
  size 9
  end

vareas basins@ice_surf
  label Ice basins
  color gray
  fcolor 250:250:250
  width 0.1
  end

vareas basins@land_surf
  label Land basins
  color gray
  fcolor 127:223:138
  width 0.3
  end

vlegend
  where 7.5 1.1
  font Courier
  fontsize 12
  border 0:0:0
  end

scalebar s
  where 1.5 1.5
  length 10
  units kilometers
  font Courier
  fontsize 12
  segment 10
  numbers 10
  height 0.09
  end

																	
EOF
# g.region region=watson
convert -trim -transparent white ./tmp/${fname}.ps -density 300 ./fig/${fname}.png
# o ./fig/${fname}.png
#+END_SRC

*** Figure                                                :ignore:

#+NAME: fig:watson_basins
#+ATTR_LATEX: :width \textwidth :placement [!h]
#+CAPTION: Watson basins based on different routing assumptions. ArcticDEM basin used for "this work" in Fig. [[fig:vanAs_compare]].
[[./fig/watson_land_surf.png]]


** COMMENT ArcticDEM v BedMachine
:PROPERTIES:
:clearpage: t
:END:


#+NAME: BM_v_ArcticDEM
#+BEGIN_SRC bash :results none :exports none :eval no :session *freshwater-shell*
g.mapset -c BM_v_ArcticDEM
g.region n=-2726100 s=-2809200 w=-364800 e=-281500 res=100
g.region save=BM_v_ArcticDEM

MAPSET=land_surf # ArcticDEM
cat << EOF | ps.map -e input=- output=./tmp/BM_v_ArcticDEM_${MAPSET}.eps --o
<<BM_v_ArcticDEM_psmap>>

scalebar f
   length 10
   units kilometers
   segment 2
   where 1 2
   fontsize 14
   end
EOF
convert -trim ./tmp/BM_v_ArcticDEM_${MAPSET}.{eps,png}


MAPSET=land_surf_BM3 # BedMachine V3
cat << EOF | ps.map -e input=- output=./tmp/BM_v_ArcticDEM_${MAPSET}.eps --o
<<BM_v_ArcticDEM_psmap>>
EOF
convert -trim ./tmp/BM_v_ArcticDEM_${MAPSET}.{eps,png}

convert ./tmp/BM_v_ArcticDEM_land_surf.png \
	./tmp/BM_v_ArcticDEM_land_surf_BM3.png \
	 +append \
	 ./tmp/BM_v_ArcticDEM.png

o ./tmp/BM_v_ArcticDEM.png
#+END_SRC

#+NAME: BM_v_ArcticDEM_psmap
#+BEGIN_SRC bash
border n
paper a4
  end

vlines streams@${MAPSET}
  type line
  color 0:0:0
  where hack = 1
  width 4
  end

vlines streams@${MAPSET}
  type line
  color 0:0:0
  where hack = 2
  width 2
  end

vlines streams@${MAPSET}
  type line
  color 0:0:0
  where hack = 3
  width 1
  end

vpoints outlets@${MAPSET}
  type point
  color 51:160:44
  fcolor 51:160:44 # 127:223:138
  end

vareas basins@${MAPSET}
  color 128:128:128
  fcolor none
  # where area > 300000000
  width 1
  end

vareas basins@${MAPSET}
  # fcolor 127:223:138
  # color 127:223:138
  # fcolor 127:223:138
  fcolor none
  # color 127:223:138
  color none
  lpos 0
  end
#+END_SRC

#+RESULTS: BM_v_ArcticDEM_psmap

#+NAME: fig:BM3_v_aDEM
#+ATTR_LATEX: :width 0.8\textwidth :placement [!h]
#+CAPTION: ArcticDEM v BedMachine land basin. Basin outline in gray. Streams shown in black, with stream order Hack citep:jasiewicz_2011_hortonian number 1 thick, 2 medium, and 3 thin. Left panel is ArcticDEM, right panel is BedMachine v3. Note large basin in center of ArcticDEM left panel draining to the coastal sea outside the fjord. That same basin is split in BedMachine right panel, with the majority of it draining inside the fjord
[[./tmp/BM_v_ArcticDEM.png]]


** Change in Outlet
:PROPERTIES:
:clearpage: t
:END:

#+NAME: fig:diff_land_surf_aDEM_BM3_jako
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Change in outlet location between baseline ArcticDEM surface routing and BedMachine v3 surface routing is shown for every grid cell. Region is zoomed in near Sermeq Kujalleq (Jakobshavn Isbræ). White-and-black contour line shows 2000 m elevation, above which little runoff occurs. 
[[./fig/diff_land_surf_ArcticDEM_surfBM3_class_zoom_jako.png]]

** GEM Basin
:PROPERTIES:
:clearpage: t
:END:

#+NAME: fig:GEM_map_Zackenberg
#+ATTR_LATEX: :width 0.9\textwidth :placement [!h]
#+CAPTION: Zackenberg basin for GEM outlet. Note two small glaciers without correstponding MAR or RACMO ice cells. See Fig. \ref{fig:GEM_ts} for comparisons between GEM and MAR discharge at this location. Also visible is basin artifact at southern-most portion of basin. Because basins < 1 km^{2} are absorbed into their largest neighbor, here small basins clearly outside the basin (south of the coastal mountain range) are absorbed into the basin.
[[./fig/GEM_Zackenberg.png]]

#+NAME: fig:GEM_map_Rode
#+ATTR_LATEX: :width 0.8\textwidth :placement [!h]
#+CAPTION: Röde Elve basin for GEM outlet. See figures \ref{fig:GEM_ts} and \ref{fig:GEM_scatter} for comparisons between GEM and MAR discharge at this location.
[[./fig/GEM_RodeElv.png]]

#+NAME: fig:GEM_map_others
#+ATTR_LATEX: :width 0.8\textwidth :placement [!h]
#+CAPTION: GEM basins for Kingigtorssuaq, Kobbefjord, Oriartorfik, and Teqinngalip outlets. Note that except for one RCM ice cell, no ice basins have RCM runoff estimates. Furthemore, at the eastern edge of the image RCM ice cells exist where no ice basin exists (that RCM runoff is discarded). See figures \ref{fig:GEM_ts} and \ref{fig:GEM_scatter} for comparisons between GEM and MAR discharge at these location.
[[./fig/GEM_OtherFour.png]]

#+NAME: fig:GEM_ts
#+ATTR_LATEX: :width 0.9\textwidth :placement [!h]
#+CAPTION: Time series of GEM observed MAR ice and land runoff for basins shown in Figures \ref{fig:GEM_map_Zackenberg}, \ref{fig:GEM_map_Rode}, and \ref{fig:GEM_map_others}. Only 2017 shown because that is the only year  where data exists at Röde Elv.
[[./fig/GEM_ts_doy.pdf]]

#+NAME: fig:GEM_scatter
#+ATTR_LATEX: :width 0.9\textwidth :placement [!h]
#+CAPTION: Scatter plot of 10-day averages of GEM and MAR runoff for basins shown in Figures \ref{fig:GEM_map_Zackenberg}, \ref{fig:GEM_map_Rode}, and \ref{fig:GEM_map_others}. Data for all availabel years at all stations are shown.
[[./fig/GEM_scatter.png]]

*** Code for Figures                                    :noexport:

# # from manual inspection of basins + GEM locations in QGIS
# GEM_meta = pd.Series(index=GEM.columns)
# GEM_meta['Kobbefjord']     = 141100 
# GEM_meta['Oriartorfik']    = 140660
# GEM_meta['Teqinngalip']    = 140669
# GEM_meta['Kingigtorssuaq'] = 140937
# GEM_meta['Röde_Elv']       = 91818
# GEM_meta['Zackenberg']      = 49123


**** Zackenberg 
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*
g.mapset -c GEM_figs_Zackenberg

g.region n=-1516500 s=-1554200 w=663000 e=713100 res=1000 -pa
g.region n=n+10000 s=s-10000 w=w-10000 e=e+10000 -pa
g.region save=Zackenberg

# vector crop
v.in.region output=region 

# Land basin outline
v.overlay ainput=region binput=basins@land_surf operator=and output=basins_land
v.overlay ainput=region binput=basins@ice_surf operator=and output=basins_ice

outlet_ID=49123
v.extract input=basins_land where="b_cat == ${outlet_ID}" output=basins_land_this
v.select ainput=outlets@land_surf atype=point binput=basins_land_this operator=overlap output=outlets_land_this
v.select ainput=streams@land_surf atype=line binput=basins_land_this operator=overlap output=streams_land_this

# v.overlay ainput=streams@ice_surf atype=line binput=basins_ice_this operator=and output=streams_ice_this
v.select ainput=outlets@ice_surf atype=point binput=basins_ice_this operator=overlap output=outlets_ice_this
v.select ainput=streams@ice_surf atype=line binput=basins_ice_this operator=overlap output=streams_ice_this

ice_basin_IDs=$(grep ,${outlet_ID}, ./freshwater/ice_surf/outlets.csv | cut -d, -f1 | tr '\n' ',')
v.extract input=basins@ice_surf cats=${ice_basin_IDs} output=basins_ice_this
# v.overlay ainput=streams@land_surf atype=line binput=basins_land_this operator=and output=streams_ice_this

r.to.vect input=mask_ice_MAR@MAR output=MAR_ice type=area
r.to.vect input=mask_land_MAR@MAR output=MAR_land type=area
r.to.vect input=mask_ice_RACMO@RACMO output=RACMO_ice type=area


### Basemap
g.region res=15
r.mapcalc "r = rgb.1@NSIDC_0713"
r.mapcalc "g = rgb.2@NSIDC_0713"
r.mapcalc "b = rgb.3@NSIDC_0713"
i.colors.enhance -p red=r green=g blue=b strength=93
g.region region=Zackenberg -p
#+END_SRC

**** Röde Elv
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*
g.mapset -c GEM_figs_RodeElv

g.region n=-2238420 s=-2253255 w=-343384 e=-328521 res=1000 -pa
g.region n=n+10000 s=s-10000 w=w-10000 e=e+10000 -pa
g.region save=RodeElv

# vector crop
v.in.region output=region 

# Land basin outline
v.overlay ainput=region binput=basins@land_surf operator=and output=basins_land
v.overlay ainput=region binput=basins@ice_surf operator=and output=basins_ice

outlet_ID=91818
v.extract input=basins_land where="b_cat == ${outlet_ID}" output=basins_land_this
v.select ainput=outlets@land_surf atype=point binput=basins_land_this operator=overlap output=outlets_land_this
v.select ainput=streams@land_surf atype=line binput=basins_land_this operator=overlap output=streams_land_this

v.select ainput=outlets@ice_surf atype=point binput=basins_ice_this operator=overlap output=outlets_ice_this
v.select ainput=streams@ice_surf atype=line binput=basins_ice_this operator=overlap output=streams_ice_this


ice_basin_IDs=$(grep ,${outlet_ID}, ./freshwater/ice_surf/outlets.csv | cut -d, -f1 | tr '\n' ',')
v.extract input=basins@ice_surf cats=${ice_basin_IDs} output=basins_ice_this
# v.overlay ainput=streams@land_surf atype=line binput=basins_land_this operator=and output=streams_ice_this

r.to.vect input=mask_ice_MAR@MAR output=MAR_ice type=area
r.to.vect input=mask_land_MAR@MAR output=MAR_land type=area
r.to.vect input=mask_ice_RACMO@RACMO output=RACMO_ice type=area


### Basemap
g.region res=15
r.mapcalc "r = rgb.1@NSIDC_0713"
r.mapcalc "g = rgb.2@NSIDC_0713"
r.mapcalc "b = rgb.3@NSIDC_0713"
i.colors.enhance -p red=r green=g blue=b strength=95
g.region region=RodeElv -p
#+END_SRC

**** Other Four
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*
g.mapset -c GEM_figs_OtherFour

g.region n=-2819615 s=-2839241 w=-331095 e=-311430 res=1000 -pa
g.region n=n+10000 s=s-10000 w=w-10000 e=e+10000 -pa
g.region save=OtherFour

# vector crop
v.in.region output=region 

# Land basin outline
v.overlay ainput=region binput=basins@land_surf operator=and output=basins_land
v.overlay ainput=region binput=basins@ice_surf operator=and output=basins_ice

# GEM_meta['Kobbefjord']     = 141100 
# GEM_meta['Oriartorfik']    = 140660
# GEM_meta['Teqinngalip']    = 140669
# GEM_meta['Kingigtorssuaq'] = 140937

outlet_IDs=141100,140660,140669,140937
v.extract input=basins_land where="(b_cat == 141100) OR (b_cat == 140660) OR (b_cat == 140669) OR (b_cat == 140937)" output=basins_land_this
v.select ainput=outlets@land_surf atype=point binput=basins_land_this operator=overlap output=outlets_land_this
v.select ainput=streams@land_surf atype=line binput=basins_land_this operator=overlap output=streams_land_this

v.select ainput=outlets@ice_surf atype=point binput=basins_ice_this operator=overlap output=outlets_ice_this
v.select ainput=streams@ice_surf atype=line binput=basins_ice_this operator=overlap output=streams_ice_this

ice_basin_IDs=$(grep -E '141100|140660|140669|140937' ./freshwater/ice_surf/outlets.csv | cut -d, -f1 | tr '\n' ',')
v.extract input=basins@ice_surf cats=${ice_basin_IDs} output=basins_ice_this
# v.overlay ainput=streams@land_surf atype=line binput=basins_land_this operator=and output=streams_ice_this

r.to.vect input=mask_ice_MAR@MAR output=MAR_ice type=area
r.to.vect input=mask_land_MAR@MAR output=MAR_land type=area
r.to.vect input=mask_ice_RACMO@RACMO output=RACMO_ice type=area


### Basemap
g.region res=15
r.mapcalc "r = rgb.1@NSIDC_0713"
r.mapcalc "g = rgb.2@NSIDC_0713"
r.mapcalc "b = rgb.3@NSIDC_0713"
i.colors.enhance -p red=r green=g blue=b strength=95
g.region region=OtherFour -p
#+END_SRC

**** PSMAP
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*

for mapset in GEM_figs_Zackenberg GEM_figs_RodeElv GEM_figs_OtherFour; do
# for mapset in $(echo GEM_figs_OtherFour); do
  region="${mapset##*_}"
  g.mapset ${mapset}
  g.region vector=basins_land_this
  g.region e=e+1000 w=w-1000 n=n+1000 s=s-1000
  g.region res=15

  scalexy="1 1"; legendxy="1 1"
  if [[ ${region} == "Zackenberg" ]]; then scalexy="1.0 1.5"; legendxy="5.8 4.0"; fi
  if [[ ${region} == "RodeElv" ]]; then scalexy="2 1.5"; legendxy="5.5 7.5"; fi
  if [[ ${region} == "OtherFour" ]]; then scalexy="2 1.5"; legendxy="0.75 4.01"; fi
  
cat << EOF | ps.map -e input=- output=./fig/GEM_${region}.eps --o
<<GEM_basins_psmap>>
EOF

  convert -trim -density 300 ./fig/GEM_${region}.eps ./fig/GEM_${region}.png
  o ./fig/GEM_${region}.png
done
#+END_SRC

| Color       |   R |   G |   B | hex     |
|-------------+-----+-----+-----+---------|
| light blue  | 166 | 206 | 227 | #a6cee3 |
| dark blue   |  31 | 120 | 180 | #1f78b4 |
| light green | 178 | 223 | 138 | #b2df8a |
| dark green  |  51 | 160 |  44 | #33a02c |
| pink        | 251 | 154 | 153 | #fb9a99 |
| red         | 227 |  26 |  28 | #e31a1c |
| pale orange | 253 | 191 | 111 | #fdbf6f |
| orange      | 255 | 127 |   0 | #ff7f00 |

#+NAME: GEM_basins_psmap
#+BEGIN_SRC bash :results verbatim :tangle no
border n

paper a4
  end

vareas basins_land_this
  color 51:160:44
  fcolor none
  label Land basin
  end

vareas basins_ice_this
  color 31:120:180
  fcolor none
  label Ice basins
  end

vlines streams_land_this
  color 178:223:138
  # lpos 0
  label Streams
  end

vpoints outlets_ice_this
  fcolor 255:127:0
  # fcolor white
  color none
  # symbol basic/box
  label Outlets
  size 5
  end

vpoints outlets_land_this
  # color 51:160:44
  fcolor 255:127:0
  color none
  size 5
  lpos 0
  end

vpoints GEM@GEM
  type point
  color 255:127:0
  fcolor none
  label GEM station
  end

vareas MAR_ice
  color 126:206:227
  pat $GISBASE/etc/paint/patterns/diag_down.eps
  scale 1
  fcolor 126:206:227
  width 1
  label RCM ice
  end

# vareas RACMO_ice
#   color 126:206:227
#   pat $GISBASE/etc/paint/patterns/diag_up.eps
#   scale 1
#   fcolor 126:206:227
#   width 1
#   label RACMO ice
#   end

rgb r g b

vlegend
  where ${legendxy}
  fontsize 14
  end

scalebar f
   length 4
   units kilometers
   segment 2
   where ${scalexy}
   fontsize 12
   end
#+END_SRC

#+RESULTS: GEM_basins_psmap

** Qaanaaq


#+NAME: fig:map_Qaanaaq
#+ATTR_LATEX: :width 0.8\textwidth :placement [!h]
#+CAPTION: Plan view of Qaanaaq basin. Note that MAR ice cells only cover ~1 % of ice basin, while RACMO ice cells cover ~90 % of ice basin. See Figure \ref{fig:ts_Qaanaaq} for runoff data from this basin.
[[./fig/Qaanaaq.png]]

#+NAME: fig:ts_Qaanaaq
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Time series of observed and modeled runoff at Qaanaaq basin outlet (see Figure \ref{fig:map_Qaanaaq}). Displayed uncertainty is 9 % for observations and 15 % for RCMs.
[[./fig/Qaanaaq_ts.png]]

*** Code for Figures                                    :noexport:

lat: 77.475273975
lon: -69.303039228

ID: 33133

#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*
g.mapset -c GEM_figs_Qaanaaq

g.region w=-562213 s=-1243283 e=-549609 n=-1235773 res=1000 -pa
g.region n=n+10000 s=s-10000 w=w-10000 e=e+10000 -pa
g.region save=Qaanaaq

# vector crop
v.in.region output=region 

m.proj -i coordinates=-69.303039228,77.475273975 | v.in.ascii input=- output=qaanaaq_point

# Land basin outline
v.overlay ainput=region binput=basins@land_surf operator=and output=basins_land
v.overlay ainput=region binput=basins@ice_surf operator=and output=basins_ice

outlet_ID=33133
v.extract input=basins_land where="b_cat == ${outlet_ID}" output=basins_land_this
v.select ainput=outlets@land_surf atype=point binput=basins_land_this operator=overlap output=outlets_land_this
v.select ainput=streams@land_surf atype=line binput=basins_land_this operator=overlap output=streams_land_this

# v.overlay ainput=streams@ice_surf atype=line binput=basins_ice_this operator=and output=streams_ice_this

ice_basin_IDs=$(grep ,${outlet_ID}, ./freshwater/ice_surf/outlets.csv | cut -d, -f1 | tr '\n' ',')
v.extract input=basins@ice_surf cats=${ice_basin_IDs} output=basins_ice_this
# v.overlay ainput=streams@land_surf atype=line binput=basins_land_this operator=and output=streams_ice_this
v.select ainput=outlets@ice_surf atype=point binput=basins_ice_this operator=overlap output=outlets_ice_this
v.select ainput=streams@ice_surf atype=line binput=basins_ice_this operator=overlap output=streams_ice_this

r.to.vect input=mask_ice_MAR@MAR output=MAR_ice type=area
r.to.vect input=mask_land_MAR@MAR output=MAR_land type=area
r.to.vect input=mask_ice_RACMO@RACMO output=RACMO_ice type=area


### Basemap
g.region res=15
r.mapcalc "r = rgb.1@NSIDC_0713"
r.mapcalc "g = rgb.2@NSIDC_0713"
r.mapcalc "b = rgb.3@NSIDC_0713"
i.colors.enhance -p red=r green=g blue=b strength=93
g.region region=Qaanaaq -p
#+END_SRC

**** PSMAP
#+BEGIN_SRC bash :results verbatim :session *freshwater-shell*

for mapset in $(echo GEM_figs_Qaanaaq); do
  region="${mapset##*_}"
  g.mapset ${mapset}
  g.region vector=basins_land_this
  g.region e=e+1000 w=w-1000 n=n+1000 s=s-1000
  g.region res=15

  scalexy="3.3 5.5"; legendxy="0.8 1.2"
  if [[ ${region} == "Zackenberg" ]]; then scalexy="1 1.5"; legendxy="5.8 4.0"; fi
  
cat << EOF | ps.map -e input=- output=./fig/${region}.eps --o
<<Qaanaaq_basins_psmap>>
EOF

  convert -trim -density 300 ./fig/${region}.eps ./fig/${region}.png
  o ./fig/${region}.png
done
#+END_SRC

#+NAME: Qaanaaq_basins_psmap
#+BEGIN_SRC bash :results verbatim :tangle no
border n

paper a4
  end

vareas basins_land_this
  color 51:160:44
  fcolor none
  label Land basin
  end

vareas basins_ice_this
  color 31:120:180
  fcolor none
  label Ice basins
  end

vlines streams_land_this
  color 178:223:138
  # lpos 0
  label Streams
  end

vpoints outlets_ice_this
  fcolor 255:127:0
  # fcolor white
  color none
  # symbol basic/box
  label Outlets
  size 5
  end

vpoints outlets_land_this
  # color 51:160:44
  fcolor 255:127:0
  color none
  size 5
  lpos 0
  end

vpoints qaanaaq_point
  type point
  color 255:127:0
  fcolor none
  label Station
  end

vareas MAR_ice
  color 126:206:227
  pat $GISBASE/etc/paint/patterns/diag_down.eps
  scale 1
  fcolor 126:206:227
  width 1
  label MAR ice
  end

vareas RACMO_ice
  color 126:206:227
  pat $GISBASE/etc/paint/patterns/diag_up.eps
  scale 1
  fcolor 126:206:227
  width 1
  label RACMO ice
  end

rgb r g b

vlegend
  where ${legendxy}
  fontsize 14
  end

scalebar f
   length 4
   units kilometers
   segment 2
   where ${scalexy}
   fontsize 12
   end
#+END_SRC

**** Plot
#+NAME: Qaanaaq_compare
#+BEGIN_SRC jupyter-python :session Qaanaaq :exports results :results raw drawer
import numpy as np
import pandas as pd
import xarray as xr

obs = pd.read_csv("/home/kdm/data.me/qaanaaq/discharge2017.txt", index_col=0, parse_dates=True)
tmp = pd.read_csv("/home/kdm/data.me/qaanaaq/discharge2018.txt", index_col=0, parse_dates=True)
obs = pd.concat((obs,tmp))
tmp = pd.read_csv("/home/kdm/data.me/qaanaaq/discharge2019.txt", index_col=0, parse_dates=True)
obs = pd.concat((obs,tmp))

ds_land = xr.open_mfdataset('./freshwater/runoff/coast/runoff_land_MAR_*.nc', combine='by_coords')
ds_ice = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_MAR_*.nc', combine='by_coords')
if 'MAR' not in locals():
    MAR = pd.DataFrame(index=obs.index, columns=['ice'])#,'land'])
    MAR['land'] = ds_land.sel(station=33133).to_dataframe()['runoff']
    MAR['ice'] = ds_ice.sel(station=23764).to_dataframe()['runoff']
    MAR.dropna(inplace=True)
    # MAR = MAR.sum(axis='columns')
    MAR.name = "MAR"

ds_ice = xr.open_mfdataset('./freshwater/runoff/margin/runoff_ice_RACMO_*.nc', combine='by_coords')
if 'RACMO' not in locals():
    RACMO = pd.DataFrame(index=obs.index, columns=['ice'])
    RACMO['ice'] = ds_ice.sel(station=23764).to_dataframe()['runoff']
    RACMO.dropna(inplace=True)
    RACMO = RACMO.sum(axis='columns')
    RACMO.name = "RACMO"

from matplotlib import rc
rc('font', size=12)
rc('text', usetex=False)
# matplotlib.pyplot.xkcd()

C_darkblue="#1f78b4"
C_lightgreen="#b2df8"
C_darkgreen="#33a02c"
C_red="#e31a1c"
C_orange="#fdbf6f"

import matplotlib.pyplot as plt
# plt.close(1)
fig = plt.figure(1, figsize=(5,4)) # w,h
fig.clf()
fig.set_tight_layout(True)
# import matplotlib.gridspec as gridspec
# gs = gridspec.GridSpec(3, 2) #w,h
# ax = plt.subplot(gs[:,:])
ax = fig.add_subplot(1,1,1)

obs_MAR = pd.DataFrame(obs)\
        .rename({'Discharge':'Observed'}, axis='columns')\
        .merge(MAR, left_index=True, right_index=True, how='inner')
obs_RACMO = pd.DataFrame(obs)\
              .rename({'Discharge':'Observed'}, axis='columns')\
              .merge(RACMO, left_index=True, right_index=True, how='inner')

# obs_MAR.plot(kind='scatter', x='Observed', y='ice', alpha = 0.9,ax=ax, label='MAR')
# obs_RACMO.plot(kind='scatter', x='Observed', y='RACMO', alpha=0.9, ax=ax, marker='s', color='k', label='RACMO')

# # pd.DataFrame(obs_MAR.sum()).T.plot(kind='scatter', x='Obs', y='MAR', alpha = 0.9,ax=ax, label='MAR')
# # pd.DataFrame(obs_RACMO.sum()).T.plot(kind='scatter', x='Obs', y='RACMO', alpha = 0.9,ax=ax, marker='s', color='k', label='RACMO')

# ax.plot([0,np.max([ax.get_xlim()[1],ax.get_ylim()[1]])],
#         [0,np.max([ax.get_xlim()[1],ax.get_ylim()[1]])],
#         'k--')

# ax.set_xlabel('Observed Runoff [m$^{3}$ s$^{-1}$]')
# ax.set_ylabel('RACMO & MAR Runoff [m$^{3}$ s$^{-1}$]')

# plt.savefig('./fig/Qaanaaq_scatter.png', transparent=False, bbox_inches='tight', dpi=96)

obs_MAR_RACMO = obs_MAR.merge(obs_RACMO['RACMO'], left_index=True, right_index=True)
ax = obs_MAR_RACMO[['Observed','ice','RACMO']].plot(drawstyle='steps', 
                        color=[C_darkblue,C_darkgreen,C_orange])
obs_MAR_RACMO[['land']].plot(ax=ax,
                             drawstyle='steps', 
                             linestyle='--',
                             color=C_darkgreen)

ax.fill_between(obs_MAR_RACMO.index, 
                obs_MAR_RACMO['Observed']*0.955, # 9 % according to Ken Kondo email
                obs_MAR_RACMO['Observed']*1.045,
                color=C_darkblue, step='pre', alpha=0.25)
ax.fill_between(obs_MAR_RACMO.index, 
                obs_MAR_RACMO['ice']*0.925, # 15 % according to Xavier
                obs_MAR_RACMO['ice']*1.075,
                color=C_darkgreen, step='pre', alpha=0.25)
ax.fill_between(obs_MAR_RACMO.index, 
                obs_MAR_RACMO['land']*0.925, # 15 % according to Xavier
                obs_MAR_RACMO['land']*1.075,
                linestyle='--',
                color=C_darkgreen, step='pre', alpha=0.25)
ax.fill_between(obs_MAR_RACMO.index, 
                obs_MAR_RACMO['RACMO']*0.925, # 15 % ?
                obs_MAR_RACMO['RACMO']*1.075,
                color=C_orange, step='pre', alpha=0.25)

ax.legend(['Observed','MAR ice','RACMO','MAR land'])

ax.set_ylabel('Runoff [m$^{3}$ s$^{-1}$]')

from adjust_spines import adjust_spines as adj
adj(ax, ['left','bottom'])

plt.savefig('./fig/Qaanaaq_ts.png', transparent=False, bbox_inches='tight', dpi=150)

#+END_SRC

#+RESULTS: Qaanaaq_compare

* Appendix                                                :ignore:
#+LaTeX: \appendix
#+LaTeX: \clearpage

** Software
:PROPERTIES:
:clearpage: t
:END:

This work was performed using only open-source software, primarily =GRASS GIS= citep:neteler_2012_GRASS and =Python= citep:van-rossum_1995_python, in particular the =Jupyter= citep:kluyver_2016_jupyter, =pandas= citep:mckinney_2010_pandas, =numpy= citep:oliphant_2006_numpy, =statsmodel= citep:seabold_2010_statsmodels, =x-array= citep:hoyer_2017_xarray, and =Matplotlib= citep:hunter_2007_matplotlib packages. The entire work was performed in =Emacs= citep:stallman_1981_emacs using =Org Mode= citep:schulte_2012_a-multi-language. The =parallel= citep:tange_2011_parallel tool was used to speed up processing. We used =proj4= citep:proj4 to compute the errors in the EPSG 3413 projection. All code used in this work is available in the Supplemental Online Material.


** Changing basins with changing routing schemes
:PROPERTIES:
:clearpage: t
:END:

# #+NAME: fig:diff_land_surf_aDEM_BM3_jako
# #+ATTR_LATEX: 0.8:width \textwidth :placement [!h]
# #+CAPTION: Change in outlet location between baseline ArcticDEM surface routing and BedMachine v3 surface routing is shown for every grid cell. Region is zoomed in near Sermeq Kujalleq (Jakobshavn Isbræ). Contour line shows 2000 m elevation. 
# [[./fig/diff_land_surf_ArcticDEM_surfBM3_class_zoom_jako.png]]

#+NAME: fig:outlet_change_1
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:diff_land_surf_aDEM_BM3_jako]] but for all of Greenland not zoomed in.
[[./fig/diff_land_surf_ArcticDEM_surfBM3_class.png]]

#+NAME: fig:outlet_change_11
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_1]], but comparing BedMachine surface with Bedmachine 100 % subglacial pressure.
[[./fig/diff_land_surf_sub_BM3_100_class.png]]

#+NAME: fig:outlet_change_12
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_1]], but with 90 % subglacial pressure.
[[./fig/diff_land_surf_sub_BM3_90_class.png]]

#+NAME: fig:outlet_change_13
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_1]], but with 80 % subglacial pressure.
[[./fig/diff_land_surf_sub_BM3_80_class.png]]

#+NAME: fig:outlet_change_2
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_1]] but comparing ice margin outlet change, not coastal outlet change.
[[./fig/diff_ice_surf_ArcticDEM_surfBM3_class.png]]

#+NAME: fig:outlet_change_21
#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_11]], but ice margin outlet rather than coastal outlet. Same as Fig [[fig:outlet_change_2]] but comparing BedMachine surface with BedMachine 100 % subglacial pressure.
[[./fig/diff_ice_surf_sub_BM3_100_class.png]]

#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_12]], but ice margin outlet rather than coastal outlet. Same as Fig [[fig:outlet_change_2]] but with 90 % subglacial pressure.
[[./fig/diff_ice_surf_sub_BM3_90_class.png]]

#+ATTR_LATEX: :width 0.5\textwidth :placement [!h]
#+CAPTION: Same as Fig. [[fig:outlet_change_13]], but ice margin outlet rather than coastal outlet. Same as Fig [[fig:outlet_change_2]] but with 80 % subglacial pressure.
[[./fig/diff_ice_surf_sub_BM3_80_class.png]]



* Meta                                                  :noexport:
** Set up git

This sets up gitinfo2 so that the git version number and branch are included in any PDFs generated from this document.

#+BEGIN_SRC bash :cmdline -i :results verbatim :eval no
git init
SRC=~/Documents/templates/gitinfo2.script
for f in `echo 'commit' 'merge' 'checkout'`; do
    DEST=./.git/hooks/post-${f}
    cp $SRC $DEST
    chmod u+x $DEST
    echo $SRC $DEST
done
git add *
git commit -a -m "Hello, world"
#+END_SRC
** Software

This project uses software - bash, GRASS, Python, etc. The python environment is reproducible if you have Conda installed. Below I provide the version of the software(s) used to create this document in order to support the goal of bit-matching reproducibility. 

*** Git

Note - git version will always be dirty because or stale, because a document cannot contain its own check-in git version - the hash is generated after the check-in. Still, this may be useful as it records the previous commit.

#+BEGIN_SRC bash :results verbatim :eval no-export :exports both
git describe --always --dirty="*"
#+END_SRC

#+RESULTS:
: 310237f*

*** Emacs
#+BEGIN_SRC emacs-lisp :eval no-export :exports both
(emacs-version)
#+END_SRC

#+RESULTS:
: GNU Emacs 26.3 (build 2, x86_64-pc-linux-gnu, GTK+ Version 3.22.30)
:  of 2019-09-16

*** Org Mode
#+BEGIN_SRC emacs-lisp :eval no-export :exports both
(org-version nil t)
#+END_SRC

#+RESULTS:
: Org mode version 9.3.5 (9.3.5-elpa @ /home/kdm/.emacs.d/elpa/org-20200212/)

*** Bash
#+BEGIN_SRC bash :results verbatim :eval no-export :exports both
bash --version
#+END_SRC

#+RESULTS:
: GNU bash, version 4.4.20(1)-release (x86_64-pc-linux-gnu)
: Copyright (C) 2016 Free Software Foundation, Inc.
: This is free software; you are free to change and redistribute it.
: There is NO WARRANTY, to the extent permitted by law.

*** Python
**** Create or Clone Environment

#+BEGIN_SRC emacs-lisp :eval no :tangle .dir-locals.el
((nil . ((pyvenv-workon . "sci"))))
#+END_SRC

#+BEGIN_SRC bash :results verbatim :eval no :tangle .envrc
if [[ ${CONDA_DEFAULT_ENV} != "sci" ]]; then
  if [[ ! $INSIDE_EMACS ]]; then
    conda activate sci;
  fi
fi
#+END_SRC

**** Export for others to use

The code below should produce [[./environment.yml]] when this file is exported. If that file exists, then =conda env create= and =source activate PROJECTNAME= will install all the python packages used in this document.

#+NAME: conda_env 
#+BEGIN_SRC bash :cmdline -i :results verbatim :eval no-export :exports both
conda env export --name sci | cat
#+END_SRC

#+RESULTS: conda_env
#+begin_example
name: sci
channels:
  - https://repo.anaconda.com/pkgs/free
  - conda-forge
  - defaults
dependencies:
  - affine=2.2.1=py_0
  - asn1crypto=0.24.0=py36_1003
  - attrs=18.2.0=py_0
  - backcall=0.1.0=py_0
  - basemap=1.2.0=py36h705c2d8_0
  - blas=1.0=mkl
  - bokeh=1.0.1=py36_1000
  - boost-cpp=1.68.0=h3a22d5f_0
  - boto3=1.9.58=py_0
  - botocore=1.12.58=py_0
  - bottleneck=1.2.1=py36h7eb728f_1
  - bzip2=1.0.6=h470a237_2
  - ca-certificates=2019.11.28=hecc5488_0
  - cairo=1.14.12=he6fea26_5
  - certifi=2019.11.28=py36_0
  - cffi=1.11.5=py36h5e8e0c9_1
  - cftime=1.0.2.1=py36h7eb728f_0
  - click=7.0=py_0
  - click-plugins=1.0.4=py_0
  - cligj=0.5.0=py_0
  - cloudpickle=0.6.1=py_0
  - cryptography=2.6.1=py36h72c5cf5_0
  - cryptography-vectors=2.3.1=py36_1000
  - curl=7.64.1=hf8cf82a_0
  - cycler=0.10.0=py_1
  - cytoolz=0.9.0.1=py36h470a237_1
  - dask=0.20.0=py_0
  - dask-core=0.20.0=py_0
  - dbus=1.13.0=h3a4f0e9_0
  - decorator=4.3.0=py_0
  - descartes=1.1.0=py_2
  - dill=0.2.8.2=py36_1000
  - distributed=1.24.0=py36_1000
  - docutils=0.14=py36_1001
  - entrypoints=0.3=py36_1000
  - expat=2.2.5=hfc679d8_2
  - fontconfig=2.13.1=h65d0f4c_0
  - freetype=2.9.1=h6debe1e_4
  - freexl=1.0.5=h470a237_2
  - geos=3.6.2=hfc679d8_4
  - geotiff=1.4.2=h700e5ad_5
  - gettext=0.19.8.1=h5e8e0c9_1
  - giflib=5.1.4=h470a237_1
  - glib=2.55.0=h464dc38_2
  - gmp=6.1.2=hfc679d8_0
  - gst-plugins-base=1.12.5=hde13a9d_0
  - gstreamer=1.12.5=h61a6719_0
  - h5netcdf=0.6.2=py_0
  - h5py=2.8.0=py36h470a237_0
  - hdf4=4.2.13=h951d187_2
  - hdf5=1.10.1=2
  - heapdict=1.0.0=py36_1000
  - icu=58.2=hfc679d8_0
  - idna=2.8=py36_1000
  - intel-openmp=2019.0=118
  - ipykernel=5.1.0=pyh24bf2e0_0
  - ipython=7.1.1=py36h24bf2e0_1000
  - ipython_genutils=0.2.0=py_1
  - ipywidgets=7.4.2=py_0
  - jedi=0.15.2=py36_0
  - jinja2=2.10=py_1
  - jmespath=0.9.3=py_1
  - jpeg=9c=h470a237_1
  - json-c=0.12.1=h470a237_1
  - jsonschema=3.0.0a3=py36_1000
  - jupyter=1.0.0=py_1
  - jupyter_client=5.2.3=py_1
  - jupyter_console=6.0.0=py_0
  - jupyter_core=4.4.0=py_0
  - kealib=1.4.8=hfc679d8_0
  - kiwisolver=1.0.1=py36h2d50403_2
  - krb5=1.16.3=h05b26f9_1001
  - libblas=3.8.0=7_h6e990d7_netlib
  - libcblas=3.8.0=7_h6e990d7_netlib
  - libcurl=7.64.1=hda55be3_0
  - libdap4=3.19.1=h8fe5423_1
  - libedit=3.1.20170329=hf8c457e_1001
  - libffi=3.2.1=hfc679d8_5
  - libgcc-ng=8.2.0=hdf63c60_1
  - libgfortran=3.0.0=1
  - libgfortran-ng=7.2.0=hdf63c60_3
  - libiconv=1.15=h470a237_3
  - libkml=1.3.0=he469717_9
  - liblapack=3.8.0=7_h6e990d7_netlib
  - libnetcdf=4.4.1.1=10
  - libpng=1.6.35=ha92aebf_2
  - libpq=11.2=h4770945_0
  - libsodium=1.0.16=h470a237_1
  - libspatialindex=1.8.5=hfc679d8_3
  - libspatialite=4.3.0a=hdfcc80b_23
  - libssh2=1.8.2=h22169c7_2
  - libstdcxx-ng=7.3.0=hdf63c60_0
  - libtiff=4.0.9=he6b73bb_2
  - libuuid=2.32.1=h470a237_2
  - libxcb=1.13=h470a237_2
  - libxml2=2.9.8=h422b904_5
  - locket=0.2.0=py_2
  - markupsafe=1.0=py36h470a237_1
  - matplotlib=3.0.3=py36_0
  - matplotlib-base=3.0.3=py36h167e16e_0
  - mistune=0.8.4=py36h470a237_0
  - mkl=2018.0.3=1
  - mkl_fft=1.0.6=py36_0
  - mkl_random=1.0.1=py36_0
  - msgpack-python=0.5.6=py36h2d50403_3
  - munch=2.3.2=py_0
  - nbconvert=5.3.1=py_1
  - nbformat=4.4.0=py_1
  - ncurses=6.1=hfc679d8_1
  - netcdf4=1.3.1=py36_1
  - notebook=5.7.0=py36_1000
  - olefile=0.46=py_0
  - openblas=0.3.3=ha44fe06_1
  - openjpeg=2.3.0=h0e734dc_3
  - openssl=1.1.1d=h516909a_0
  - packaging=18.0=py_0
  - pandoc=2.3.1=0
  - pandocfilters=1.4.2=py_1
  - parso=0.5.2=py_0
  - partd=0.3.9=py_0
  - patsy=0.5.1=py_0
  - pcre=8.41=hfc679d8_3
  - pexpect=4.6.0=py36_1000
  - pickleshare=0.7.5=py36_1000
  - pillow=5.3.0=py36hc736899_0
  - pint=0.8.1=py_1
  - pip=18.1=py36_1000
  - pixman=0.34.0=h470a237_3
  - poppler=0.61.1=h4d7e492_4
  - poppler-data=0.4.9=0
  - postgresql=11.2=h61314c7_0
  - proj4=4.9.3=h470a237_8
  - prometheus_client=0.4.2=py_0
  - prompt_toolkit=2.0.7=py_0
  - psutil=5.4.8=py36h470a237_0
  - psycopg2=2.8.1=py36h72c5cf5_0
  - pthread-stubs=0.4=h470a237_1
  - ptyprocess=0.6.0=py36_1000
  - pycparser=2.19=py_0
  - pygments=2.2.0=py_1
  - pyopenssl=18.0.0=py36_1000
  - pyparsing=2.3.0=py_0
  - pyproj=1.9.5.1=py36h508ed2a_6
  - pyqt=4.11.4=py36_3
  - pyrsistent=0.14.5=py36h470a237_1
  - pysal=1.14.4.post2=py36_1001
  - pyshp=1.2.12=py_2
  - pysocks=1.6.8=py36_1002
  - python=3.6.7=h0371630_0
  - python-dateutil=2.7.5=py_0
  - pytz=2018.7=py_0
  - pyyaml=3.13=py36h470a237_1
  - pyzmq=17.1.2=py36hae99301_1
  - qt=4.8.7=2
  - qtconsole=4.4.2=py_1
  - readline=7.0=haf1bffa_1
  - rtree=0.8.3=py36_1000
  - s3transfer=0.1.13=py36_1001
  - scipy=1.1.0=py36hc49cb51_0
  - send2trash=1.5.0=py_0
  - setuptools=40.5.0=py36_0
  - shapely=1.6.4=py36h164cb2d_1
  - simplejson=3.16.1=py36h470a237_0
  - simplekml=1.3.0=py_1
  - sip=4.18=py36_1
  - six=1.14.0=py36_0
  - snuggs=1.4.1=py_1
  - sortedcontainers=2.0.5=py_0
  - sqlalchemy=1.2.15=py36h470a237_0
  - sqlite=3.25.2=hb1c47c0_0
  - statsmodels=0.9.0=py36h7eb728f_0
  - tabulate=0.8.2=py_0
  - tblib=1.3.2=py_1
  - terminado=0.8.1=py36_1001
  - testpath=0.4.2=py36_1000
  - tk=8.6.9=h84994c4_1001
  - toolz=0.9.0=py_1
  - tornado=5.1.1=py36h470a237_0
  - traitlets=4.3.2=py36_1000
  - tzcode=2018g=h14c3975_1001
  - urllib3=1.24.1=py36_1000
  - wcwidth=0.1.7=py_1
  - wheel=0.32.2=py36_0
  - widgetsnbextension=3.4.2=py36_1000
  - xarray=0.14.1=py_0
  - xerces-c=3.2.0=h5d6a6da_2
  - xorg-kbproto=1.0.7=h470a237_2
  - xorg-libice=1.0.9=h470a237_4
  - xorg-libsm=1.2.3=h8c8a85c_0
  - xorg-libx11=1.6.6=h470a237_0
  - xorg-libxau=1.0.8=h470a237_6
  - xorg-libxdmcp=1.1.2=h470a237_7
  - xorg-libxext=1.3.3=h470a237_4
  - xorg-libxrender=0.9.10=h470a237_2
  - xorg-renderproto=0.11.1=h470a237_2
  - xorg-xextproto=7.3.0=h470a237_2
  - xorg-xproto=7.0.31=h470a237_7
  - xz=5.2.4=h470a237_1
  - yaml=0.1.7=h470a237_1
  - zeromq=4.2.5=hfc679d8_6
  - zict=0.1.3=py_0
  - zlib=1.2.11=h470a237_3
  - pip:
    - atomicwrites==1.3.0
    - bleach==3.0.2
    - cfchecker==4.0.0
    - cfunits==3.2.2
    - chardet==3.0.4
    - csvs-to-sqlite==1.0
    - dateparser==0.7.1
    - fastkml==0.11
    - fiona==1.8.11
    - future==0.17.1
    - geopandas==0.6.2
    - grass-session==0.1
    - ical2orgpy==0.2.0
    - icalendar==4.0.3
    - importlib-metadata==0.18
    - more-itertools==7.2.0
    - mpmath==1.1.0
    - numpy==1.17.4
    - pandas==0.25.1
    - pluggy==0.12.0
    - py==1.8.0
    - py-lru-cache==0.1.4
    - pycwt==0.3.0a22
    - pygeoif==0.7
    - pytest==5.0.1
    - q==2.6
    - rasterio==1.1.0
    - regex==2019.8.19
    - seaborn==0.9.0
    - sty==1.0.0b9
    - sympy==1.3
    - tqdm==4.28.1
    - tzlocal==1.5.1
    - uncertainties==3.1.2
    - webencodings==0.5.1
    - xlrd==1.2.0
    - zipp==0.5.2
prefix: /home/kdm/local/anaconda/envs/sci

#+end_example

*** LaTeX
#+BEGIN_SRC bash :cmdline "-i" :results verbatim :eval no-export  :exports both
pdflatex --version
#+END_SRC

#+RESULTS:
#+begin_example
pdfTeX 3.14159265-2.6-1.40.18 (TeX Live 2017/Debian)
kpathsea version 6.2.3
Copyright 2017 Han The Thanh (pdfTeX) et al.
There is NO warranty.  Redistribution of this software is
covered by the terms of both the pdfTeX copyright and
the Lesser GNU General Public License.
For more information about these matters, see the file
named COPYING and the pdfTeX source.
Primary author of pdfTeX: Han The Thanh (pdfTeX) et al.
Compiled with libpng 1.6.34; using libpng 1.6.34
Compiled with zlib 1.2.11; using zlib 1.2.11
Compiled with poppler version 0.62.0
#+end_example


* LaTeX Setup                                           :noexport:
#+NAME: copernicus-latex-setup
#+BEGIN_SRC emacs-lisp :results none :eval no-export
(add-to-list 'org-latex-classes
               `("copernicus"
                 "\\documentclass{copernicus}
               [NO-DEFAULT-PACKAGES]
               [NO-PACKAGES]
               [EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )

(setq-local org-latex-title-command "")
#+END_SRC

